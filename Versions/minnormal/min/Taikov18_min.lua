local g;Split=function(l,m)local n={}for o,p in l:gmatch("([^"..m.."]*)("..m.."?)")do table.insert(n,o)if p==''then return n end end end;Trim=function(l)local m=l:gsub("^%s*(.-)%s*$","%1")return m end;TrimLeft=function(l)local m=l:gsub("^%s*(.-)$","%1")return m end;TrimRight=function(l)local m=l:gsub("^(.-)%s*$","%1")return m end;StartsWith=function(l,m)return l:sub(1,#m)==m end;EndsWith=function(l,m)return l:sub(-#m,-1)==m end;Table={}function Table.Clone(l,m)m=m or{}local n=type(l)local o;if n=='table'then if m[l]then o=m[l]else o={}m[l]=o;for p,q in next,l,nil do o[Table.Clone(p,m)]=Table.Clone(q,m)end;setmetatable(o,Table.Clone(getmetatable(l),m))end else o=l end;return o end;ClipN=function(l,m,o)if l<m then return m elseif l>o then return o else return l end end;function Error(l)error(l)end;LineN=nil;function ParseError(l,m,n)Error('Line: '..LineN..'\n'..l..': '..m.. (n and(', '..n)or''))end;function MsToS(l)return l/1000 end;function SToMs(l)return l*1000 end;Taiko={}Taiko.Data={Languages={'','EN','JA','CN','TW','KO'},GenreName={Pop={'pop','j-pop'},Anime={'anime','アニメ'},Kids={'kids','どうよう'},Variety={'variety','バラエティ'},VOCALOID={'vocaloid','ボーカロイド'},Classic={'classic','クラシック'},['Game Music']={'game music','ゲームミュージック'},['Namco Original']={'namco original','ナムコオリジナル'}},CourseId={easy=0,normal=1,hard=2,oni=3,edit=4,tower=5,dan=6,ura=4},CourseName={[0]='Easy','Normal','Hard','Oni','Edit','Tower','Dan','Ura'},RatingMultiplier={[0]=0,[1]=0.5,[2]=1,[3]=2},GogoMultiplier=1.2,ScoreMode={[0]=function(l,m,n,o,p,q)return l+ ( ( (m<200)and(n or 1000)or( (n or 1000)+ (o or 1000)))*Taiko.Data.RatingMultiplier[p]* (q and Taiko.Data.GogoMultiplier or 1))end,[1]=function(l,m,n,o,p,q)return l+ ( (n+math.max(0,o*math.floor((math.min(m,100)-1)/10)))*Taiko.Data.RatingMultiplier[p]* (q and Taiko.Data.GogoMultiplier or 1))end,[2]=function(l,m,n,o,p,q)return l+ ( (n+o* ( (m>=100)and 8 or(m>=50)and 4 or(m>=30)and 2 or(m>=10)and 1 or 0))*Taiko.Data.RatingMultiplier[p]* (q and Taiko.Data.GogoMultiplier or 1))end},Autoscore={[0]=function(l)end,[1]=function(l)end,[2]=function(l)end},SideId={normal=1,ex=2,both=3},SideName={'normal','ex','both'},StyleId={single=1,double=2,couple=2},StyleName={'single','double'},Exam={Condition={g=true,jp=true,jg=true,jb=true,s=true,r=true,h=true,c=true},Scope={m=true,l=true}},Branch={PathId={N=0,E=1,M=2},PathName={[0]='N',[1]='E',[2]='M'},Requirements={r=function()end,p=function()end}},Timing={GetFunction=function(l)return function(m)if l==1 then return{good=5 /2 *m,ok=13 /2 *m,bad=15 /2 *m}else return{good=3 /2 *m,ok=9 /2 *m,bad=13 /2 *m}end end end},StatusId={bad=0,ok=1,good=2,biggood=3},StatusName={[0]='BAD',[1]='OK',[2]='GOOD',[3]='GOOD'},ModeId={['']=0,P1=1,P2=2},ModeName={[0]='',P1,P2},Combo={[1]=true,[2]=true,[3]=true,[4]=true},BigLeniency=2,Strings={Notes={}}}for l,m in pairs(Taiko.Data.ScoreMode)do Taiko.Data.ScoreMode[l]=function(...)return math.floor(m(...)/10)*10 end end;function Taiko.ParseTJA(l)local m=os.clock()local n={}local o={Metadata={SUBTITLE='',BPM=120,WAVE='main.mp3',OFFSET=0,DEMOSTART=0,SCOREMODE=1,SONGVOL=100,SEVOL=100,SIDE=3,LIFE=0,GAME='Taiko',HEADSCROLL=1,MOVIEOFFSET=0,COURSE='ONI',LEVEL=0,BALLOON=nil,SCOREINIT,SCOREDIFF,BALLOONNOR=nil,BALLOONEXP=nil,BALLOONMAS=nil,STYLE=1,EXAM1=nil,EXAM2=nil,EXAM3=nil,GAUGEINCR='NORMAL',TOTAL=nil,HIDDENBRANCH=0,DIVERGENOTES=false,SCOREINIT=0,SCOREDIFF=0},Data={}}local function p(B)local C=Taiko.Data.Languages;for i=1,#C do local D=o.Metadata[B..C[i]]if D then return D end end;return nil end;local function q(B,C,D)local E=tonumber(C)if E then return E else ParseError(B,D,C)end end;local function r(B,C,D,E)if C then return C else ParseError(B,D,E)end end;local function s(B,C,D)local E={['true']=true,['false']=false,yes=true,no=false,['1']=true,['0']=false,[1]=true,[0]=false}local F=E[C]~=nil;if F then return F else ParseError(B,D,C)end end;local function u(B,C)local D=','local E='\\'local F={}local G=''local H=false;for i=1,#C do local I=string.sub(C,i,i)if H then G=G..I;H=false else if I==D then table.insert(F,G)G=''elseif I==E then H=true else G=G..I end end end;table.insert(F,G)return F end;local function v(B,C,D)local E=u(B,C)for i=1,#E do E[i]=q(B,E[i],D,C)end;return E end;local function w(B,C,D)if C and C~=''then return v(B,C,D)else return{}end end;local function x(B,C,D)if C and C~=''then local E=u(B,C,D)r(B,Taiko.Data.Exam.Condition[E[1]],D)E[2]=q(B,E[2],D)E[3]=q(B,E[3],D)r(B,Taiko.Data.Exam.Scope[E[4]],D)return E else return{}end end;local y={}local function z()local B={settings={noteparse={notealias={A=3,B=4},noteexceptions={[',']=true,[' ']=true,['\t']=true}},command={matchexceptions={}}},bpm=0,ms=0,songstarted=false,timingpoint=nil,sign=4 /4,mpm=0,mspermeasure=0,scroll=1,measuredone=true,currentmeasure={},measurepushto=o.Data,barline=true,gogo=false,lastlong=nil,balloonn=1,currentbranch=nil,branch={on=false,requirements={},paths={}},msbeforebranch=nil,section=false,notechain={}}function B.createnote(C)if C then local D={ms=nil,data=nil,type=C,txt=nil,gogo=B.gogo,scroll=(B.scroll*o.Metadata.HEADSCROLL),mspermeasure=B.mspermeasure,bpm=B.bpm,nextnote=nil,radius=1,requiredhits=nil,length=nil,endnote=nil,section=nil,text=nil,onnotepush=nil}D.type=C;if C==3 or C==4 or C==6 then D.radius=D.radius*1.6 end;if C==5 or C==6 or C==7 or C==9 then if B.lastlong then if C==9 then else ParseError('parser.noteparse','Last long note has not ended')end else B.lastlong=D;if C==7 or C==9 then D.requiredhits=r('parser.noteparse',o.Metadata.BALLOON[B.balloonn],'Invalid number of balloons',B.balloonn)B.balloonn=B.balloonn+1 end end end;if C==8 then local E=B.lastlong;B.lastlong=nil;D.startnote=E;if E then D.onnotepush=function()E.length=D.ms-E.ms;E.endnote=D end else end end;if B.section then D.section=true;B.section=false end;return D else return{ms=nil,data=nil,type=nil,txt=nil,gogo=B.gogo,scroll=(B.scroll*o.Metadata.HEADSCROLL),mspermeasure=B.mspermeasure,bpm=B.bpm,nextnote=nil}end end;function B.endbranch()local C=B.createnote()C.data='event'C.event='branch'C.branch={requirements=B.branch.requirements,paths=B.branch.paths}B.branch.on=false;B.branch.requirements={}B.branch.paths={}table.insert(o.Data,C)B.measurepushto=o.Data end;return B end;y=z()local A=Split(l,'\n')for i=1,#A do LineN=i;local B=Trim(A[i])if StartsWith(B,'//')or B==''then else local C=string.find(B,'//')if C then B=string.sub(B,1,C-1)end;local D=false;if y.songstarted==false and D==false then local E={string.match(B,'(%u+):(.*)')}if E[1]then local F=Trim(E[2])if F~=''then o.Metadata[Trim(E[1])]=F end;D=true end end;if(y.songstarted or StartsWith(B,'#START'))and D==false then local E={string.match(B,'#(%u-)%s(.*)')}if not E[1]then E={string.match(B,'#(%u+)')}end;if E[1]then if E[1]=='START'then if y.songstarted then ParseError(E[1],'Song has already started')else o.OriginalMetadata=Table.Clone(o.Metadata)if E[2]then o.Metadata.MODE=r(E[1],Taiko.Data.ModeId[E[2]],'Invalid mode',E[2])else o.Metadata.MODE=0 end;o.Metadata.TITLE=r(E[1],p('TITLE'),'Title is missing')o.Metadata.SUBTITLE=r(E[1],p('SUBTITLE'),'Subtitle is missing')o.Metadata.BPM=q(E[1],o.Metadata.BPM,'Invalid bpm')o.Metadata.OFFSET=SToMs(q(E[1],o.Metadata.OFFSET,'Invalid offset'))o.Metadata.DEMOSTART=SToMs(q(E[1],o.Metadata.DEMOSTART,'Invalid demostart'))if o.Metadata.DEMOSTART==0 then o.Metadata.DEMOSTART=nil end;for I,J in pairs(Taiko.Data.GenreName)do for i=1,#J do if J[i]==o.Metadata.GENRE then o.Metadata.GENRE=I end end end;o.Metadata.SCOREMODE=q(E[1],o.Metadata.SCOREMODE,'Invalid scoremode')r(E[1],Taiko.Data.ScoreMode[o.Metadata.SCOREMODE],'Invalid scoremode',o.Metadata.SCOREMODE)if o.Metadata.MAKER then o.Metadata.CREATORURLT={}o.Metadata.CREATOR=Trim(string.gsub(o.Metadata.MAKER,'(<.->)',function(I)table.insert(o.Metadata.CREATORURLT,string.sub(I,2,-2))return''end))o.Metadata.CREATORURL=table.concat(o.Metadata.CREATORURLT,', ')o.Metadata.CREATIVE=false else o.Metadata.CREATIVE=false end;o.Metadata.SONGVOL=q(E[1],o.Metadata.SONGVOL,'Invalid songvol')/100;o.Metadata.SEVOL=q(E[1],o.Metadata.SEVOL,'Invalid sevol')/100;local F=tonumber(o.Metadata.SIDE)if F then r(E[1],Taiko.Data.SideName[F],'Invalid side id',o.Metadata.SIDE)o.Metadata.SIDE=F else o.Metadata.SIDE=r(E[1],Taiko.Data.SideId[string.lower(o.Metadata.SIDE)],'Invalid side name',o.Metadata.SIDE)end;o.Metadata.LIFE=q(E[1],o.Metadata.LIFE,'Invalid life')if o.Metadata.LIFE==0 then o.Metadata.LIFE=nil end;o.Metadata.GAME=string.lower(o.Metadata.GAME)if o.Metadata.GAME=='taiko'then elseif o.Metadata.GAME=='jube'then else end;o.Metadata.HEADSCROLL=q(E[1],o.Metadata.HEADSCROLL,'Invalid headscroll')o.Metadata.MOVIEOFFSET=q(E[1],o.Metadata.MOVIEOFFSET,'Invalid movieoffset')local G=tonumber(o.Metadata.COURSE)if G then r(E[1],Taiko.Data.CourseName[G],'Invalid course id',o.Metadata.COURSE)o.Metadata.COURSE=G else o.Metadata.COURSE=r(E[1],Taiko.Data.CourseId[string.lower(o.Metadata.COURSE)],'Invalid course name',o.Metadata.COURSE)end;o.Metadata.TIMING=Taiko.Data.Timing.GetFunction(o.Metadata.COURSE)o.Metadata.LEVEL=ClipN(math.floor(q(E[1],o.Metadata.LEVEL,'Invalid level')),0,10)o.Metadata.BALLOON=w(E[1],o.Metadata.BALLOON,'Invalid balloon')o.Metadata.SCOREINIT=q(E[1],o.Metadata.SCOREINIT,'Invalid scoreinit')o.Metadata.SCOREDIFF=q(E[1],o.Metadata.SCOREDIFF,'Invalid scoreinit')o.Metadata.BALLOONNOR=w(E[1],o.Metadata.BALLOONNOR,'Invalid balloonnor')o.Metadata.BALLOONEXP=w(E[1],o.Metadata.BALLOONEXP,'Invalid balloonexp')o.Metadata.BALLOONMAS=w(E[1],o.Metadata.BALLOONMAS,'Invalid balloonmas')local H=tonumber(o.Metadata.STYLE)if H then r(E[1],Taiko.Data.StyleName[H],'Invalid style id',Taiko.Data.STYLE)o.Metadata.STYLE=H else o.Metadata.STYLE=r(E[1],Taiko.Data.StyleId[string.lower(o.Metadata.STYLE)],'Invalid style name',o.Metadata.STYLE)end;o.Metadata.EXAM1=x(o.Metadata.EXAM1)o.Metadata.EXAM2=x(o.Metadata.EXAM2)o.Metadata.EXAM3=x(o.Metadata.EXAM3)o.Metadata.GAUGEINCR=string.lower(o.Metadata.GAUGEINCR)if o.Metadata.TOTAL then o.Metadata.TOTAL=q(E[1],o.Metadata.TOTAL,'Invalid total')end;o.Metadata.HIDDENBRANCH=s(E[1],o.Metadata.HIDDENBRANCH,'Invalid hiddenbranch')y.bpm=o.Metadata.BPM;y.songstarted=true end elseif E[1]=='END'then if y.songstarted then if#y.currentmeasure~=0 then ParseError(E[1],'Current measure is not empty')end;table.insert(n,o)o={Metadata=Table.Clone(o.OriginalMetadata),Data={}}y=z()y.songstarted=false;y.measurepushto=o.Data else ParseError(E[1],'Song has already ended')end elseif E[1]=='MEASURE'then local F,G=string.match(E[2],'(%d+)/(%d+)')F=q(E[1],F,'Invalid measure')G=q(E[1],G,'Invalid measure')y.sign=(F/G)or y.sign elseif E[1]=='BPMCHANGE'then y.bpm=q(E[1],E[2],'Invalid bpmchange')or y.bpm elseif E[1]=='DELAY'then table.insert(y.currentmeasure,{E[1],SToMs((q(E[1],E[2],'Invalid delay')or 0))})elseif E[1]=='SCROLL'then y.scroll=q(E[1],E[2],'Invalid scroll')or y.scroll;if y.scroll==0 then ParseError(E[1],'Scroll cannot be 0')end elseif E[1]=='GOGOSTART'then y.gogo=true elseif E[1]=='GOGOEND'then y.gogo=false elseif E[1]=='BARLINEOFF'then y.barline=false elseif E[1]=='BARLINEON'then y.barline=true elseif E[1]=='BRANCHSTART'then if y.branch.on then y.endbranch()end;y.msbeforebranch=y.ms;y.branch.on=true;o.Metadata.DIVERGENOTES=true;local F=u(E[1],E[2])local G=r(E[1],Taiko.Data.Branch.Requirements[string.lower(F[1])],'Invalid type',F[1])y.branch.requirements={G}local H=2;while true do if not F[H]then break end;local I=Taiko.Data.Branch.PathName[H-1]if I then y.branch.requirements[I]=F[H]else break end;H=H+1 end elseif Taiko.Data.Branch.PathId[E[1]]then if y.branch.on then y.ms=y.msbeforebranch;y.currentbranch=E[1]y.branch.paths[E[1]]={}y.measurepushto=y.branch.paths[E[1]]else ParseError(E[1],'Branch has not started')end elseif E[1]=='BRANCHEND'then if y.branch.on then y.endbranch()else ParseError(E[1],'Branch has already ended')end elseif E[1]=='SECTION'then y.section=true elseif E[1]=='LYRIC'then elseif E[1]=='LEVELHOLD'then elseif E[1]=='BMSCROLL'then elseif E[1]=='HBSCROLL'then elseif E[1]=='SENOTECHANGE'then elseif E[1]=='NEXTSONG'then elseif E[1]=='DIRECTION'then elseif E[1]=='SUDDEN'then elseif E[1]=='JPOSSCROLL'then else end;D=true end end;if(y.songstarted)and D==false then y.mpm=y.bpm*y.sign/4;y.mspermeasure=60000 *y.sign*4 /y.bpm;if y.barline and#y.currentmeasure==0 then local E=y.createnote()E.ms=y.ms;E.data='event'E.event='barline'table.insert(y.measurepushto,1,E)end;for i=1,#B do local E=string.sub(B,i,i)if y.settings.noteparse.noteexceptions[E]then else local F=q('parser.noteparse',tonumber(E)or y.settings.noteparse.notealias[E]or E,'Invalid note')if F then local G=y.createnote(F)G.data='note'table.insert(y.currentmeasure,G)end end end;if EndsWith(TrimRight(B),',')then y.mpm=y.bpm*y.sign/4;y.mspermeasure=60000 *y.sign*4 /y.bpm;if#y.currentmeasure==0 then y.ms=y.ms+y.mspermeasure else local E=0;local F=nil;for i=1,#y.currentmeasure do local H=y.currentmeasure[i]if H.data=='note'then F=F or H.mspermeasure;E=E+1 end end;F=F or y.mspermeasure;local G=F/E;for i=1,#y.currentmeasure do local H=y.currentmeasure[i]if H[1]=='DELAY'then y.ms=y.ms+H[2]else if H.type~=0 then H.ms=y.ms;local I=o.Data[#o.Data]if I then I.nextnote=H end;table.insert(y.measurepushto,H)if H.onnotepush then H.onnotepush()end;G=H.mspermeasure/E end end;y.ms=y.ms+G end end;y.measuredone=true;y.currentmeasure={}else y.measuredone=false end end end end;print('Parsing Took: '..SToMs(os.clock()-m)..'ms')return n end;function Taiko.Score(l,m,n,o,p)if o==0 then n=0 else n=n+1 end;local q=l.Metadata;return Taiko.Data.ScoreMode[q.SCOREMODE](m,n,q.SCOREINIT,q.SCOREDIFF,o,p),n end;function Taiko.Analyze(l)local m='M'local n={[1]=2,[2]=2,[3]=3,[4]=3}local o={notes={n=0,validn=0},measures=0,lengthms=0,drumrollms=0,drumrollbigms=0,balloonms=0,balloonhit=0,specialms=0,specialhit=0,maxcombo=0,maxscore=0}local p=nil;Taiko.ForAll(l.Data,function(q,r,s)if q.data=='note'then o.notes.n=o.notes.n+1;o.notes[q.type]=o.notes[q.type]and o.notes[q.type]+1 or 1;if n[q.type]then o.maxscore,o.maxcombo=Taiko.Score(l,o.maxscore,o.maxcombo,n[q.type],q.gogo)end;local u=q.endnote;if u then local v=u.ms-q.ms;if q.type==5 then o.drumrollms=o.drumrollms+v elseif q.type==6 then o.drumrollbigms=o.drumrollbigms+v elseif q.type==7 then o.balloonms=o.balloonms+v;o.balloonhit=o.balloonhit+q.requiredhits elseif q.type==9 then o.specialms=o.specialms+v;o.specialhit=o.specialhit+q.requiredhits else end end;p=q elseif q.data=='event'and q.event=='barline'then o.measures=o.measures+1 else end end,m)o.lengthms=p.ms-l.Metadata.OFFSET;o.notes.validn=o.maxcombo;return o end;function Taiko.GetDifficulty(l,m)local n=Taiko.Data.CourseId[string.lower(m)]or m;for o,p in pairs(l)do if p.Metadata.COURSE==n then return p end end;Error('No difficulty found, '..m)return nil end;function Taiko.ForAll(l,m,n)local o=1;for i=1,#l do local p=l[i]if p.branch then if n then local q=p.branch.paths[n]for i2=1,#q do m(q[i2],i2,o)o=o+1 end;o=o-1 else local q=-1;for r,s in pairs(p.branch.paths)do local u=o;for i2=1,#s do m(s[i2],i2,u)u=u+1 end;q=(q<u)and u or q end;o=q end else m(p,i,o)end;o=o+1 end;return l end;function Taiko.GetAllNotes(l)local m={}for n,o in pairs(l)do if o.branch then for p,q in pairs(o.branch.paths)do for i=1,#q do table.insert(m,q[i])end end else table.insert(m,o)end end;return m end;function Taiko.ConnectNotes(l)local m=nil;for i=#l,1,-1 do local o=l[i]o.nextnote=m;m=o end;return l end;function Taiko.ExtractBranch(l,m)return l.branch.paths[m]end;function Taiko.ConnectAll(l)local m=nil;for i=#l,1,-1 do local n=l[i]if n.branch then for o,p in pairs(n.branch.paths)do local q=Taiko.ConnectNotes(p)q[#q].nextnote=m end else n.nextnote=m end;m=n end end;function Taiko.CalculateSpeed(l,m)local n=(m*l.scroll*l.bpm/7500)return n end;function Taiko.CalculateSpeedAll(l,m)for i=1,#l do l[i].speed=Taiko.CalculateSpeed(l[i],m)end;return l end;function Taiko.RenderScale(l)local m={}local n={}local o={}for i=1,#l.Data do local s=l.Data[i]if s.data=='note'then local u=math.floor(s.ms)if math.floor(u)-u==0 then table.insert(m,{u,s.type})table.insert(n,u)else table.insert(o,i)end end end;function gcd2(s,u)if u==0 then return s else return gcd2(u,s%u)end end;function gcdn(s)local u=s[1]for i=2,#s do u=gcd2(u,s[i])end;return u end;local p=gcdn(n)for i=1,#o do local s=m[o[i]]s[1]=math.floor(s[1]/p)*p end;local q=''local r=0;for i=1,#m do m[i][1]=m[i][1]/p;q=q..string.rep(' ',m[i][1]-r)..m[i][2]r=m[i][1]end;return q end;function Taiko.PlaySong(l,m,n,o)local p={on=false,fps=60,frames={}}local q=nil;local r={auto={[1]=false,[2]=true},notespeedmul={[1]=1,[2]=2,[3]=3,[4]=4,[5]=0.25,[6]=0.5,[7]=0.75},songspeedmul={[1]=1,[2]=2,[3]=3,[4]=4,[5]=0.25,[6]=0.5,[7]=0.75}}local s=r.auto[n[2]]or false;local u=false;local v=r.notespeedmul[n[3]]or 1;local w=r.songspeedmul[n[4]]or 1;local x=o or{}x={Hit=x.Hit or{['4']=2,['v']=1,['n']=1,['8']=2},Escape=x.Escape or{['\27']=true,ALT_ESC=true},L=x.L or{KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_A2=true},R=x.R or{KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true},Select=x.Select or{KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}}local z=1;local A=2;local B='>'local C='\n\n\n'local D=10;local E=1000;local F=4;local G=0;local H=10;local I=0;local J=40;local K=3;local L=1;local M={[1]={color='red'},[2]={color='blue'},[3]={color='red'},[4]={color='blue'},[5]={color='yellow'},[6]={color='yellow'}}local N=200;local O=N/4;local P=4;local Q=20;J=math.floor(J*F)local R=I+J;K=math.floor(K*F)local S=require('taikocurses')local T=m or{window=S.initscr()}S.keypad(T,true)S.echo(false)S.raw(true)S.nl(false)S.cbreak(true)S.nodelay(T,true)local U={[0]={Data={[1]={'0','1','1','1','1','1','1','1'},[2]={[2]='1',[5]='1',[8]='1'},[3]={[2]='1',[5]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={[3]='1',[4]='1',[6]='1',[7]='1'},[8]={'0','0','1','1','1','1','1','1'},[9]={[2]='1',[5]='1'},[10]={[2]='1',[5]='1'},[11]={[2]='1',[5]='1'},[12]={[2]='1',[5]='1'},[13]={'0','0','1','1','1','1','1','1'},[15]={'0','1','1','1','1','1','1','1'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'}},Color={All='blue'},Offset={-1,0}},[1]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[8]='1'},[5]={[2]='1',[8]='1'},[6]={'0','0','1','1','1','1','1','0'},[8]={'0','1','1','1','1','1','1','1'},[9]={[5]='1'},[10]={[4]='1',[6]='1'},[11]={[3]='1',[7]='1'},[12]={[2]='1',[8]='1'}},Color={All='white'},Offset={-1,0}},[2]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={'0','1','0','0','1','1','1','1'},[8]={'0','0','1','1','1','1','1','0'},[9]={[2]='1',[8]='1'},[10]={[2]='1',[8]='1'},[11]={[2]='1',[8]='1'},[12]={[2]='1',[8]='1'},[13]={'0','0','1','1','1','1','1','0'},[15]={'0','0','1','1','1','1','1','0'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'},[22]={'0','1','1','1','1','1','1','1'},[23]={[2]='1',[8]='1'},[24]={[2]='1',[8]='1'},[25]={[2]='1',[8]='1'},[26]={[2]='1',[8]='1'},[27]={'0','0','1','1','1','1','1','0'}},Color={All='yellow'},Offset={-1,0}},Size={27,8}}U[3]=U[2]local V={[0]=nil,[1]={},[2]={}}local W;if g then W=g else os.execute('chcp 65001')W={}local Ob=([[
⠀ ⢀ ⠠ ⢠ ⠐ ⢐ ⠰ ⢰ ⠈ ⢈ ⠨ ⢨ ⠘ ⢘ ⠸ ⢸
⡀ ⣀ ⡠ ⣠ ⡐ ⣐ ⡰ ⣰ ⡈ ⣈ ⡨ ⣨ ⡘ ⣘ ⡸ ⣸
⠄ ⢄ ⠤ ⢤ ⠔ ⢔ ⠴ ⢴ ⠌ ⢌ ⠬ ⢬ ⠜ ⢜ ⠼ ⢼
⡄ ⣄ ⡤ ⣤ ⡔ ⣔ ⡴ ⣴ ⡌ ⣌ ⡬ ⣬ ⡜ ⣜ ⡼ ⣼
⠂ ⢂ ⠢ ⢢ ⠒ ⢒ ⠲ ⢲ ⠊ ⢊ ⠪ ⢪ ⠚ ⢚ ⠺ ⢺
⡂ ⣂ ⡢ ⣢ ⡒ ⣒ ⡲ ⣲ ⡊ ⣊ ⡪ ⣪ ⡚ ⣚ ⡺ ⣺
⠆ ⢆ ⠦ ⢦ ⠖ ⢖ ⠶ ⢶ ⠎ ⢎ ⠮ ⢮ ⠞ ⢞ ⠾ ⢾
⡆ ⣆ ⡦ ⣦ ⡖ ⣖ ⡶ ⣶ ⡎ ⣎ ⡮ ⣮ ⡞ ⣞ ⡾ ⣾
⠁ ⢁ ⠡ ⢡ ⠑ ⢑ ⠱ ⢱ ⠉ ⢉ ⠩ ⢩ ⠙ ⢙ ⠹ ⢹
⡁ ⣁ ⡡ ⣡ ⡑ ⣑ ⡱ ⣱ ⡉ ⣉ ⡩ ⣩ ⡙ ⣙ ⡹ ⣹
⠅ ⢅ ⠥ ⢥ ⠕ ⢕ ⠵ ⢵ ⠍ ⢍ ⠭ ⢭ ⠝ ⢝ ⠽ ⢽
⡅ ⣅ ⡥ ⣥ ⡕ ⣕ ⡵ ⣵ ⡍ ⣍ ⡭ ⣭ ⡝ ⣝ ⡽ ⣽
⠃ ⢃ ⠣ ⢣ ⠓ ⢓ ⠳ ⢳ ⠋ ⢋ ⠫ ⢫ ⠛ ⢛ ⠻ ⢻
⡃ ⣃ ⡣ ⣣ ⡓ ⣓ ⡳ ⣳ ⡋ ⣋ ⡫ ⣫ ⡛ ⣛ ⡻ ⣻
⠇ ⢇ ⠧ ⢧ ⠗ ⢗ ⠷ ⢷ ⠏ ⢏ ⠯ ⢯ ⠟ ⢟ ⠿ ⢿
⡇ ⣇ ⡧ ⣧ ⡗ ⣗ ⡷ ⣷ ⡏ ⣏ ⡯ ⣯ ⡟ ⣟ ⡿ ⣿]]):gsub('\n',' ')function GenerateDotData()function ToBinary(ac)local bc={}while ac>0 do local dc=math.fmod(ac,2)bc[#bc+1]=string.sub(dc,1,1)ac=(ac-dc)/2 end;local cc=string.reverse(table.concat(bc))return string.rep('0',8 -#cc)..cc end;local function Ub(ac)return ac end;local Vb=Split(Ob,' ')local Wb={}local Xb=false;local Yb=''local Zb=' 'for i=1,#Vb do Wb[i-1]=Ub(Vb[i])end;return Wb end;W.Data={}W.Data.Dot=GenerateDotData()W.ColorData={reset=0,clear=0,space=0,bright=1,bold=1,dim=2,faint=1,italic=3,underline=4,blink=5,reverse=7,invisible=8,hidden=8,strikethrough=9,black=30,red=31,green=32,yellow=33,blue=34,purple=35,magenta=35,cyan=36,white=37,onblack=40,onred=41,ongreen=42,onyellow=43,onblue=44,onpurple=45,onmagenta=45,oncyan=46,onwhite=47}W.Color={}for Ub,Vb in pairs(W.ColorData)do W.Color[Ub]='\27['..Vb..'m'end;local Pb,Qb=I,J;local Rb,Sb=-H,H;Rb,Sb=-20,20;W.Convert={}W.Convert.ToDots=function(Ub,Vb)Vb=Vb or 0;local Wb,Xb=Pb+Vb,Qb+Vb;local Yb,Zb=Ub.Data,Ub.Color;local ac={}local bc=0;local cc=W.Data.Dot[bc]local dc=nil;local ec=nil;local fc=W.Color['reset']if Ub.Color.All then local gc=W.Color[Ub.Color.All]ac[#ac+1]=gc;ec=gc end;if not Rb then return''end;for y=Rb,Sb,4 do for x=Wb,Xb,2 do local gc=Yb[x]local hc=Yb[x+1]local ic=(gc and( (gc[y]or 0)*128 + (gc[y+1]or 0)*64 + (gc[y+2]or 0)*32 + (gc[y+3]or 0)*16)or 0)+ (hc and( (hc[y]or 0)*8 + (hc[y+1]or 0)*4 + (hc[y+2]or 0)*2 + (hc[y+3]or 0))or 0)if ic~=bc then ic=W.Data.Dot[ic]if not ec then local jc=Zb[x]local kc=Zb[x+1]local lc=( (jc)and(jc[y]or jc[y+1]or jc[y+2]or jc[y+3]))or( (kc)and(kc[y]or kc[y+1]or kc[y+2]or kc[y+3]))if lc then lc=W.Color[lc]else lc=fc end;if dc==lc then else ac[#ac+1]=lc;dc=lc end end;ac[#ac+1]=ic else ac[#ac+1]=cc end end;ac[#ac+1]='\n'end;ac[#ac+1]=fc;return table.concat(ac)end;W.ToDotsParallel=function(Ub,Vb,Wb)Wb=Wb or 0;local Xb,Yb=Pb+Wb,Qb+Wb;local Zb,ac=Ub.Data,Ub.Color;local bc,cc=Vb.Data,Vb.Color;local dc={}local ec=0;local fc=W.Data.Dot[ec]local gc=nil;local hc=nil;local ic=W.Color['reset']if Ub.Color.All then local jc=W.Color[Ub.Color.All]dc[#dc+1]=jc;hc=jc end;if not Rb then return''end;for y=Rb,Sb,4 do for x=Xb,Yb,2 do local jc=Zb[x]local kc=Zb[x+1]local lc=bc[x]local mc=bc[x+1]local nc=( (jc and lc)and( (jc[y]or lc[y]or 0)*128 + (jc[y+1]or lc[y+1]or 0)*64 + (jc[y+2]or lc[y+2]or 0)*32 + (jc[y+3]or lc[y+3]or 0)*16)or(jc)and( (jc[y]or 0)*128 + (jc[y+1]or 0)*64 + (jc[y+2]or 0)*32 + (jc[y+3]or 0)*16)or(lc)and( (lc[y]or 0)*128 + (lc[y+1]or 0)*64 + (lc[y+2]or 0)*32 + (lc[y+3]or 0)*16)or 0)+ ( (kc and mc)and( (kc[y]or mc[y]or 0)*8 + (kc[y+1]or mc[y+1]or 0)*4 + (kc[y+2]or mc[y+2]or 0)*2 + (kc[y+3]or mc[y+3]or 0))or(kc)and( (kc[y]or 0)*8 + (kc[y+1]or 0)*4 + (kc[y+2]or 0)*2 + (kc[y+3]or 0))or(mc)and( (mc[y]or 0)*8 + (mc[y+1]or 0)*4 + (mc[y+2]or 0)*2 + (mc[y+3]or 0))or 0)if nc~=ec then nc=W.Data.Dot[nc]if not hc then local oc=cc[x]local pc=cc[x+1]local qc=ac[x]local rc=ac[x+1]local sc=qc and(qc[y]or qc[y+1]or qc[y+2]or qc[y+3])or rc and(rc[y]or rc[y+1]or rc[y+2]or rc[y+3])or oc and(oc[y]or oc[y+1]or oc[y+2]or oc[y+3])or pc and(pc[y]or pc[y+1]or pc[y+2]or pc[y+3])if sc then sc=W.Color[sc]else sc=ic end;if gc==sc then else dc[#dc+1]=sc;gc=sc end end;dc[#dc+1]=nc else dc[#dc+1]=fc end end;dc[#dc+1]='\n'end;dc[#dc+1]=ic;return table.concat(dc)end;W.CircleGen=function(Ub,Vb,Wb,Xb,Yb)Yb=Yb or{}local Zb=Yb.color;local ac=Xb*Xb;local bc=Xb;for y=0,Xb do bc=bc+1;repeat bc=bc-1 until bc*bc+y*y<=ac;for x2=0,bc do Ub.Data[Vb+x2]=Ub.Data[Vb+x2]or{}Ub.Data[Vb-x2]=Ub.Data[Vb-x2]or{}Ub.Data[Vb+x2][Wb+y]='1'Ub.Data[Vb-x2][Wb+y]='1'Ub.Data[Vb+x2][Wb-y]='1'Ub.Data[Vb-x2][Wb-y]='1'Ub.Color[Vb+x2]=Ub.Color[Vb+x2]or{}Ub.Color[Vb-x2]=Ub.Color[Vb-x2]or{}Ub.Color[Vb+x2][Wb+y]=Zb;Ub.Color[Vb-x2][Wb+y]=Zb;Ub.Color[Vb+x2][Wb-y]=Zb;Ub.Color[Vb-x2][Wb-y]=Zb end end;return Ub end;local Tb={}W.Circle=function(Ub,Vb,Wb,Xb,Yb)local Zb=nil;if Tb[Xb]then else Tb[Xb]=W.CircleGen(W.New(),0,0,Xb)end;local ac=Yb and Yb.color;Zb=Tb[Xb]for bc,cc in pairs(Zb.Data)do for dc,ec in pairs(cc)do local fc,gc=bc+Vb,dc+Wb;Ub.Data[fc]=Ub.Data[fc]or{}Ub.Data[fc][gc]=ec;Ub.Color[fc]=Ub.Color[fc]or{}Ub.Color[fc][gc]=ac end end;return Ub end;W.New=function()return{Data={},Color={}}end;g=W end;local function X(Ob,Pb)local Qb=math.floor(Pb.p)local Rb,Sb=G-H,G+H;for y=Rb,Sb do local Tb=Ob.Data[Qb]and Ob.Data[Qb][y]if Tb=='0'or Tb==nil then Ob.Data[Qb]=Ob.Data[Qb]or{}Ob.Data[Qb][y]='1'end end end;local function Y(Ob,Pb,Qb)Qb=Qb or Pb.p;W.Circle(Ob,math.floor(Qb),G,F*Pb.radius,M[Pb.type])end;local function Z(Ob,Pb,Qb,Rb,Sb,Tb)local Ub=Tb or{}color=Ub.color;for y=Rb,Sb do for x=Pb,Qb do Ob.Data[x]=Ob.Data[x]or{}Ob.Data[x][y]='1'if color then Ob.Color[x]=Ob.Color[x]or{}Ob.Color[x][y]=color end end end end;local function ab(Ob,Pb,Qb)local Rb=Pb.type;if Rb==1 or Rb==2 or Rb==3 or Rb==4 then Y(Ob,Pb)elseif Rb==5 or Rb==6 then Y(Ob,Pb)local Sb=Pb.endnote;local Tb=(Sb.ms-Pb.ms)*Pb.speed;Y(Ob,Pb)local Ub=F*Pb.radius;local Vb,Wb=math.floor(Pb.p),math.floor(Pb.p+Tb)local Xb=math.floor(G-Ub)local Yb=math.floor(G+Ub)if Qb then else local Zb=(I-D)if Vb<Zb then Vb=Zb end;local ac=(J+D)if Wb>ac then Wb=ac end end;Z(Ob,Vb,Wb,Xb,Yb,M[Pb.type])elseif Rb==8 then Y(Ob,Pb.startnote,Pb.p)end end;local function bb(Ob,Pb,Qb,Rb)local Sb=P/ (O/2)local Tb=-Sb*math.abs(( (Qb-Pb.startms)/ (N/O))- (P/Sb))+P;local Ub=U[Pb.status]local Vb=Ub.Offset;local Wb=Ub.Color.All;local Xb,Yb=0,-math.floor(F*1.6)-8 -math.floor(Tb)local Zb,ac=Vb[1]+Xb+Rb,Vb[2]+Yb;for x=1,U.Size[1]do for y=1,U.Size[2]do local bc,cc=x+Zb,y+ac;Ob.Data[bc]=Ob.Data[bc]or{}Ob.Data[bc][cc]=Ub.Data[x]and Ub.Data[x][y]Ob.Color[bc]=Ob.Color[bc]or{}Ob.Color[bc][cc]=Wb end end end;local function cb(Ob,Pb)local Qb=V[Pb.status]local Rb=Qb.Offset;local Sb=Qb.Color.All;local Tb,Ub=0,0;for Vb,Wb in pairs(Qb.Data)do for Xb,Yb in pairs(Wb)do if Yb=='1'then local Zb,ac=Vb+Rb[1]+Tb,Xb+Rb[2]+Ub;Ob.Data[Zb]=Ob.Data[Zb]or{}Ob.Data[Zb][ac]=Yb;Ob.Color[Zb]=Ob.Color[Zb]or{}Ob.Color[Zb][ac]=Sb end end end end;local db={ClearScreen=function()io.write("\27[2J")end,SetCursor=function(Ob,Pb)io.write(string.format("\27[%d;%dH",Pb,Ob))end}local eb=Taiko.GetAllNotes(l.Data)local fb=l.Metadata.OFFSET;local gb=1000 /60;local hb=l.Metadata.TIMING(gb)local function ib(Ob)return(Ob.data=='note')or(Ob.data=='event'and Ob.event=='barline')end;local function jb(Ob,Pb)return Pb- (( (J+D)/math.abs(Ob.speed)))end;local function kb(Ob,Pb)return(Ob.ms-Pb)*Ob.speed+K end;local function lb(Ob,Pb)return Ob.loadp- (Ob.speed* (Pb-Ob.loadms))end;local mb={}for Ob,Pb in pairs(eb)do Pb.ms=Pb.oms or Pb.ms;Pb.oms=Pb.ms;Pb.ms=(Pb.ms-fb)/w;Pb.s=MsToS(Pb.ms)Pb.speed=(Taiko.CalculateSpeed(Pb,F))*v;Pb.loadms=jb(Pb,Pb.ms)Pb.loads=MsToS(Pb.loadms)Pb.loadp=kb(Pb,Pb.loadms)Pb.hit=nil;mb[#mb+1]=Pb.ms end;for Ob,Pb in pairs(l.Data)do if Pb.branch then for Qb,Rb in pairs(Pb.branch.paths)do table.sort(Rb,function(Sb,Tb)return Sb.loadms<Tb.loadms end)end end end;table.sort(l.Data,function(Ob,Pb)if Ob.branch and Pb.branch then for Qb,Rb in pairs(Ob.branch.paths)do for Sb,Tb in pairs(Pb.branch.paths)do return Rb[1].loadms<Tb[1].loadms end end elseif Ob.branch then for Qb,Rb in pairs(Ob.branch.paths)do return Rb[1].loadms<Pb.loadms end elseif Pb.branch then for Qb,Rb in pairs(Pb.branch.paths)do return Ob.loadms<Rb[1].loadms end else return Ob.loadms<Pb.loadms end end)Taiko.ConnectAll(l.Data)Taiko.ForAll(l.Data,function(Ob,Pb,Qb)Ob.n=Qb end)local nb=math.max(unpack(mb))+ (E/w)local ob={s=1,e=0,n=0}local pb=l.Data[1]local qb=pb.loads;ob.e=ob.n;local rb=10;local sb=string.rep(' ',rb)local tb={}local function ub(Ob,Pb)tb[#tb+1]=Ob;tb[#tb+1]=': 'tb[#tb+1]=tostring(Pb)tb[#tb+1]=sb;tb[#tb+1]='\n'end;local function vb()print(table.concat(tb))tb={}end;local wb=''local function xb(Ob)wb=wb..'\n'..Ob end;local function yb()print(wb)end;db.ClearScreen()local zb='M'local Ab={startms=nil,status=nil}local Bb={-1,nil}local Cb=0;local Db=0;local Eb=true;local Fb=true;local Gb=false;local Hb=nil;local Ib=nil;local Jb=nil;local Kb=nil;local Lb=nil;local Mb=nil;if q then local Ob=1 /q;local Pb=nil end;local Nb=os.clock()if q then nextframes=Nb+frames end;if not p.on then while true do local Ob=W.New()local Pb=os.clock()local Qb=Pb-Nb;local Rb=Qb*1000;if pb then if pb.loadms<Rb then ob.n=ob.n+1;ob.e=pb.n;ob[pb.n]=pb;if Gb and pb.speed~=Hb then Gb=false end;if Gb then pb.p=lb(pb,Lb)if pb.data=='event'then if pb.event=='barline'then X(Jb,pb,Gb)end elseif pb.data=='note'then ab(Jb,pb,Gb)else error('Invalid note.data')end end;pb=pb.nextnote;if pb and pb.branch then pb=pb.branch.paths[zb][1]end end else if Rb>nb then break end end;if Fb and Gb==false then local Zb=nil;for i=ob.s,ob.e do if Zb then if ob[i]and Zb~=ob[i].speed then Zb=false;break end else Zb=ob[i].speed end end;if Zb then Lb=Rb;Hb=Zb;Jb=false;Kb=ob[ob.s]or ob[ob.s+1]Gb=true else Gb=false end end;local Sb=0;if Gb and Jb then Eb=false;local Zb=ob[ob.s]or ob[ob.s+1]local ac=Ib or Zb.p;Ib=ac;local bc=lb(Kb,Rb)ac=ac or bc;local cc=math.floor(ac-bc+0.5)if cc>=1 then Sb=cc else end;Ob=Jb else Ib=nil;Eb=true end;if Eb and Jb~=false then W.Circle(Ob,math.floor(K),G,F,{color='purple'})end;if Gb then Mb=W.New()W.Circle(Mb,math.floor(K)+Sb,G,F,{color='purple'})end;local Tb={}local Ub={}for i=ob.s,ob.e do local Zb=ob[i]if Zb then if Zb.data=='note'then if(Zb.type==1 or Zb.type==3)and(not Tb[1]or math.abs(Rb-Zb.ms)<Tb[1])then Tb[1]=math.abs(Rb-Zb.ms)Ub[1]=Zb elseif(Zb.type==2 or Zb.type==4)and(not Tb[2]or math.abs(Rb-Zb.ms)<Tb[2])then Tb[2]=math.abs(Rb-Zb.ms)Ub[2]=Zb end end;Zb.p=lb(Zb,Rb)if math.abs(Zb.p-K)> (J+D+1)then if Zb.endnote and Zb.endnote.done~=true then else Zb.done=true;ob[i]=nil;if pb and ob.n==0 then ob.s=pb.n elseif Zb.n==ob.s then if Zb.n==ob.e then ob.n=0 else local ac=ob.s;repeat ac=ac+1;ob.n=ob.n-1 until ob[ac]ob.s=ac end end end else if Eb then if Zb.data=='event'then if Zb.event=='barline'then X(Ob,Zb)end elseif Zb.data=='note'then ab(Ob,Zb)else error('Invalid note.data')end end end end end;if Jb==false then Jb=Ob end;if Ab.status then if Rb>Ab.startms+N then Ab={}else if Gb then bb(Mb,Ab,Rb,Sb)else bb(Ob,Ab,Rb,Sb)end end end;db.SetCursor(1,1)if Gb then if Mb then print(W.ToDotsParallel(Ob,Mb,Sb))else print(W.Convert.ToDots(Ob,Sb))end else if q then local Zb=W.Convert.ToDots(Ob,Sb)repeat until os.clock()>=nextframes;nextframes=nextframes+frames;print(Zb)else print(W.Convert.ToDots(Ob,Sb))end end;Cb=Cb+1;local Vb=os.clock()-Pb;Db=Db+Vb;local Wb=S.getch(T)local Xb=S.getkeyname(Wb)local Yb=x.Hit[Xb]if s then local Zb=Tb[1]local ac=Tb[2]local bc=(Tb[1]and Tb[2])and( (Tb[1]<Tb[2])and 1 or 2)or(Tb[1]and 1 or 2)local cc=Tb[bc]local dc=Ub[bc]if cc and Rb>dc.ms and(not dc.hit)then if u then Yb=bc else dc.hit=true;local ec=dc.type;local fc=( (ec==3 or ec==4)and 3)or 2;Ab={startms=Rb,status=fc}end end end;if Yb and Tb[Yb]and(not Ub[Yb].hit)then local Zb=Tb[Yb]local ac;local bc=Ub[Yb].type;local cc=( (bc==3 or bc==4)and Taiko.Data.BigLeniency)or 1;if Zb< (hb.good)then local dc=Ub[Yb].type;ac=( (dc==3 or dc==4)and 3)or 2 elseif Zb< (hb.ok*cc)then ac=1 elseif Zb< (hb.bad*cc)then ac=0 else ac=nil end;if ac then Ub[Yb].hit=true;Ab={startms=Rb,status=ac}end end;if x.Escape[Xb]then local Zb=os.clock()db.ClearScreen()S.nodelay(T,false)local ac={'Back','Retry','Back to Select'}while true do db.SetCursor(1,1)local bc={}for i=1,#ac do bc[i]=( (i==z)and(B..string.rep(' ',A-#B))or string.rep(' ',A))..ac[i]end;print(table.concat(bc,C))local cc=S.getch(T)local dc=S.getkeyname(cc)if x.L[dc]then z=z==1 and 1 or z-1 elseif x.R[dc]then z=z==3 and 3 or z+1 elseif x.Select[dc]then if z==1 then elseif z==2 then return'Retry'elseif z==3 then return nil end;break elseif x.Escape[dc]then break end end;S.nodelay(T,true)Nb=Nb+ (os.clock()-Zb)end;if Wb~=-1 then Bb={Wb,Xb}end;ub('Input (ascii)',Bb[1])ub('Input (key)',Bb[2])ub('S',Qb)ub('Ms',Rb)ub('Loaded',ob.n)ub('Frames Rendered',Cb)ub('Last Frame Render (s)',Vb)ub('Last Frame Render (ms)',Vb*1000)ub('Frame Render Total (s)',Db)ub('Frame Render Total (ms)',Db*1000)ub('Frame Render Total (%)',Db/Qb*100)ub('FPS (Frame)',Cb/Qb)ub('Memory Usage (mb)',collectgarbage('count')/1000)ub('Finished (%)',Rb/ (nb)*100)ub('Nearest1 (ms)',Tb[1])ub('Nearest2 (ms)',Tb[2])ub('Song Name',l.Metadata.TITLE)ub('Difficulty (id)',l.Metadata.COURSE)ub('Stars',l.Metadata.LEVEL)vb()yb()end else error('Prerendering has been removed')end;return true end;function Taiko.SongSelect(l,m)local n={}local o,p=10,10;local q,r,s,u=-o,o,-p,p;local v=true;local w=1;local x=1;local y=4;local z=5;local A=5;local B=2;local C='V'local D='>'local E=10;local F=nil;local G='>'local H='>'local I=2;local J=true;local K={[2]={'Normal','Auto'},[3]={'Normal','2x Speed','3x Speed','4x Speed','0.25x Speed','0.5x Speed','0.75x Speed'},[4]={'Normal','2x Speed','3x Speed','4x Speed','0.25x Speed','0.5x Speed','0.75x Speed'},[5]={'TODO Normal'}}local L={4,1,1,1,1,1}local M={nil}for hb,ib in pairs(K)do M[hb]={1,#ib,ib}end;local N=require('./CompactTJA/compactv4')local O=require('taikocurses')local P={window=O.initscr()}O.keypad(P,true)O.echo(false)O.raw(true)O.nl(false)O.cbreak(true)O.nodelay(P,true)O.getch(P)O.nodelay(P,false)local Q,R=O.cols(),O.lines()F=F or Q-2;local S={Escape={['\27']=true,ALT_ESC=true},Scroll={L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_A2=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true}},Select={Init={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Escape={['\27']=true,ALT_ESC=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true},U={KEY_UP=true,KEY_A2=true},D={KEY_DOWN=true,KEY_C2=true},Play={Hit={['4']=2,['v']=1,['n']=1,['8']=2},Escape={['\27']=true,ALT_ESC=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_DOWN=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}}},Search={Init={ALT_F=true,f=true,F=true},Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},FirstResult={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Select={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true},Up={KEY_A2=true,KEY_UP=true},Down={KEY_C2=true,KEY_DOWN=true},Escape={['\27']=true,ALT_ESC=true}},Add={Init={ALT_N=true,n=true,N=true},Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}},StandardInput={Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},Escape={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_DOWN=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true}}}local T={ClearScreen=function()io.write("\27[2J")end,SetCursor=function(hb,ib)io.write(string.format("\27[%d;%dH",ib,hb))end,ClearLine=function()io.write("\27[2K")end,CursorLeft=function(hb)io.write(string.format("\27[%dD",hb))end,CursorRight=function(hb)io.write(string.format("\27[%dC",hb))end,SaveCursor=function()io.write("\27[s")end,RestoreCursor=function()io.write("\27[u")end}local function U(hb)return hb..string.rep(' ',F-#hb)end;local function V()local hb=O.getch(P)local ib=O.getkeyname(hb)return hb,ib end;local function W()local hb=''local ib=0;local jb=ib;while true do local kb,lb=V()if S.StandardInput.Backspace[lb]then hb=string.sub(hb,1,ib-1)..string.sub(hb,ib+1,-1)ib=ib-1 elseif S.StandardInput.Escape[lb]then io.write('\n')return hb elseif S.StandardInput.L[lb]then ib=ib-1 elseif S.StandardInput.R[lb]then ib=ib+1 else hb=string.sub(hb,1,ib)..lb..string.sub(hb,ib+1,-1)ib=ib+1 end;ib=ClipN(ib,0,#hb)local mb=ib-jb;if mb<0 then T.CursorLeft(-mb)elseif mb>0 then T.CursorRight(mb)end;T.SaveCursor()T.ClearLine()io.write('\r')io.write(hb)T.RestoreCursor()jb=ib end end;local function X(hb)return hb>=32 and hb<=126 end;local function Y(hb,ib,jb,kb)return(hb and(ib..string.sub(jb,#ib+1,-1))or jb)..kb end;local function Z(hb,ib,jb)return hb>jb and ib or hb<ib and jb or hb end;local ab={[0]='No',[1]='Yes'}local function bb(hb)return hb and ab[1]or ab[0]end;local function cb(hb)return hb*100 ..'%'end;local function db(hb)return MsToS(hb)..'s'end;local function eb(hb)return db(SToMs(hb))end;local function fb(hb)return tonumber(hb)and tonumber(hb)or 0 end;local gb={}T.ClearScreen()while true do n={}if v then n[q]={}for i=w-z,w+z do local lb=nil;if i<1 then lb=#l+i elseif i>#l then lb=i-#l else lb=i end;local mb=l[lb]if mb then n[0]=n[0]or{}n[0][(i-w)*A]=mb end end;local jb={}local kb=string.rep(' ',B)for y=s,u do jb[#jb+1]=Y(y==0,D,kb,'')jb[#jb+1]=U(n[0][y]or'')jb[#jb+1]='\n'end;T.SetCursor(1,1)print(table.concat(jb))else n[0]={}n[0][s]=C;for i=w-z,w+z do local kb=nil;if i<1 then kb=#l+i elseif i>#l then kb=i-#l else kb=i end;local lb=l[kb]if lb then local mb=(i-w)*A;n[mb]=n[mb]or{}local nb=s+B;for i2=1,#lb do n[mb][nb]=string.sub(lb,i2,i2)nb=nb+1 end end end;local jb={}for y=s,u do for x=q,r do if n[x]and n[x][y]then local kb=n[x][y]if X(string.byte(kb))then jb[#jb+1]=kb else jb[#jb+1]=' 'end else jb[#jb+1]=' 'end end;jb[#jb+1]='\n'end;T.SetCursor(1,1)print(table.concat(jb))end;local hb,ib=V()if S.Scroll.L[ib]then w=w-1 elseif S.Scroll.R[ib]then w=w+1 elseif S.Select.Init[ib]then local jb;if J then if gb[w]then jb=gb[w]else jb=Taiko.ParseTJA(m[w])gb[w]=jb end else jb=Taiko.ParseTJA(m[w])end;local kb={}for ob,pb in pairs(jb)do kb[#kb+1]={ob,pb.Metadata.COURSE}end;table.sort(kb,function(ob,pb)return ob[2]<pb[2]end)min=1;max=#kb;M[x]={min,max,kb}DifficultyMap=kb;local lb=string.rep(' ',I)T.ClearScreen()T.SetCursor(1,1)local mb=nil;local nb=x;while true do x=ClipN(x,1,5)if x~=nb then y=L[x]nb=x end;local ob=M[x]min,max=ob[1],ob[2]y=Z(y,min,max)L[x]=y;T.SetCursor(1,1)local pb=DifficultyMap[L[1]][2]mb=Taiko.GetDifficulty(jb,pb)local qb=mb.Metadata;local rb=Taiko.Analyze(mb)local sb={{'',qb.TITLE},{'\t',qb.SUBTITLE},{'',''},{'','Select Options:'},{Y(x==1,H,lb,'Difficulty: '),Taiko.Data.CourseName[qb.COURSE]},{Y(x==2,H,lb,'Mode: '),K[2][L[2]]},{Y(x==3,H,lb,'Note Speed: '),K[3][L[3]]},{Y(x==4,H,lb,'Song Speed: '),K[4][L[4]]},{Y(x==5,H,lb,'Modifiers: '),K[5][L[5]]},{'',''},{'Difficulty: ',Taiko.Data.CourseName[qb.COURSE]},{'Stars: ',qb.LEVEL},{'Diverge Notes: ',bb(qb.DIVERGENOTES)},{'',''},{'','Statistics:'},{'Don (DON) / Ka (KA): ',fb(rb.notes[1])..' + ('..fb(rb.notes[3])..') / '..fb(rb.notes[2])..' + ('..fb(rb.notes[4])..') = '..cb((fb(rb.notes[1])+fb(rb.notes[3]))/rb.notes.validn)..' / '..cb((fb(rb.notes[2])+fb(rb.notes[4]))/rb.notes.validn)},{'Max Score (without drumroll): ',rb.maxscore},{'Max Combo: ',rb.maxcombo},{'Drumroll Time (total): ',db(rb.drumrollms+rb.drumrollbigms)},{'Balloon Time: ',db(rb.balloonms)},{'Balloon Hits: ',rb.balloonhit},{'Special Time: ',db(rb.specialms)},{'Special Hits: ',rb.specialhit},{'',''},{'','Press Enter to Play!'}}for i=1,#sb do local vb=sb[i]print(U(vb[1]..tostring(vb[2])))end;local tb,ub=V()if S.Select.L[ub]then y=y-1 elseif S.Select.R[ub]then y=y+1 elseif S.Select.U[ub]then x=x-1 elseif S.Select.D[ub]then x=x+1 elseif S.Select.Select[ub]then while true do local vb,wb=Taiko.PlaySong(Taiko.GetDifficulty(jb,pb),P,L,S.Select.Play)if vb and wb then break elseif vb=='Retry'then else break end end;O.nodelay(P,false)elseif S.Select.Escape[ub]then break end end elseif S.Search.Init[ib]then local jb=''local kb={}local lb=1;local mb=nil;local nb=1;T.ClearScreen()T.SetCursor(1,1)print('Searching...')while true do T.SetCursor(#jb+1,2)local ob,pb=V()T.SetCursor(1,2)if S.Search.Backspace[pb]then jb=string.sub(jb,1,-2)elseif S.Search.FirstResult[pb]then mb=kb[1]break elseif S.Search.Select[pb]then mb=kb[nb]break elseif S.Search.Down[pb]then nb=nb+1 elseif S.Search.Up[pb]then nb=nb-1 elseif S.Search.Escape[pb]then break else jb=jb..pb end;print(U(jb))local qb=N.SearchHeaderAll(l,jb)for i=1,E do if qb[i][2]==-math.huge then lb=i-1;break elseif i==E then lb=i end end;nb=ClipN(nb,1,lb)local rb=false;for i=1,E do local sb=qb[i]if rb then print(U(''))else if sb then if sb[2]==-math.huge then rb=true;print(U(''))else print(U((i==nb and G or i)..'. '..qb[i][3]))kb[i]=sb end end end end end;w=(mb and mb[1]or w)or w elseif S.Add.Init[ib]then print('Import a Custom Song')while true do print('Enter a .tja or .tjac file path (with the file extention)')local jb=W()local kb=io.open(jb,'rb')if kb then local lb=kb:read('*all')if EndsWith(jb,'.tja')then print('Enter a song name')local mb=W()l[#l+1]=mb;m[#m+1]=lb;break elseif EndsWith(jb,'.tjac')then local mb,nb=N.Decompress(lb)for i=1,#mb do m[#m+1]=mb[i]l[#l+1]=nb[i]end;break else print('Invalid file type')end;io.close(kb)else print('Unable to read file')end end elseif S.Escape[ib]then return end;w=Z(w,1,#l)end end;local h='./CompactTJA/taikobuipm.tjac'h='./CompactTJA/ESE/06 Classical.tjac'h='./CompactTJA/ESE/ESE.tjac'local i=require('./CompactTJA/compactv4')local j,k=i.Decompress(i.Read(h))Taiko.SongSelect(k,j)error()Taiko.PlaySong(Taiko.GetDifficulty(Taiko.ParseTJA(i.InputFile(h)),'Ura'))
local h=nil;local i=require('taikocurses')local j=require('./CompactTJA/compactv4')Split=function(n,o)local p={}for q,r in n:gmatch("([^"..o.."]*)("..o.."?)")do table.insert(p,q)if r==''then return p end end end;Trim=function(n)local o=n:gsub("^%s*(.-)%s*$","%1")return o end;TrimLeft=function(n)local o=n:gsub("^%s*(.-)$","%1")return o end;TrimRight=function(n)local o=n:gsub("^(.-)%s*$","%1")return o end;StartsWith=function(n,o)return n:sub(1,#o)==o end;EndsWith=function(n,o)return n:sub(-#o,-1)==o end;Table={}function Table.Clone(n,o)o=o or{}local p=type(n)local q;if p=='table'then if o[n]then q=o[n]else q={}o[n]=q;for r,s in next,n,nil do q[Table.Clone(r,o)]=Table.Clone(s,o)end;setmetatable(q,Table.Clone(getmetatable(n),o))end else q=n end;return q end;ClipN=function(o,p,q)if o<p then return p elseif o>q then return q else return o end end;function Error(n)error(n)end;LineN=nil;function ParseError(n,o,p)Error('Line: '..LineN..'\n'..n..': '..o.. (p and(', '..p)or''))end;function MsToS(n)return n/1000 end;function SToMs(n)return n*1000 end;Taiko={}Taiko.Data={Languages={'','EN','JA','CN','TW','KO'},GenreName={Pop={'pop','j-pop'},Anime={'anime','アニメ'},Kids={'kids','どうよう'},Variety={'variety','バラエティ'},VOCALOID={'vocaloid','ボーカロイド'},Classic={'classic','クラシック'},['Game Music']={'game music','ゲームミュージック'},['Namco Original']={'namco original','ナムコオリジナル'}},CourseId={easy=0,normal=1,hard=2,oni=3,edit=4,tower=5,dan=6,ura=4},CourseName={[0]='Easy','Normal','Hard','Oni','Edit','Tower','Dan','Ura'},RatingMultiplier={[0]=0,[1]=0.5,[2]=1,[3]=2},GogoMultiplier=1.2,ScoreMode={Note={[0]=function(n,o,p,q,r,s)return n+ ( ( (o<200)and(p or 1000)or( (p or 1000)+ (q or 1000)))*Taiko.Data.RatingMultiplier[r]* (s and Taiko.Data.GogoMultiplier or 1))end,[1]=function(n,o,p,q,r,s)return n+ ( (p+math.max(0,q*math.floor((math.min(o,100)-1)/10)))*Taiko.Data.RatingMultiplier[r]* (s and Taiko.Data.GogoMultiplier or 1))end,[2]=function(n,o,p,q,r,s)return math.floor(n+ ( (p+q* ( (o>=100)and 8 or(o>=50)and 4 or(o>=30)and 2 or(o>=10)and 1 or 0))*Taiko.Data.RatingMultiplier[r]* (s and Taiko.Data.GogoMultiplier or 1))/10)*10 end},Drumroll={[0]=function(n,o,p)return n+ ( (o==5 and 300 or o==6 and 600)* (p and Taiko.Data.GogoMultiplier or 1))end,[1]=function(n,o,p)return n+ ( (o==5 and 300 or o==6 and 600)* (p and Taiko.Data.GogoMultiplier or 1))end,[2]=function(n,o,p)return n+ ( (o==5 and 100 or o==6 and 200)* (p and Taiko.Data.GogoMultiplier or 1))end},Balloon={[0]=function(n,o,p)return n+ ( (o==7 and 300)* (p and Taiko.Data.GogoMultiplier or 1))end,[1]=function(n,o,p)return n+ ( (o==7 and 300)* (p and Taiko.Data.GogoMultiplier or 1))end,[2]=function(n,o,p)return n+ ( (o==7 and 300)* (p and Taiko.Data.GogoMultiplier or 1))end},BalloonPop={[0]=function(n,o,p)return n+ ( (o==7 and 5000)* (p and Taiko.Data.GogoMultiplier or 1))end,[1]=function(n,o,p)return n+ ( (o==7 and 5000)* (p and Taiko.Data.GogoMultiplier or 1))end,[2]=function(n,o,p)return n+ ( (o==7 and 5000)* (p and Taiko.Data.GogoMultiplier or 1))end}},Autoscore={[0]=function(n)end,[1]=function(n)end,[2]=function(n)end},SideId={normal=1,ex=2,both=3},SideName={'normal','ex','both'},StyleId={single=1,double=2,couple=2},StyleName={'single','double'},Exam={Condition={g=true,jp=true,jg=true,jb=true,s=true,r=true,h=true,c=true},Scope={m=true,l=true}},Branch={PathId={N=0,E=1,M=2},PathName={[0]='N',[1]='E',[2]='M'},Requirements={r=function()end,p=function()end}},Timing={GetFunction=function(n)return function(o)if n==1 then return{good=5 /2 *o,ok=13 /2 *o,bad=15 /2 *o}else return{good=3 /2 *o,ok=9 /2 *o,bad=13 /2 *o}end end end},StatusId={bad=0,ok=1,good=2,biggood=3},StatusName={[0]='BAD',[1]='OK',[2]='GOOD',[3]='GOOD'},ModeId={['']=0,P1=1,P2=2},ModeName={[0]='',P1,P2},Combo={[1]=true,[2]=true,[3]=true,[4]=true},BigLeniency=2,Strings={Notes={}}}function Taiko.ParseTJA(n)local o=os.clock()local p=flashpixel;local q={}local r={Metadata={SUBTITLE='',BPM=120,WAVE='main.mp3',OFFSET=0,DEMOSTART=0,SCOREMODE=1,SONGVOL=100,SEVOL=100,SIDE=3,LIFE=0,GAME='Taiko',HEADSCROLL=1,MOVIEOFFSET=0,COURSE='ONI',LEVEL=0,BALLOON=nil,SCOREINIT,SCOREDIFF,BALLOONNOR=nil,BALLOONEXP=nil,BALLOONMAS=nil,STYLE=1,EXAM1=nil,EXAM2=nil,EXAM3=nil,GAUGEINCR='NORMAL',TOTAL=nil,HIDDENBRANCH=0,DIVERGENOTES=false,SCOREINIT=0,SCOREDIFF=0},Data={}}local function s(J)local K=Taiko.Data.Languages;for i=1,#K do local L=r.Metadata[J..K[i]]if L then return L end end;return nil end;local function u(J,K,L)local M=tonumber(K)if M then return M else ParseError(J,L,K)end end;local function v(J,K,L,M)if K then return K else ParseError(J,L,M)end end;local function w(J,K,L)local M={['true']=true,['false']=false,yes=true,no=false,['1']=true,['0']=false,[1]=true,[0]=false}local N=M[K]~=nil;if N then return N else ParseError(J,L,K)end end;local function x(J,K)local L=','local M='\\'local N={}local O=''local P=false;for i=1,#K do local Q=string.sub(K,i,i)if P then O=O..Q;P=false else if Q==L then table.insert(N,O)O=''elseif Q==M then P=true else O=O..Q end end end;table.insert(N,O)return N end;local function y(J,K,L)local M=x(J,K)for i=1,#M do M[i]=u(J,M[i],L,K)end;return M end;local function z(J,K,L)if K and K~=''then return y(J,K,L)else return{}end end;local function A(J,K,L)if K and K~=''then local M=x(J,K,L)v(J,Taiko.Data.Exam.Condition[M[1]],L)M[2]=u(J,M[2],L)M[3]=u(J,M[3],L)v(J,Taiko.Data.Exam.Scope[M[4]],L)return M else return{}end end;local B=error;local function C(J)local K=nil;local L=false;local M=''for i=1,#J do local N=string.sub(J,i,i)if N=='+'or N=='-'then if K then B('There are multiple signs')else K=N end elseif N=='.'then if L then B('There are multiple decimal points')else M=M..N;L=true end elseif tonumber(N)then M=M..N end end;if M==''then B('No number was found')end;return tonumber((K or'+')..M)end;local function D(J)local K=tonumber(J)if K then return K end;local L=string.gsub(J,'[^%d%.%-%+]','')if L==''then return 0 end;return tonumber(L)or C(J)or C(L)end;local function E(J)return string.find(J,'i')end;local function F(J)local K={0,0}local L=false;local M=''for i=1,#J do local N=string.sub(J,i,i)if N=='+'or N=='-'then K[1]=K[1]+D(M)M=N elseif N=='i'then K[2]=K[2]+D(M)M=''else M=M..N end end;if M~=''then K[1]=K[1]+D(M)end;return K end;local G={}local function H()local J={settings={noteparse={notealias={A=3,B=4},noteexceptions={[',']=true,[' ']=true,['\t']=true}},command={matchexceptions={}}},bpm=0,ms=0,songstarted=false,timingpoint=nil,sign=4 /4,mpm=0,mspermeasure=0,scroll=1,measuredone=true,currentmeasure={},measurepushto=r.Data,barline=true,insertbarline=true,gogo=false,lastlong=nil,balloonn=1,currentbranch=nil,branch={on=false,requirements={},paths={}},msbeforebranch=nil,section=false,disablescroll=false,stopsong=false,delay=0,notechain={}}function J.createnote(K)if K then local L={ms=nil,data=nil,type=K,txt=nil,gogo=J.gogo,scroll=(J.scroll*r.Metadata.HEADSCROLL),mspermeasure=J.mspermeasure,bpm=J.bpm,nextnote=nil,radius=1,requiredhits=nil,length=nil,endnote=nil,section=nil,text=nil,delay=J.delay,onnotepush=nil}L.type=K;if K==3 or K==4 or K==6 then L.radius=L.radius*1.6 end;if K==5 or K==6 or K==7 or K==9 then if J.lastlong then if K==9 then else ParseError('parser.noteparse','Last long note has not ended')end else J.lastlong=L;if K==7 or K==9 then L.requiredhits=v('parser.noteparse',r.Metadata.BALLOON[J.balloonn],'Invalid number of balloons',J.balloonn)J.balloonn=J.balloonn+1 end end end;if K==8 then local M=J.lastlong;J.lastlong=nil;L.startnote=M;if M then L.onnotepush=function()M.length=L.ms-M.ms;M.endnote=L end else end end;if J.section then L.section=true;J.section=false end;return L else return{ms=nil,data=nil,type=nil,txt=nil,gogo=J.gogo,scroll=(J.scroll*r.Metadata.HEADSCROLL),mspermeasure=J.mspermeasure,bpm=J.bpm,nextnote=nil,delay=J.delay}end end;function J.endbranch()local K=J.createnote()K.data='event'K.event='branch'K.branch={requirements=J.branch.requirements,paths=J.branch.paths}J.branch.on=false;J.branch.requirements={}J.branch.paths={}table.insert(r.Data,K)J.measurepushto=r.Data end;return J end;G=H()local I=Split(n,'\n')for i=1,#I do LineN=i;local J=Trim(I[i])if StartsWith(J,'//')or J==''then else local K=string.find(J,'//')if K then J=string.sub(J,1,K-1)end;local L=false;if G.songstarted==false and L==false then local M={string.match(J,'(%u+):(.*)')}if M[1]then local N=Trim(M[2])if N~=''then r.Metadata[Trim(M[1])]=N end;L=true end end;if(G.songstarted or StartsWith(J,'#START')or StartsWith(J,'#BMSCROLL')or StartsWith(J,'#HBSCROLL'))and L==false then local M={string.match(J,'#(%u-)%s(.*)')}if not M[1]then M={string.match(J,'#(%u+)')}end;if M[1]then if M[1]=='START'then if G.songstarted then ParseError(M[1],'Song has already started')else r.OriginalMetadata=Table.Clone(r.Metadata)if M[2]then r.Metadata.MODE=v(M[1],Taiko.Data.ModeId[M[2]],'Invalid mode',M[2])else r.Metadata.MODE=0 end;r.Metadata.TITLE=v(M[1],s('TITLE'),'Title is missing')r.Metadata.SUBTITLE=v(M[1],s('SUBTITLE'),'Subtitle is missing')r.Metadata.BPM=u(M[1],r.Metadata.BPM,'Invalid bpm')r.Metadata.OFFSET=SToMs(u(M[1],r.Metadata.OFFSET,'Invalid offset'))r.Metadata.DEMOSTART=SToMs(u(M[1],r.Metadata.DEMOSTART,'Invalid demostart'))if r.Metadata.DEMOSTART==0 then r.Metadata.DEMOSTART=nil end;for Q,R in pairs(Taiko.Data.GenreName)do for i=1,#R do if R[i]==r.Metadata.GENRE then r.Metadata.GENRE=Q end end end;r.Metadata.SCOREMODE=u(M[1],r.Metadata.SCOREMODE,'Invalid scoremode')v(M[1],Taiko.Data.ScoreMode.Note[r.Metadata.SCOREMODE],'Invalid scoremode',r.Metadata.SCOREMODE)if r.Metadata.MAKER then r.Metadata.CREATORURLT={}r.Metadata.CREATOR=Trim(string.gsub(r.Metadata.MAKER,'(<.->)',function(Q)table.insert(r.Metadata.CREATORURLT,string.sub(Q,2,-2))return''end))r.Metadata.CREATORURL=table.concat(r.Metadata.CREATORURLT,', ')r.Metadata.CREATIVE=false else r.Metadata.CREATIVE=false end;r.Metadata.SONGVOL=u(M[1],r.Metadata.SONGVOL,'Invalid songvol')/100;r.Metadata.SEVOL=u(M[1],r.Metadata.SEVOL,'Invalid sevol')/100;local N=tonumber(r.Metadata.SIDE)if N then v(M[1],Taiko.Data.SideName[N],'Invalid side id',r.Metadata.SIDE)r.Metadata.SIDE=N else r.Metadata.SIDE=v(M[1],Taiko.Data.SideId[string.lower(r.Metadata.SIDE)],'Invalid side name',r.Metadata.SIDE)end;r.Metadata.LIFE=u(M[1],r.Metadata.LIFE,'Invalid life')if r.Metadata.LIFE==0 then r.Metadata.LIFE=nil end;r.Metadata.GAME=string.lower(r.Metadata.GAME)if r.Metadata.GAME=='taiko'then elseif r.Metadata.GAME=='jube'then else end;r.Metadata.HEADSCROLL=u(M[1],r.Metadata.HEADSCROLL,'Invalid headscroll')r.Metadata.MOVIEOFFSET=u(M[1],r.Metadata.MOVIEOFFSET,'Invalid movieoffset')local O=tonumber(r.Metadata.COURSE)if O then v(M[1],Taiko.Data.CourseName[O],'Invalid course id',r.Metadata.COURSE)r.Metadata.COURSE=O else r.Metadata.COURSE=v(M[1],Taiko.Data.CourseId[string.lower(r.Metadata.COURSE)],'Invalid course name',r.Metadata.COURSE)end;r.Metadata.TIMING=Taiko.Data.Timing.GetFunction(r.Metadata.COURSE)r.Metadata.LEVEL=ClipN(math.floor(u(M[1],r.Metadata.LEVEL,'Invalid level')),0,10)r.Metadata.BALLOON=z(M[1],r.Metadata.BALLOON,'Invalid balloon')r.Metadata.SCOREINIT=u(M[1],r.Metadata.SCOREINIT,'Invalid scoreinit')r.Metadata.SCOREDIFF=u(M[1],r.Metadata.SCOREDIFF,'Invalid scoreinit')r.Metadata.BALLOONNOR=z(M[1],r.Metadata.BALLOONNOR,'Invalid balloonnor')r.Metadata.BALLOONEXP=z(M[1],r.Metadata.BALLOONEXP,'Invalid balloonexp')r.Metadata.BALLOONMAS=z(M[1],r.Metadata.BALLOONMAS,'Invalid balloonmas')local P=tonumber(r.Metadata.STYLE)if P then v(M[1],Taiko.Data.StyleName[P],'Invalid style id',Taiko.Data.STYLE)r.Metadata.STYLE=P else r.Metadata.STYLE=v(M[1],Taiko.Data.StyleId[string.lower(r.Metadata.STYLE)],'Invalid style name',r.Metadata.STYLE)end;r.Metadata.EXAM1=A(r.Metadata.EXAM1)r.Metadata.EXAM2=A(r.Metadata.EXAM2)r.Metadata.EXAM3=A(r.Metadata.EXAM3)r.Metadata.GAUGEINCR=string.lower(r.Metadata.GAUGEINCR)if r.Metadata.TOTAL then r.Metadata.TOTAL=u(M[1],r.Metadata.TOTAL,'Invalid total')end;r.Metadata.HIDDENBRANCH=w(M[1],r.Metadata.HIDDENBRANCH,'Invalid hiddenbranch')G.bpm=r.Metadata.BPM;G.songstarted=true end elseif M[1]=='END'then if G.songstarted then if#G.currentmeasure~=0 then ParseError(M[1],'Current measure is not empty')end;table.insert(q,r)r={Metadata=Table.Clone(r.OriginalMetadata),Data={}}G=H()G.songstarted=false;G.measurepushto=r.Data else ParseError(M[1],'Song has already ended')end elseif M[1]=='MEASURE'then local N,O=string.match(M[2],'(%d+)/(%d+)')N=u(M[1],N,'Invalid measure')O=u(M[1],O,'Invalid measure')G.sign=(N/O)or G.sign elseif M[1]=='BPMCHANGE'then G.bpm=u(M[1],M[2],'Invalid bpmchange')or G.bpm elseif M[1]=='DELAY'then local N=SToMs((u(M[1],M[2],'Invalid delay')or 0))G.delay=G.delay+N;table.insert(G.currentmeasure,{'DELAY',N})elseif M[1]=='SCROLL'then if G.disablescroll then else G.scroll=u(M[1],M[2],'Invalid scroll')or G.scroll;if G.scroll==0 then ParseError(M[1],'Scroll cannot be 0')end end elseif M[1]=='GOGOSTART'then G.gogo=true elseif M[1]=='GOGOEND'then G.gogo=false elseif M[1]=='BARLINEOFF'then G.barline=false elseif M[1]=='BARLINEON'then G.barline=true elseif M[1]=='BRANCHSTART'then if G.branch.on then G.endbranch()end;G.msbeforebranch=G.ms;G.branch.on=true;r.Metadata.DIVERGENOTES=true;local N=x(M[1],M[2])local O=v(M[1],Taiko.Data.Branch.Requirements[string.lower(N[1])],'Invalid type',N[1])G.branch.requirements={O}local P=2;while true do if not N[P]then break end;local Q=Taiko.Data.Branch.PathName[P-1]if Q then G.branch.requirements[Q]=N[P]else break end;P=P+1 end elseif Taiko.Data.Branch.PathId[M[1]]then if G.branch.on then G.ms=G.msbeforebranch;G.currentbranch=M[1]G.branch.paths[M[1]]={}G.measurepushto=G.branch.paths[M[1]]else ParseError(M[1],'Branch has not started')end elseif M[1]=='BRANCHEND'then if G.branch.on then G.endbranch()else ParseError(M[1],'Branch has already ended')end elseif M[1]=='SECTION'then G.section=true elseif M[1]=='LYRIC'then elseif M[1]=='LEVELHOLD'then elseif M[1]=='BMSCROLL'then G.disablescroll=true;G.stopsong=true elseif M[1]=='HBSCROLL'then G.stopsong=true elseif M[1]=='SENOTECHANGE'then elseif M[1]=='NEXTSONG'then elseif M[1]=='DIRECTION'then elseif M[1]=='SUDDEN'then elseif M[1]=='JPOSSCROLL'then else end;L=true end end;if(G.songstarted)and L==false then G.mpm=G.bpm*G.sign/4;G.mspermeasure=60000 *G.sign*4 /G.bpm;if G.barline and G.insertbarline then local M=G.createnote()M.ms=G.ms;M.data='event'M.event='barline'table.insert(G.measurepushto,M)G.insertbarline=false end;for i=1,#J do local M=string.sub(J,i,i)if G.settings.noteparse.noteexceptions[M]then else local N=u('parser.noteparse',tonumber(M)or G.settings.noteparse.notealias[M]or M,'Invalid note')if N then local O=G.createnote(N)O.data='note'table.insert(G.currentmeasure,O)end end end;if EndsWith(TrimRight(J),',')then G.mpm=G.bpm*G.sign/4;G.mspermeasure=60000 *G.sign*4 /G.bpm;if#G.currentmeasure==0 then G.ms=G.ms+G.mspermeasure elseif#G.currentmeasure==1 and G.currentmeasure[1].data=='event'and G.currentmeasure[1].event=='barline'then r.Data[#r.Data+1]=G.currentmeasure[1]G.ms=G.ms+G.mspermeasure else local M=0;local N=nil;for i=1,#G.currentmeasure do local P=G.currentmeasure[i]if P.data=='note'then N=N or P.mspermeasure;M=M+1 end end;N=N or G.mspermeasure;local O=N/M;for i=1,#G.currentmeasure do local P=G.currentmeasure[i]if P[1]=='DELAY'then G.ms=G.ms+P[2]else if not p or P.type~=0 then P.ms=G.ms;local Q=G.measurepushto[#G.measurepushto]or r.Data[#r.Data]if Q then Q.nextnote=P end;table.insert(G.measurepushto,P)if P.onnotepush then P.onnotepush()end;O=P.mspermeasure/M end;if P.data=='note'then G.ms=G.ms+O end end end end;G.measuredone=true;G.currentmeasure={}G.insertbarline=true else G.measuredone=false end end end end;print('Parsing Took: '..SToMs(os.clock()-o)..'ms')return q end;function Taiko.SerializeTJA(n)local function o(A)return math.floor(A+0.5)end;local p=5;local q=10 ^p;local function r(A)return math.floor(A*q+0.5)/q end;local function s(A)if math.floor(A)~=A then return string.format('%f',A)else return tostring(A)end end;local function u(A,B)if A<B then return u(B,A)end;if math.abs(B)<0.001 then return A else return u(B,A-math.floor(A/B)*B)end end;local function v(A)local B=u(A,1)return o(A/B),o(1 /B)end;local function w(A)local B,C=string.match(A,'(%d+)/(%d+)')return B,C end;local function x(A)for i=1,#A do A[i]=tostring(A[i])end;return table.concat(A,',')end;local function y(A)local B={}local C={OFFSET=true,DEMOSTART=true}for L,M in pairs(A.Metadata)do local N;if type(M)=='number'then if C[L]then N=tostring(MsToS(tonumber(M)))else N=tostring(M)end elseif type(M)=='table'then N=x(M)elseif type(M)=='string'then N=tostring(M)else N=nil end;if N then B[#B+1]=L;B[#B+1]=':'B[#B+1]=N;B[#B+1]='\n'end end;B[#B+1]='\n\n'local D=false;local E=false;local F=A.Metadata.HEADSCROLL;for i=1,#A.Data do local L=A.Data[i]L.ms=L.ms-L.delay;if L.data=='event'and L.event=='barline'then D=true end;if L.delay and L.delay~=0 then E=true end;if L.scroll and L.scroll~=F then F=false end end;if E then if F then B[#B+1]='#BMSCROLL\n'else B[#B+1]='#HBSCROLL\n'end end;B[#B+1]='#START\n'if D then B[#B+1]='#BARLINEON\n'else B[#B+1]='#BARLINEOFF\n'end;local G={startms=nil}local H=nil;local I=0;local J={scroll=0,bpm=A.Metadata.BPM,measure=nil,gogo=false,delay=0}local K={scroll={'#SCROLL ',nil,function(L)local M=L.scroll/A.Metadata.HEADSCROLL;if M~=J.scroll then J.scroll=M;return tostring(M)end end},bpm={'#BPMCHANGE ',tostring(A.Metadata.BPM),function(L)local M=L.bpm;if M~=J.bpm then J.bpm=M;return tostring(M)end end},measure={'#MEASURE ',false,function(L)local M,N=v(L.bpm*L.mspermeasure/240000)local O=M..'/'..N;if O~=J.measure then J.measure=O;return O end end},gogo={'#GOGO',false,function(L)local M=L.gogo;if M~=J.gogo then J.gogo=M;if M then return'START'else return'END'end end end},delay={'#DELAY ',nil,function(L)if L.delay~=J.delay then local M=L.delay-J.delay;J.delay=L.delay;return s(MsToS(M))end end}}for i=1,#A.Data do local L=A.Data[i]local M=L.ms;if L.data=='note'then G[#G+1]=L elseif L.data=='event'and L.event=='barline'then G.startms=L.ms;G[#G+1]=L end;local N=A.Data[i+1]if(N and N.data=='event'and N.event=='barline')or(i==#A.Data)then if#G==0 then error('No barline')else local O={}for i=2,#G do local S=G[i-1]local T=G[i]O[#O+1]=math.abs(T.ms-S.ms)end;O[#O+1]=math.abs((G.startms+G[1].mspermeasure)-G[#G].ms)local P=O[1]for i=2,#O do P=u(P,O[i])end;if P==nil then error('gcd invalid, probably delay')P=G[1]and(G[1].ms-I)end;local Q=G.startms;local R=Q+G[1].mspermeasure;for i2=1,#G do local S=G[i2]for T,U in pairs(K)do if S[T]==U[2]then else local V=U[3](S)if V then U[2]=V;if B[#B]~='\n'then B[#B+1]='\n'end;B[#B+1]=U[1]B[#B+1]=V;B[#B+1]='\n'end end end;if i2 ~=1 then B[#B+1]=tostring(S.type)end;if i2 ==1 and#G~=1 then B[#B+1]=string.rep('0',( (G[i2 +1]and G[i2 +1].ms or R)-S.ms)/P)else B[#B+1]=string.rep('0',( (G[i2 +1]and G[i2 +1].ms or R)-S.ms)/P-1)end end;B[#B+1]=','B[#B+1]='\n'G={}end end end;if B[#B]~='\n'then B[#B+1]='\n'end;B[#B+1]='\n#END'return table.concat(B)end;local z={'// Automatically Serialized by Taiko.SerializeTJA'}for A,B in pairs(n)do z[#z+1]=y(B)return table.concat(z,'\n\n')end;z=table.concat(z,'\n\n')return z end;function Taiko.Score(n,o,p,q,r)if q==0 then p=0 else p=p+1 end;local s=n.Metadata;return Taiko.Data.ScoreMode.Note[s.SCOREMODE](o,p,s.SCOREINIT,s.SCOREDIFF,q,r),p end;function Taiko.Analyze(n)local o='M'local p={[1]=2,[2]=2,[3]=3,[4]=3}local q={notes={n=0,validn=0},measures=0,lengthms=0,drumrollms=0,drumrollbigms=0,balloonms=0,balloonhit=0,specialms=0,specialhit=0,maxcombo=0,maxscore=0}local r=nil;Taiko.ForAll(n.Data,function(s,u,v)if s.data=='note'then q.notes.n=q.notes.n+1;q.notes[s.type]=q.notes[s.type]and q.notes[s.type]+1 or 1;if p[s.type]then q.maxscore,q.maxcombo=Taiko.Score(n,q.maxscore,q.maxcombo,p[s.type],s.gogo)end;local w=s.endnote;if w then local x=w.ms-s.ms;if s.type==5 then q.drumrollms=q.drumrollms+x elseif s.type==6 then q.drumrollbigms=q.drumrollbigms+x elseif s.type==7 then q.balloonms=q.balloonms+x;q.balloonhit=q.balloonhit+s.requiredhits elseif s.type==9 then q.specialms=q.specialms+x;q.specialhit=q.specialhit+s.requiredhits else end end;r=s elseif s.data=='event'and s.event=='barline'then q.measures=q.measures+1 else end end,o)q.lengthms=r.ms-n.Metadata.OFFSET;q.notes.validn=q.maxcombo;return q end;function Taiko.GetDifficulty(n,o)local p=Taiko.Data.CourseId[string.lower(o)]or o;for q,r in pairs(n)do if r.Metadata.COURSE==p then return r end end;Error('No difficulty found, '..o)return nil end;function Taiko.ForAll(n,o,p)local q=1;for i=1,#n do local r=n[i]if r.branch then if p then local s=r.branch.paths[p]for i2=1,#s do o(s[i2],i2,q)q=q+1 end;q=q-1 else local s=-1;for u,w in pairs(r.branch.paths)do local x=q;for i2=1,#w do o(w[i2],i2,x)x=x+1 end;s=(s<x)and x or s end;q=s end else o(r,i,q)end;q=q+1 end;return n end;function Taiko.GetAllNotes(n)local o={}for p,q in pairs(n)do if q.branch then for r,s in pairs(q.branch.paths)do for i=1,#s do table.insert(o,s[i])end end else table.insert(o,q)end end;return o end;function Taiko.ConnectNotes(n)local o=nil;for i=#n,1,-1 do local p=n[i]p.nextnote=o;o=p end;return n end;function Taiko.ExtractBranch(n,o)return n.branch.paths[o]end;function Taiko.ConnectAll(n)local o=nil;for i=#n,1,-1 do local p=n[i]if p.branch then for q,r in pairs(p.branch.paths)do local s=Taiko.ConnectNotes(r)s[#s].nextnote=o end else p.nextnote=o end;o=p end end;function Taiko.CalculateSpeed(n,o)local p=(o*n.scroll*n.bpm/7500)return p end;function Taiko.CalculateSpeedAll(n,o)for i=1,#n do n[i].speed=Taiko.CalculateSpeed(n[i],o)end;return n end;function Taiko.RenderScale(n)local o={}local p={}local q={}for i=1,#n.Data do local v=n.Data[i]if v.data=='note'then local w=math.floor(v.ms)if math.floor(w)-w==0 then table.insert(o,{w,v.type})table.insert(p,w)else table.insert(q,i)end end end;function gcd2(v,w)if w==0 then return v else return gcd2(w,v%w)end end;function gcdn(v)local w=v[1]for i=2,#v do w=gcd2(w,v[i])end;return w end;local r=gcdn(p)for i=1,#q do local v=o[q[i]]v[1]=math.floor(v[1]/r)*r end;local s=''local u=0;for i=1,#o do o[i][1]=o[i][1]/r;s=s..string.rep(' ',o[i][1]-u)..o[i][2]u=o[i][1]end;return s end;function Taiko.PlaySong(n,o,p,q)local r={on=false,fps=60,frames={}}local s=nil;local u={auto={[1]=false,[2]=true},notespeedmul={[1]=1,[2]=2,[3]=3,[4]=4,[5]=0.25,[6]=0.5,[7]=0.75},songspeedmul={[1]=1,[2]=2,[3]=3,[4]=4,[5]=0.25,[6]=0.5,[7]=0.75}}local v=u.auto[p[2]]or false;local w=u.notespeedmul[p[3]]or 1;local x=u.songspeedmul[p[4]]or 1;local z=true;local A=q or{}A={Hit=A.Hit or{['4']=2,['v']=1,['n']=1,['8']=2},Escape=A.Escape or{['\27']=true,ALT_ESC=true},L=A.L or{KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_A2=true},R=A.R or{KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true},Select=A.Select or{KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}}local B=1;local C=2;local D='>'local E='\n\n\n'local F=10;local G=10;local H=1000;local I=4;local J=0;local K=10;local L=0;local M=40;local N=3;local O=1;local P={[1]={color='red'},[2]={color='blue'},[3]={color='red'},[4]={color='blue'},[5]={color='yellow'},[6]={color='yellow'},[7]={color='cyan'}}local Q=200;local R=Q/4;local S=4;local T=20;M=math.floor(M*I)local U=L+M;N=math.floor(N*I)local V=o or{window=i.initscr()}i.keypad(V,true)i.echo(false)i.raw(true)i.nl(false)i.cbreak(true)i.nodelay(V,true)local W={[0]={Data={[1]={'0','1','1','1','1','1','1','1'},[2]={[2]='1',[5]='1',[8]='1'},[3]={[2]='1',[5]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={[3]='1',[4]='1',[6]='1',[7]='1'},[8]={'0','0','1','1','1','1','1','1'},[9]={[2]='1',[5]='1'},[10]={[2]='1',[5]='1'},[11]={[2]='1',[5]='1'},[12]={[2]='1',[5]='1'},[13]={'0','0','1','1','1','1','1','1'},[15]={'0','1','1','1','1','1','1','1'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'}},Color={All='blue'},Offset={-1,0}},[1]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[8]='1'},[5]={[2]='1',[8]='1'},[6]={'0','0','1','1','1','1','1','0'},[8]={'0','1','1','1','1','1','1','1'},[9]={[5]='1'},[10]={[4]='1',[6]='1'},[11]={[3]='1',[7]='1'},[12]={[2]='1',[8]='1'}},Color={All='white'},Offset={-1,0}},[2]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={'0','1','0','0','1','1','1','1'},[8]={'0','0','1','1','1','1','1','0'},[9]={[2]='1',[8]='1'},[10]={[2]='1',[8]='1'},[11]={[2]='1',[8]='1'},[12]={[2]='1',[8]='1'},[13]={'0','0','1','1','1','1','1','0'},[15]={'0','0','1','1','1','1','1','0'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'},[22]={'0','1','1','1','1','1','1','1'},[23]={[2]='1',[8]='1'},[24]={[2]='1',[8]='1'},[25]={[2]='1',[8]='1'},[26]={[2]='1',[8]='1'},[27]={'0','0','1','1','1','1','1','0'}},Color={All='yellow'},Offset={-1,0}},Size={27,8}}W[3]=W[2]local X={[0]=nil,[1]={},[2]={}}local Y;if h then Y=h else os.execute('chcp 65001')Y={}local nc=([[
⠀ ⢀ ⠠ ⢠ ⠐ ⢐ ⠰ ⢰ ⠈ ⢈ ⠨ ⢨ ⠘ ⢘ ⠸ ⢸
⡀ ⣀ ⡠ ⣠ ⡐ ⣐ ⡰ ⣰ ⡈ ⣈ ⡨ ⣨ ⡘ ⣘ ⡸ ⣸
⠄ ⢄ ⠤ ⢤ ⠔ ⢔ ⠴ ⢴ ⠌ ⢌ ⠬ ⢬ ⠜ ⢜ ⠼ ⢼
⡄ ⣄ ⡤ ⣤ ⡔ ⣔ ⡴ ⣴ ⡌ ⣌ ⡬ ⣬ ⡜ ⣜ ⡼ ⣼
⠂ ⢂ ⠢ ⢢ ⠒ ⢒ ⠲ ⢲ ⠊ ⢊ ⠪ ⢪ ⠚ ⢚ ⠺ ⢺
⡂ ⣂ ⡢ ⣢ ⡒ ⣒ ⡲ ⣲ ⡊ ⣊ ⡪ ⣪ ⡚ ⣚ ⡺ ⣺
⠆ ⢆ ⠦ ⢦ ⠖ ⢖ ⠶ ⢶ ⠎ ⢎ ⠮ ⢮ ⠞ ⢞ ⠾ ⢾
⡆ ⣆ ⡦ ⣦ ⡖ ⣖ ⡶ ⣶ ⡎ ⣎ ⡮ ⣮ ⡞ ⣞ ⡾ ⣾
⠁ ⢁ ⠡ ⢡ ⠑ ⢑ ⠱ ⢱ ⠉ ⢉ ⠩ ⢩ ⠙ ⢙ ⠹ ⢹
⡁ ⣁ ⡡ ⣡ ⡑ ⣑ ⡱ ⣱ ⡉ ⣉ ⡩ ⣩ ⡙ ⣙ ⡹ ⣹
⠅ ⢅ ⠥ ⢥ ⠕ ⢕ ⠵ ⢵ ⠍ ⢍ ⠭ ⢭ ⠝ ⢝ ⠽ ⢽
⡅ ⣅ ⡥ ⣥ ⡕ ⣕ ⡵ ⣵ ⡍ ⣍ ⡭ ⣭ ⡝ ⣝ ⡽ ⣽
⠃ ⢃ ⠣ ⢣ ⠓ ⢓ ⠳ ⢳ ⠋ ⢋ ⠫ ⢫ ⠛ ⢛ ⠻ ⢻
⡃ ⣃ ⡣ ⣣ ⡓ ⣓ ⡳ ⣳ ⡋ ⣋ ⡫ ⣫ ⡛ ⣛ ⡻ ⣻
⠇ ⢇ ⠧ ⢧ ⠗ ⢗ ⠷ ⢷ ⠏ ⢏ ⠯ ⢯ ⠟ ⢟ ⠿ ⢿
⡇ ⣇ ⡧ ⣧ ⡗ ⣗ ⡷ ⣷ ⡏ ⣏ ⡯ ⣯ ⡟ ⣟ ⡿ ⣿]]):gsub('\n',' ')function GenerateDotData()function ToBinary(zc)local Ac={}while zc>0 do local Cc=math.fmod(zc,2)Ac[#Ac+1]=string.sub(Cc,1,1)zc=(zc-Cc)/2 end;local Bc=string.reverse(table.concat(Ac))return string.rep('0',8 -#Bc)..Bc end;local function tc(zc)return zc end;local uc=Split(nc,' ')local vc={}local wc=false;local xc=''local yc=' 'for i=1,#uc do vc[i-1]=tc(uc[i])end;return vc end;Y.Data={}Y.Data.Dot=GenerateDotData()Y.ColorData={reset=0,clear=0,space=0,bright=1,bold=1,dim=2,faint=1,italic=3,underline=4,blink=5,reverse=7,invisible=8,hidden=8,strikethrough=9,black=30,red=31,green=32,yellow=33,blue=34,purple=35,magenta=35,cyan=36,white=37,onblack=40,onred=41,ongreen=42,onyellow=43,onblue=44,onpurple=45,onmagenta=45,oncyan=46,onwhite=47}Y.Color={}for tc,uc in pairs(Y.ColorData)do Y.Color[tc]='\27['..uc..'m'end;local oc,pc=L,M;local qc,rc=-K,K;qc,rc=-20,20;Y.Convert={}Y.Convert.ToDots=function(tc,uc)uc=uc or 0;local vc,wc=oc+uc,pc+uc;local xc,yc=tc.Data,tc.Color;local zc={}local Ac=0;local Bc=Y.Data.Dot[Ac]local Cc=nil;local Dc=nil;local Ec=Y.Color['reset']if tc.Color.All then local Fc=Y.Color[tc.Color.All]zc[#zc+1]=Fc;Dc=Fc end;if not qc then return''end;for y=qc,rc,4 do for x=vc,wc,2 do local Fc=xc[x]local Gc=xc[x+1]local Hc=(Fc and( (Fc[y]or 0)*128 + (Fc[y+1]or 0)*64 + (Fc[y+2]or 0)*32 + (Fc[y+3]or 0)*16)or 0)+ (Gc and( (Gc[y]or 0)*8 + (Gc[y+1]or 0)*4 + (Gc[y+2]or 0)*2 + (Gc[y+3]or 0))or 0)if Hc~=Ac then Hc=Y.Data.Dot[Hc]if not Dc then local Ic=yc[x]local Jc=yc[x+1]local Kc=( (Ic)and(Ic[y]or Ic[y+1]or Ic[y+2]or Ic[y+3]))or( (Jc)and(Jc[y]or Jc[y+1]or Jc[y+2]or Jc[y+3]))if Kc then Kc=Y.Color[Kc]else Kc=Ec end;if Cc==Kc then else zc[#zc+1]=Kc;Cc=Kc end end;zc[#zc+1]=Hc else zc[#zc+1]=Bc end end;zc[#zc+1]='\n'end;zc[#zc+1]=Ec;return table.concat(zc)end;Y.ToDotsParallel=function(tc,uc,vc)vc=vc or 0;local wc,xc=oc+vc,pc+vc;local yc,zc=tc.Data,tc.Color;local Ac,Bc=uc.Data,uc.Color;local Cc={}local Dc=0;local Ec=Y.Data.Dot[Dc]local Fc=nil;local Gc=nil;local Hc=Y.Color['reset']if tc.Color.All then local Ic=Y.Color[tc.Color.All]Cc[#Cc+1]=Ic;Gc=Ic end;if not qc then return''end;for y=qc,rc,4 do for x=wc,xc,2 do local Ic=yc[x]local Jc=yc[x+1]local Kc=Ac[x]local Lc=Ac[x+1]local Mc=( (Ic and Kc)and( (Ic[y]or Kc[y]or 0)*128 + (Ic[y+1]or Kc[y+1]or 0)*64 + (Ic[y+2]or Kc[y+2]or 0)*32 + (Ic[y+3]or Kc[y+3]or 0)*16)or(Ic)and( (Ic[y]or 0)*128 + (Ic[y+1]or 0)*64 + (Ic[y+2]or 0)*32 + (Ic[y+3]or 0)*16)or(Kc)and( (Kc[y]or 0)*128 + (Kc[y+1]or 0)*64 + (Kc[y+2]or 0)*32 + (Kc[y+3]or 0)*16)or 0)+ ( (Jc and Lc)and( (Jc[y]or Lc[y]or 0)*8 + (Jc[y+1]or Lc[y+1]or 0)*4 + (Jc[y+2]or Lc[y+2]or 0)*2 + (Jc[y+3]or Lc[y+3]or 0))or(Jc)and( (Jc[y]or 0)*8 + (Jc[y+1]or 0)*4 + (Jc[y+2]or 0)*2 + (Jc[y+3]or 0))or(Lc)and( (Lc[y]or 0)*8 + (Lc[y+1]or 0)*4 + (Lc[y+2]or 0)*2 + (Lc[y+3]or 0))or 0)if Mc~=Dc then Mc=Y.Data.Dot[Mc]if not Gc then local Nc=Bc[x]local Oc=Bc[x+1]local Pc=zc[x]local Qc=zc[x+1]local Rc=Pc and(Pc[y]or Pc[y+1]or Pc[y+2]or Pc[y+3])or Qc and(Qc[y]or Qc[y+1]or Qc[y+2]or Qc[y+3])or Nc and(Nc[y]or Nc[y+1]or Nc[y+2]or Nc[y+3])or Oc and(Oc[y]or Oc[y+1]or Oc[y+2]or Oc[y+3])if Rc then Rc=Y.Color[Rc]else Rc=Hc end;if Fc==Rc then else Cc[#Cc+1]=Rc;Fc=Rc end end;Cc[#Cc+1]=Mc else Cc[#Cc+1]=Ec end end;Cc[#Cc+1]='\n'end;Cc[#Cc+1]=Hc;return table.concat(Cc)end;Y.CircleGen=function(tc,uc,vc,wc,xc)xc=xc or{}local yc=xc.color;local zc=wc*wc;local Ac=wc;for y=0,wc do Ac=Ac+1;repeat Ac=Ac-1 until Ac*Ac+y*y<=zc;for x2=0,Ac do tc.Data[uc+x2]=tc.Data[uc+x2]or{}tc.Data[uc-x2]=tc.Data[uc-x2]or{}tc.Data[uc+x2][vc+y]='1'tc.Data[uc-x2][vc+y]='1'tc.Data[uc+x2][vc-y]='1'tc.Data[uc-x2][vc-y]='1'tc.Color[uc+x2]=tc.Color[uc+x2]or{}tc.Color[uc-x2]=tc.Color[uc-x2]or{}tc.Color[uc+x2][vc+y]=yc;tc.Color[uc-x2][vc+y]=yc;tc.Color[uc+x2][vc-y]=yc;tc.Color[uc-x2][vc-y]=yc end end;return tc end;local sc={}Y.Circle=function(tc,uc,vc,wc,xc)local yc=nil;if sc[wc]then else sc[wc]=Y.CircleGen(Y.New(),0,0,wc)end;local zc=xc and xc.color;yc=sc[wc]for Ac,Bc in pairs(yc.Data)do for Cc,Dc in pairs(Bc)do local Ec,Fc=Ac+uc,Cc+vc;tc.Data[Ec]=tc.Data[Ec]or{}tc.Data[Ec][Fc]=Dc;tc.Color[Ec]=tc.Color[Ec]or{}tc.Color[Ec][Fc]=zc end end;return tc end;Y.New=function()return{Data={},Color={}}end;h=Y end;local function Z(nc,oc)local pc=math.floor(oc.p)local qc,rc=J-K,J+K;for y=qc,rc do nc.Data[pc]=nc.Data[pc]or{}nc.Data[pc][y]='1'end end;local function ab(nc,oc,pc)pc=pc or oc.p;Y.Circle(nc,math.floor(pc),J,I*oc.radius,P[oc.type])end;local function bb(nc,oc,pc,qc,rc,sc)local tc=sc or{}color=tc.color;for y=qc,rc do for x=oc,pc do nc.Data[x]=nc.Data[x]or{}nc.Data[x][y]='1'if color then nc.Color[x]=nc.Color[x]or{}nc.Color[x][y]=color end end end end;local cb=(L-F)local db=(M+F)local function eb(nc,oc,pc)local qc=oc.type;if qc==1 or qc==2 or qc==3 or qc==4 then ab(nc,oc)elseif qc==5 or qc==6 then ab(nc,oc)local rc=oc.endnote;local sc=(rc.ms-oc.ms)*oc.speed;local tc=I*oc.radius;local uc,vc=math.floor(oc.p),math.floor(oc.p+sc)local wc=math.floor(J-tc)local xc=math.floor(J+tc)ab(nc,rc,vc)if pc then else if uc>vc then uc,vc=vc,uc end;if uc<cb then uc=cb end;if vc>db then vc=db end end;bb(nc,uc,vc,wc,xc,P[oc.type])elseif qc==7 then oc.radius=0.8;ab(nc,oc)elseif qc==8 then end end;local function fb(nc,oc,pc,qc)local rc=S/ (R/2)local sc=-rc*math.abs(( (pc-oc.startms)/ (Q/R))- (S/rc))+S;local tc=W[oc.status]local uc=tc.Offset;local vc=tc.Color.All;local wc,xc=0,-math.floor(I*1.6)-8 -math.floor(sc)local yc,zc=uc[1]+wc+qc,uc[2]+xc;for x=1,W.Size[1]do for y=1,W.Size[2]do local Ac,Bc=x+yc,y+zc;nc.Data[Ac]=nc.Data[Ac]or{}nc.Data[Ac][Bc]=tc.Data[x]and tc.Data[x][y]nc.Color[Ac]=nc.Color[Ac]or{}nc.Color[Ac][Bc]=vc end end end;local function gb(nc,oc)local pc=X[oc.status]local qc=pc.Offset;local rc=pc.Color.All;local sc,tc=0,0;for uc,vc in pairs(pc.Data)do for wc,xc in pairs(vc)do if xc=='1'then local yc,zc=uc+qc[1]+sc,wc+qc[2]+tc;nc.Data[yc]=nc.Data[yc]or{}nc.Data[yc][zc]=xc;nc.Color[yc]=nc.Color[yc]or{}nc.Color[yc][zc]=rc end end end end;local hb={ClearScreen=function()io.write("\27[2J")end,SetCursor=function(nc,oc)io.write(string.format("\27[%d;%dH",oc,nc))end}local ib=Taiko.GetAllNotes(n.Data)local jb=n.Metadata.OFFSET;local kb=1000 /60;local lb=n.Metadata.TIMING(kb/x)local function mb(nc)return(nc.data=='note')or(nc.data=='event'and nc.event=='barline')end;local function nb(nc,oc)return oc- (( (M+F)/math.abs(nc.speed)))end;local function ob(nc,oc)return(nc.ms-oc)*nc.speed+N end;local function pb(nc,oc,pc)return nc.loadp- (nc.speed* (oc-nc.loadms))end;local qb={}for nc,oc in pairs(ib)do oc.ms=oc.oms or oc.ms;oc.oms=oc.ms;oc.ms=(oc.ms-jb)/x;oc.s=MsToS(oc.ms)oc.delay=oc.odelay or oc.delay;oc.odelay=oc.delay;oc.delay=oc.delay/x;oc.speed=(Taiko.CalculateSpeed(oc,I))*w;oc.loadms=nb(oc,oc.ms)oc.loads=MsToS(oc.loadms)oc.loadp=ob(oc,oc.loadms)oc.hit=nil;qb[#qb+1]=oc.ms end;if z then for pc,qc in pairs(n.Data)do if qc.branch then for rc,sc in pairs(qc.branch.paths)do table.sort(sc,function(tc,uc)return tc.ms<uc.ms end)end end end;table.sort(n.Data,function(pc,qc)if pc.branch and qc.branch then for rc,sc in pairs(pc.branch.paths)do for tc,uc in pairs(qc.branch.paths)do return sc[1].ms<uc[1].ms end end elseif pc.branch then for rc,sc in pairs(pc.branch.paths)do return sc[1].ms<qc.ms end elseif qc.branch then for rc,sc in pairs(qc.branch.paths)do return pc.ms<sc[1].ms end else return pc.ms<qc.ms end end)local nc=nil;local oc=0;Taiko.ForAll(n.Data,function(pc,qc,rc)if pc.delay~=oc then if nc then nc.stopms=pc.delay-nc.delay;nc.stopstart=nc.ms;nc.stopend=nc.stopstart+nc.stopms end;oc=pc.delay end;if nc and nc.delay~=0 then nc.ms=nc.ms-nc.delay;nc.s=MsToS(nc.ms)nc.loadms=nb(nc,nc.ms)nc.loads=MsToS(nc.loadms)nc.loadp=ob(nc,nc.loadms)nc.ms=nc.ms+nc.delay;nc.s=MsToS(nc.ms)end;nc=pc end)end;for nc,oc in pairs(n.Data)do if oc.branch then for pc,qc in pairs(oc.branch.paths)do table.sort(qc,function(rc,sc)return rc.loadms<sc.loadms end)end end end;table.sort(n.Data,function(nc,oc)if nc.branch and oc.branch then for pc,qc in pairs(nc.branch.paths)do for rc,sc in pairs(oc.branch.paths)do return qc[1].loadms<sc[1].loadms end end elseif nc.branch then for pc,qc in pairs(nc.branch.paths)do return qc[1].loadms<oc.loadms end elseif oc.branch then for pc,qc in pairs(oc.branch.paths)do return nc.loadms<qc[1].loadms end else return nc.loadms<oc.loadms end end)Taiko.ConnectAll(n.Data)Taiko.ForAll(n.Data,function(nc,oc,pc)nc.n=pc end)local rb=H/x;local sb=qb[1]for i=1,#qb do if qb[i]>sb then sb=qb[i]end end;sb=sb+rb;loaded={}local tb=n.Data[1]local ub=tb.loads;local vb=10;local wb=string.rep(' ',vb)local xb={}local function yb(nc,oc)xb[#xb+1]=nc;xb[#xb+1]=': 'xb[#xb+1]=tostring(oc)xb[#xb+1]=wb;xb[#xb+1]='\n'end;local function zb()print(table.concat(xb))xb={}end;local Ab={}local function Bb(nc)Ab[#Ab+1]=nc end;local function Cb()print(table.concat(Ab,'\n'))Ab={}end;hb.ClearScreen()local Db='M'local Eb=0;local Fb,Gb,Hb=n.Metadata.SCOREINIT,n.Metadata.SCOREDIFF,Taiko.Data.ScoreMode.Note[n.Metadata.SCOREMODE]local Ib=0;local Jb=false;local Kb=nil;local Lb=nil;local Mb=nil;local Nb=Taiko.Data.ScoreMode.Balloon[n.Metadata.SCOREMODE]local Ob=Taiko.Data.ScoreMode.BalloonPop[n.Metadata.SCOREMODE]local Pb=nil;local Qb=nil;local Rb=nil;local Sb=Taiko.Data.ScoreMode.Drumroll[n.Metadata.SCOREMODE]local Tb={startms=nil,status=nil}local Ub=nil;local Vb=nil;local Wb=nil;local Xb=0;local Yb={-1,nil}local Zb=0;local ac=0;local bc=true;local cc=false;local dc=false;local ec=nil;local fc=nil;local gc=nil;local hc=nil;local ic=nil;local jc=nil;local kc=os.clock()local lc,mc;if s then lc=1 /s;mc=kc+lc end;if not r.on then while true do local nc=Y.New()local oc=os.clock()local pc=oc-kc;local qc=pc*1000;if Wb and qc>Wb then Ub,Vb,Wb=nil,nil,nil end;if Kb and qc>Mb then Kb,Lb,Mb=nil,nil,nil end;if Pb and qc>Rb then Pb,Qb,Rb=nil,nil,nil end;if tb then if tb.loadms<qc then loaded[#loaded+1]=tb;if dc and tb.speed~=ec then dc=false end;if dc then tb.p=pb(tb,ic)if tb.data=='event'then if tb.event=='barline'then Z(gc,tb,dc)end elseif tb.data=='note'then eb(gc,tb,dc)else error('Invalid note.data')end end;tb=tb.nextnote;if tb and tb.branch then tb=tb.branch.paths[Db][1]end end else if qc>sb then break end end;if cc and dc==false then local zc=nil;for i=1,#loaded do if zc then if loaded[i]and zc~=loaded[i].speed then zc=false;break end else zc=loaded[i].speed end end;if zc then ic=qc;ec=zc;gc=false;hc=loaded[1]dc=true else dc=false end end;local rc=0;if dc and gc then bc=false;local zc=loaded[1]local Ac=fc or zc.p;fc=Ac;local Bc=pb(hc,qc)Ac=Ac or Bc;local Cc=math.floor(Ac-Bc+0.5)if Cc>=1 then rc=Cc else end;nc=gc else fc=nil;bc=true end;if bc and gc~=false then Y.Circle(nc,math.floor(N),J,I,{color='purple'})end;if dc then jc=Y.New()Y.Circle(jc,math.floor(N)+rc,J,I,{color='purple'})end;local sc={}local tc={}local uc=0;for i=1,#loaded do local zc=i+uc;local Ac=loaded[zc]if Ac then if Ac.data=='note'then if(Ac.type==1 or Ac.type==3)and(not sc[1]or math.abs(qc-Ac.ms)<sc[1])then sc[1]=math.abs(qc-Ac.ms)tc[1]=Ac elseif(Ac.type==2 or Ac.type==4)and(not sc[2]or math.abs(qc-Ac.ms)<sc[2])then sc[2]=math.abs(qc-Ac.ms)tc[2]=Ac end end;Ac.p=pb(Ac,Ub or(qc+Xb))if qc>Ac.ms then Jb=Ac.gogo;if Ac.type==7 then if Kb then if Kb.n==Ac.n then Ac.p=N else end end;Kb=Ac;Lb=Ac.ms;Mb=Ac.ms+Ac.length elseif Ac.type==5 or Ac.type==6 then Pb=Ac;Qb=Ac.ms;Rb=Ac.ms+Ac.length end end;if z and Ac.stopstart and qc>Ac.stopstart then Ub=Xb+Ac.stopstart;stopms=Ac.stopms;Xb=Xb-Ac.stopms;Vb=Ac.stopstart;Wb=Ac.stopend;Ac.stopstart=nil end;if(Ac.hit or math.abs(Ac.p-N)> ( (Ac.delay*math.abs(Ac.speed))+M+G))and(not(Ac.endnote and Ac.endnote.done~=true and(not Ac.hit)))then Ac.done=true;table.remove(loaded,zc)uc=uc-1 else if bc then if Ac.data=='event'then if Ac.event=='barline'then Z(nc,Ac)end elseif Ac.data=='note'then eb(nc,Ac)else error('Invalid note.data')end end end end end;if gc==false then gc=nc end;if Tb.status then if qc>Tb.startms+Q then Tb={}else if dc then fb(jc,Tb,qc,rc)else fb(nc,Tb,qc,rc)end end end;hb.SetCursor(1,1)if dc then if jc then print(Y.ToDotsParallel(nc,jc,rc))else print(Y.Convert.ToDots(nc,rc))end else if s then local zc=Y.Convert.ToDots(nc,rc)repeat until os.clock()>=mc;mc=mc+lc;print(zc)else print(Y.Convert.ToDots(nc,rc))end end;Zb=Zb+1;local vc=os.clock()-oc;ac=ac+vc;local wc=i.getch(V)local xc=i.getkeyname(wc)local yc=A.Hit[xc]if v then local zc=sc[1]local Ac=sc[2]local Bc=(sc[1]and sc[2])and( (sc[1]<sc[2])and 1 or 2)or(sc[1]and 1 or 2)local Cc=sc[Bc]local Dc=tc[Bc]if Cc and qc>=Dc.ms and(not Dc.hit)then yc=Bc elseif not Cc or(Cc and Cc> (lb.bad* ( ( (Dc.type==3 or Dc.type==4)and Taiko.Data.BigLeniency)or 1)))then if Lb and(qc>Lb and qc<Mb)then yc=1 elseif Qb and(qc>Qb and qc<Rb)then yc=1 end end end;if yc then if sc[yc]and(not tc[yc].hit)then local zc=tc[yc]local Ac=zc.type;local Bc=zc.gogo;local Cc=sc[yc]local Dc;local Ec=( (Ac==3 or Ac==4)and Taiko.Data.BigLeniency)or 1;if Cc< (lb.good)then Dc=( (Ac==3 or Ac==4)and 3)or 2;Ib=Ib+1 elseif Cc< (lb.ok*Ec)then Dc=1;Ib=Ib+1 elseif Cc< (lb.bad*Ec)then Dc=0;Ib=0 else Dc=nil end;if Dc then Eb=Hb(Eb,Ib,Fb,Gb,Dc,Bc)tc[yc].hit=true;Tb={startms=qc,status=Dc}end end;if(yc==1)and Lb and(qc>Lb and qc<Mb)then Eb=Nb(Eb,Kb.type,notegogo)end;if(yc==1 or yc==2)and Qb and(qc>Qb and qc<Rb)then Eb=Sb(Eb,Pb.type,notegogo)end end;if A.Escape[xc]then local zc=os.clock()hb.ClearScreen()i.nodelay(V,false)local Ac={'Back','Retry','Back to Select'}while true do hb.SetCursor(1,1)local Bc={}for i=1,#Ac do Bc[i]=( (i==B)and(D..string.rep(' ',C-#D))or string.rep(' ',C))..Ac[i]end;print(table.concat(Bc,E))local Cc=i.getch(V)local Dc=i.getkeyname(Cc)if A.L[Dc]then B=B==1 and 1 or B-1 elseif A.R[Dc]then B=B==3 and 3 or B+1 elseif A.Select[Dc]then if B==1 then elseif B==2 then return'Retry'elseif B==3 then return nil end;break elseif A.Escape[Dc]then break end end;i.nodelay(V,true)kc=kc+ (os.clock()-zc)end;if wc~=-1 then Yb={wc,xc}end;yb('Input (ascii)',Yb[1])yb('Input (key)',Yb[2])yb('S',pc)yb('Ms',qc)yb('Loaded',#loaded)yb('Frames Rendered',Zb)yb('Last Frame Render (ms)',vc*1000)yb('Frame Render Total (ms)',ac*1000)yb('Frame Render Total (%)',ac/pc*100)yb('FPS (Frame)',Zb/pc)yb('Score',Eb)yb('Combo',Ib)yb('Gogo',Jb)yb('Drumroll Start',Qb)yb('Drumroll End',Rb)zb()Cb()end else error('Prerendering has been removed')end;return true end;function Taiko.SongSelect(n,o)local p={}local q,r=10,10;local s,u,v,w=-q,q,-r,r;local x=true;local y=1;local z=1;local A=4;local B=5;local C=5;local D=2;local E='V'local F='>'local G=10;local H=nil;local I='>'local J='>'local K=2;local L=true;local M={[2]={'Normal','Auto'},[3]={'Normal','2x Speed','3x Speed','4x Speed','0.25x Speed','0.5x Speed','0.75x Speed'},[4]={'Normal','2x Speed','3x Speed','4x Speed','0.25x Speed','0.5x Speed','0.75x Speed'},[5]={'Normal','Reverse','Invisible','Messy'}}local N={4,1,1,1,1,1}local O={nil}for hb,ib in pairs(M)do O[hb]={1,#ib,ib}end;local P={window=i.initscr()}i.keypad(P,true)i.echo(false)i.raw(true)i.nl(false)i.cbreak(true)i.nodelay(P,true)i.getch(P)i.nodelay(P,false)local Q,R=i.cols(),i.lines()H=H or Q-2;local S={Escape={['\27']=true,ALT_ESC=true},Scroll={L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_A2=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true}},Select={Init={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Escape={['\27']=true,ALT_ESC=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true},U={KEY_UP=true,KEY_A2=true},D={KEY_DOWN=true,KEY_C2=true},Play={Hit={['4']=2,['v']=1,['n']=1,['8']=2},Escape={['\27']=true,ALT_ESC=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_DOWN=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}}},Search={Init={ALT_F=true,f=true,F=true},Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},FirstResult={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Select={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true},Up={KEY_A2=true,KEY_UP=true},Down={KEY_C2=true,KEY_DOWN=true},Escape={['\27']=true,ALT_ESC=true}},Add={Init={ALT_N=true,n=true,N=true},Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}},StandardInput={Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},Escape={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_DOWN=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true}}}local T={ClearScreen=function()io.write("\27[2J")end,SetCursor=function(hb,ib)io.write(string.format("\27[%d;%dH",ib,hb))end,ClearLine=function()io.write("\27[2K")end,CursorLeft=function(hb)io.write(string.format("\27[%dD",hb))end,CursorRight=function(hb)io.write(string.format("\27[%dC",hb))end,SaveCursor=function()io.write("\27[s")end,RestoreCursor=function()io.write("\27[u")end}local function U(hb)return hb..string.rep(' ',H-#hb)end;local function V()local hb=i.getch(P)local ib=i.getkeyname(hb)return hb,ib end;local function W()local hb=''local ib=0;local jb=ib;while true do local kb,lb=V()if S.StandardInput.Backspace[lb]then hb=string.sub(hb,1,ib-1)..string.sub(hb,ib+1,-1)ib=ib-1 elseif S.StandardInput.Escape[lb]then io.write('\n')return hb elseif S.StandardInput.L[lb]then ib=ib-1 elseif S.StandardInput.R[lb]then ib=ib+1 else hb=string.sub(hb,1,ib)..lb..string.sub(hb,ib+1,-1)ib=ib+1 end;ib=ClipN(ib,0,#hb)local mb=ib-jb;if mb<0 then T.CursorLeft(-mb)elseif mb>0 then T.CursorRight(mb)end;T.SaveCursor()T.ClearLine()io.write('\r')io.write(hb)T.RestoreCursor()jb=ib end end;local function X(hb)return hb>=32 and hb<=126 end;local function Y(hb,ib,jb,kb)return(hb and(ib..string.sub(jb,#ib+1,-1))or jb)..kb end;local function Z(hb,ib,jb)return hb>jb and ib or hb<ib and jb or hb end;local ab={[0]='No',[1]='Yes'}local function bb(hb)return hb and ab[1]or ab[0]end;local function cb(hb)return hb*100 ..'%'end;local function db(hb)return MsToS(hb)..'s'end;local function eb(hb)return db(SToMs(hb))end;local function fb(hb)return tonumber(hb)and tonumber(hb)or 0 end;local gb={}T.ClearScreen()while true do p={}if x then p[s]={}for i=y-B,y+B do local lb=nil;if i<1 then lb=#n+i elseif i>#n then lb=i-#n else lb=i end;local mb=n[lb]if mb then p[0]=p[0]or{}p[0][(i-y)*C]=mb end end;local jb={}local kb=string.rep(' ',D)for y=v,w do jb[#jb+1]=Y(y==0,F,kb,'')jb[#jb+1]=U(p[0][y]or'')jb[#jb+1]='\n'end;T.SetCursor(1,1)print(table.concat(jb))else p[0]={}p[0][v]=E;for i=y-B,y+B do local kb=nil;if i<1 then kb=#n+i elseif i>#n then kb=i-#n else kb=i end;local lb=n[kb]if lb then local mb=(i-y)*C;p[mb]=p[mb]or{}local nb=v+D;for i2=1,#lb do p[mb][nb]=string.sub(lb,i2,i2)nb=nb+1 end end end;local jb={}for y=v,w do for x=s,u do if p[x]and p[x][y]then local kb=p[x][y]if X(string.byte(kb))then jb[#jb+1]=kb else jb[#jb+1]=' 'end else jb[#jb+1]=' 'end end;jb[#jb+1]='\n'end;T.SetCursor(1,1)print(table.concat(jb))end;local hb,ib=V()if S.Scroll.L[ib]then y=y-1 elseif S.Scroll.R[ib]then y=y+1 elseif S.Select.Init[ib]then local jb;if L then if gb[y]then jb=gb[y]else jb=Taiko.ParseTJA(o[y])gb[y]=jb end else jb=Taiko.ParseTJA(o[y])end;local kb={}for ob,pb in pairs(jb)do kb[#kb+1]={ob,pb.Metadata.COURSE}end;table.sort(kb,function(ob,pb)return ob[2]<pb[2]end)min=1;max=#kb;O[1]={min,max,kb}DifficultyMap=kb;N[1]=ClipN(N[1],min,max)local lb=string.rep(' ',K)T.ClearScreen()T.SetCursor(1,1)local mb=nil;local nb=z;while true do z=ClipN(z,1,5)if z~=nb then A=N[z]nb=z end;local ob=O[z]min,max=ob[1],ob[2]A=Z(A,min,max)N[z]=A;T.SetCursor(1,1)local pb=DifficultyMap[N[1]][2]mb=Taiko.GetDifficulty(jb,pb)local qb=mb.Metadata;local rb=Taiko.Analyze(mb)local sb={{'',qb.TITLE},{'\t',qb.SUBTITLE},{'',''},{'','Select Options:'},{Y(z==1,J,lb,'Difficulty: '),Taiko.Data.CourseName[qb.COURSE]},{Y(z==2,J,lb,'Mode: '),M[2][N[2]]},{Y(z==3,J,lb,'Note Speed: '),M[3][N[3]]},{Y(z==4,J,lb,'Song Speed: '),M[4][N[4]]},{Y(z==5,J,lb,'Modifiers: '),M[5][N[5]]},{'',''},{'Difficulty: ',Taiko.Data.CourseName[qb.COURSE]},{'Stars: ',qb.LEVEL},{'Diverge Notes: ',bb(qb.DIVERGENOTES)},{'',''},{'','Statistics:'},{'Don (DON) / Ka (KA): ',fb(rb.notes[1])..' + ('..fb(rb.notes[3])..') / '..fb(rb.notes[2])..' + ('..fb(rb.notes[4])..') = '..cb((fb(rb.notes[1])+fb(rb.notes[3]))/rb.notes.validn)..' / '..cb((fb(rb.notes[2])+fb(rb.notes[4]))/rb.notes.validn)},{'Max Score (without drumroll): ',rb.maxscore},{'Max Combo: ',rb.maxcombo},{'Drumroll Time (total): ',db(rb.drumrollms+rb.drumrollbigms)},{'Balloon Time: ',db(rb.balloonms)},{'Balloon Hits: ',rb.balloonhit},{'Special Time: ',db(rb.specialms)},{'Special Hits: ',rb.specialhit},{'',''},{'','Press Enter to Play!'}}for i=1,#sb do local vb=sb[i]print(U(vb[1]..tostring(vb[2])))end;local tb,ub=V()if S.Select.L[ub]then A=A-1 elseif S.Select.R[ub]then A=A+1 elseif S.Select.U[ub]then z=z-1 elseif S.Select.D[ub]then z=z+1 elseif S.Select.Select[ub]then while true do local vb,wb=Taiko.PlaySong(Taiko.GetDifficulty(jb,pb),P,N,S.Select.Play)if vb and wb then break elseif vb=='Retry'then else break end end;i.nodelay(P,false)T.ClearScreen()elseif S.Select.Escape[ub]then break end end elseif S.Search.Init[ib]then local jb=''local kb={}local lb=1;local mb=nil;local nb=1;T.ClearScreen()T.SetCursor(1,1)print('Searching...')while true do T.SetCursor(#jb+1,2)local ob,pb=V()T.SetCursor(1,2)if S.Search.Backspace[pb]then jb=string.sub(jb,1,-2)elseif S.Search.FirstResult[pb]then mb=kb[1]break elseif S.Search.Select[pb]then mb=kb[nb]break elseif S.Search.Down[pb]then nb=nb+1 elseif S.Search.Up[pb]then nb=nb-1 elseif S.Search.Escape[pb]then break else jb=jb..pb end;print(U(jb))local qb=j.SearchHeaderAll(n,jb)for i=1,G do if qb[i][2]==-math.huge then lb=i-1;break elseif i==G then lb=i end end;nb=ClipN(nb,1,lb)local rb=false;for i=1,G do local sb=qb[i]if rb then print(U(''))else if sb then if sb[2]==-math.huge then rb=true;print(U(''))else print(U((i==nb and I or i)..'. '..qb[i][3]))kb[i]=sb end end end end end;y=(mb and mb[1]or y)or y elseif S.Add.Init[ib]then print('Import a Custom Song')while true do print('Enter a .tja or .tjac file path (with the file extention)')local jb=W()local kb=io.open(jb,'rb')if kb then local lb=kb:read('*all')if EndsWith(jb,'.tja')then print('Enter a song name')local mb=W()n[#n+1]=mb;o[#o+1]=lb;break elseif EndsWith(jb,'.tjac')then local mb,nb=j.Decompress(lb)for i=1,#mb do o[#o+1]=mb[i]n[#n+1]=nb[i]end;break else print('Invalid file type')end;io.close(kb)else print('Unable to read file')end end elseif S.Escape[ib]then return end;y=Z(y,1,#n)end end;function Taiko.Game()end;local k='./CompactTJA/taikobuipm.tjac'k='./CompactTJA/ESE/06 Classical.tjac'k='./CompactTJA/ESE/ESE.tjac'local l,m=j.Decompress(j.Read(k))Taiko.SongSelect(m,l)error()Taiko.PlaySong(Taiko.GetDifficulty(Taiko.ParseTJA(j.InputFile(k)),'Ura'))
local g;Split=function(l,m)local n={}for o,p in l:gmatch("([^"..m.."]*)("..m.."?)")do table.insert(n,o)if p==''then return n end end end;Trim=function(l)local m=l:gsub("^%s*(.-)%s*$","%1")return m end;TrimLeft=function(l)local m=l:gsub("^%s*(.-)$","%1")return m end;TrimRight=function(l)local m=l:gsub("^(.-)%s*$","%1")return m end;StartsWith=function(l,m)return l:sub(1,#m)==m end;EndsWith=function(l,m)return l:sub(-#m,-1)==m end;Table={}function Table.Clone(l,m)m=m or{}local n=type(l)local o;if n=='table'then if m[l]then o=m[l]else o={}m[l]=o;for p,q in next,l,nil do o[Table.Clone(p,m)]=Table.Clone(q,m)end;setmetatable(o,Table.Clone(getmetatable(l),m))end else o=l end;return o end;ClipN=function(l,m,o)if l<m then return m elseif l>o then return o else return l end end;function Error(l)error(l)end;LineN=nil;function ParseError(l,m,n)Error('Line: '..LineN..'\n'..l..': '..m.. (n and(', '..n)or''))end;function MsToS(l)return l/1000 end;function SToMs(l)return l*1000 end;Taiko={}Taiko.Data={Languages={'','EN','JA','CN','TW','KO'},GenreName={Pop={'pop','j-pop'},Anime={'anime','アニメ'},Kids={'kids','どうよう'},Variety={'variety','バラエティ'},VOCALOID={'vocaloid','ボーカロイド'},Classic={'classic','クラシック'},['Game Music']={'game music','ゲームミュージック'},['Namco Original']={'namco original','ナムコオリジナル'}},CourseId={easy=0,normal=1,hard=2,oni=3,edit=4,tower=5,dan=6,ura=4},CourseName={[0]='Easy','Normal','Hard','Oni','Edit','Tower','Dan','Ura'},RatingMultiplier={[0]=0,[1]=0.5,[2]=1,[3]=2},GogoMultiplier=1.2,ScoreMode={[0]=function(l,m,n,o,p,q)return l+ ( ( (m<200)and(n or 1000)or( (n or 1000)+ (o or 1000)))*Taiko.Data.RatingMultiplier[p]* (q and Taiko.Data.GogoMultiplier or 1))end,[1]=function(l,m,n,o,p,q)return l+ ( (n+math.max(0,o*math.floor((math.min(m,100)-1)/10)))*Taiko.Data.RatingMultiplier[p]* (q and Taiko.Data.GogoMultiplier or 1))end,[2]=function(l,m,n,o,p,q)return l+ ( (n+o* ( (m>=100)and 8 or(m>=50)and 4 or(m>=30)and 2 or(m>=10)and 1 or 0))*Taiko.Data.RatingMultiplier[p]* (q and Taiko.Data.GogoMultiplier or 1))end},Autoscore={[0]=function(l)end,[1]=function(l)end,[2]=function(l)end},SideId={normal=1,ex=2,both=3},SideName={'normal','ex','both'},StyleId={single=1,double=2,couple=2},StyleName={'single','double'},Exam={Condition={g=true,jp=true,jg=true,jb=true,s=true,r=true,h=true,c=true},Scope={m=true,l=true}},Branch={PathId={N=0,E=1,M=2},PathName={[0]='N',[1]='E',[2]='M'},Requirements={r=function()end,p=function()end}},Timing={GetFunction=function(l)return function(m)if l==1 then return{good=5 /2 *m,ok=13 /2 *m,bad=15 /2 *m}else return{good=3 /2 *m,ok=9 /2 *m,bad=13 /2 *m}end end end},StatusId={bad=0,ok=1,good=2,biggood=3},StatusName={[0]='BAD',[1]='OK',[2]='GOOD',[3]='GOOD'},ModeId={['']=0,P1=1,P2=2},ModeName={[0]='',P1,P2},Combo={[1]=true,[2]=true,[3]=true,[4]=true},BigLeniency=2,Strings={Notes={}}}for l,m in pairs(Taiko.Data.ScoreMode)do Taiko.Data.ScoreMode[l]=function(...)return math.floor(m(...)/10)*10 end end;function Taiko.ParseTJA(l)local m=os.clock()local n={}local o={Metadata={SUBTITLE='',BPM=120,WAVE='main.mp3',OFFSET=0,DEMOSTART=0,SCOREMODE=1,SONGVOL=100,SEVOL=100,SIDE=3,LIFE=0,GAME='Taiko',HEADSCROLL=1,MOVIEOFFSET=0,COURSE='ONI',LEVEL=0,BALLOON=nil,SCOREINIT,SCOREDIFF,BALLOONNOR=nil,BALLOONEXP=nil,BALLOONMAS=nil,STYLE=1,EXAM1=nil,EXAM2=nil,EXAM3=nil,GAUGEINCR='NORMAL',TOTAL=nil,HIDDENBRANCH=0,DIVERGENOTES=false,SCOREINIT=0,SCOREDIFF=0},Data={}}local function p(B)local C=Taiko.Data.Languages;for i=1,#C do local D=o.Metadata[B..C[i]]if D then return D end end;return nil end;local function q(B,C,D)local E=tonumber(C)if E then return E else ParseError(B,D,C)end end;local function r(B,C,D,E)if C then return C else ParseError(B,D,E)end end;local function s(B,C,D)local E={['true']=true,['false']=false,yes=true,no=false,['1']=true,['0']=false,[1]=true,[0]=false}local F=E[C]~=nil;if F then return F else ParseError(B,D,C)end end;local function u(B,C)local D=','local E='\\'local F={}local G=''local H=false;for i=1,#C do local I=string.sub(C,i,i)if H then G=G..I;H=false else if I==D then table.insert(F,G)G=''elseif I==E then H=true else G=G..I end end end;table.insert(F,G)return F end;local function v(B,C,D)local E=u(B,C)for i=1,#E do E[i]=q(B,E[i],D,C)end;return E end;local function w(B,C,D)if C and C~=''then return v(B,C,D)else return{}end end;local function x(B,C,D)if C and C~=''then local E=u(B,C,D)r(B,Taiko.Data.Exam.Condition[E[1]],D)E[2]=q(B,E[2],D)E[3]=q(B,E[3],D)r(B,Taiko.Data.Exam.Scope[E[4]],D)return E else return{}end end;local y={}local function z()local B={settings={noteparse={notealias={A=3,B=4},noteexceptions={[',']=true,[' ']=true,['\t']=true}},command={matchexceptions={}}},bpm=0,ms=0,songstarted=false,timingpoint=nil,sign=4 /4,mpm=0,mspermeasure=0,scroll=1,measuredone=true,currentmeasure={},measurepushto=o.Data,barline=true,gogo=false,lastlong=nil,balloonn=1,currentbranch=nil,branch={on=false,requirements={},paths={}},msbeforebranch=nil,section=false,disablescroll=false,stopsong=false,delay=0,notechain={}}function B.createnote(C)if C then local D={ms=nil,data=nil,type=C,txt=nil,gogo=B.gogo,scroll=(B.scroll*o.Metadata.HEADSCROLL),mspermeasure=B.mspermeasure,bpm=B.bpm,nextnote=nil,radius=1,requiredhits=nil,length=nil,endnote=nil,section=nil,text=nil,delay=B.delay,onnotepush=nil}D.type=C;if C==3 or C==4 or C==6 then D.radius=D.radius*1.6 end;if C==5 or C==6 or C==7 or C==9 then if B.lastlong then if C==9 then else ParseError('parser.noteparse','Last long note has not ended')end else B.lastlong=D;if C==7 or C==9 then D.requiredhits=r('parser.noteparse',o.Metadata.BALLOON[B.balloonn],'Invalid number of balloons',B.balloonn)B.balloonn=B.balloonn+1 end end end;if C==8 then local E=B.lastlong;B.lastlong=nil;D.startnote=E;if E then D.onnotepush=function()E.length=D.ms-E.ms;E.endnote=D end else end end;if B.section then D.section=true;B.section=false end;return D else return{ms=nil,data=nil,type=nil,txt=nil,gogo=B.gogo,scroll=(B.scroll*o.Metadata.HEADSCROLL),mspermeasure=B.mspermeasure,bpm=B.bpm,nextnote=nil,delay=B.delay}end end;function B.endbranch()local C=B.createnote()C.data='event'C.event='branch'C.branch={requirements=B.branch.requirements,paths=B.branch.paths}B.branch.on=false;B.branch.requirements={}B.branch.paths={}table.insert(o.Data,C)B.measurepushto=o.Data end;return B end;y=z()local A=Split(l,'\n')for i=1,#A do LineN=i;local B=Trim(A[i])if StartsWith(B,'//')or B==''then else local C=string.find(B,'//')if C then B=string.sub(B,1,C-1)end;local D=false;if y.songstarted==false and D==false then local E={string.match(B,'(%u+):(.*)')}if E[1]then local F=Trim(E[2])if F~=''then o.Metadata[Trim(E[1])]=F end;D=true end end;if(y.songstarted or StartsWith(B,'#START')or StartsWith(B,'#BMSCROLL')or StartsWith(B,'#HBSCROLL'))and D==false then local E={string.match(B,'#(%u-)%s(.*)')}if not E[1]then E={string.match(B,'#(%u+)')}end;if E[1]then if E[1]=='START'then if y.songstarted then ParseError(E[1],'Song has already started')else o.OriginalMetadata=Table.Clone(o.Metadata)if E[2]then o.Metadata.MODE=r(E[1],Taiko.Data.ModeId[E[2]],'Invalid mode',E[2])else o.Metadata.MODE=0 end;o.Metadata.TITLE=r(E[1],p('TITLE'),'Title is missing')o.Metadata.SUBTITLE=r(E[1],p('SUBTITLE'),'Subtitle is missing')o.Metadata.BPM=q(E[1],o.Metadata.BPM,'Invalid bpm')o.Metadata.OFFSET=SToMs(q(E[1],o.Metadata.OFFSET,'Invalid offset'))o.Metadata.DEMOSTART=SToMs(q(E[1],o.Metadata.DEMOSTART,'Invalid demostart'))if o.Metadata.DEMOSTART==0 then o.Metadata.DEMOSTART=nil end;for I,J in pairs(Taiko.Data.GenreName)do for i=1,#J do if J[i]==o.Metadata.GENRE then o.Metadata.GENRE=I end end end;o.Metadata.SCOREMODE=q(E[1],o.Metadata.SCOREMODE,'Invalid scoremode')r(E[1],Taiko.Data.ScoreMode[o.Metadata.SCOREMODE],'Invalid scoremode',o.Metadata.SCOREMODE)if o.Metadata.MAKER then o.Metadata.CREATORURLT={}o.Metadata.CREATOR=Trim(string.gsub(o.Metadata.MAKER,'(<.->)',function(I)table.insert(o.Metadata.CREATORURLT,string.sub(I,2,-2))return''end))o.Metadata.CREATORURL=table.concat(o.Metadata.CREATORURLT,', ')o.Metadata.CREATIVE=false else o.Metadata.CREATIVE=false end;o.Metadata.SONGVOL=q(E[1],o.Metadata.SONGVOL,'Invalid songvol')/100;o.Metadata.SEVOL=q(E[1],o.Metadata.SEVOL,'Invalid sevol')/100;local F=tonumber(o.Metadata.SIDE)if F then r(E[1],Taiko.Data.SideName[F],'Invalid side id',o.Metadata.SIDE)o.Metadata.SIDE=F else o.Metadata.SIDE=r(E[1],Taiko.Data.SideId[string.lower(o.Metadata.SIDE)],'Invalid side name',o.Metadata.SIDE)end;o.Metadata.LIFE=q(E[1],o.Metadata.LIFE,'Invalid life')if o.Metadata.LIFE==0 then o.Metadata.LIFE=nil end;o.Metadata.GAME=string.lower(o.Metadata.GAME)if o.Metadata.GAME=='taiko'then elseif o.Metadata.GAME=='jube'then else end;o.Metadata.HEADSCROLL=q(E[1],o.Metadata.HEADSCROLL,'Invalid headscroll')o.Metadata.MOVIEOFFSET=q(E[1],o.Metadata.MOVIEOFFSET,'Invalid movieoffset')local G=tonumber(o.Metadata.COURSE)if G then r(E[1],Taiko.Data.CourseName[G],'Invalid course id',o.Metadata.COURSE)o.Metadata.COURSE=G else o.Metadata.COURSE=r(E[1],Taiko.Data.CourseId[string.lower(o.Metadata.COURSE)],'Invalid course name',o.Metadata.COURSE)end;o.Metadata.TIMING=Taiko.Data.Timing.GetFunction(o.Metadata.COURSE)o.Metadata.LEVEL=ClipN(math.floor(q(E[1],o.Metadata.LEVEL,'Invalid level')),0,10)o.Metadata.BALLOON=w(E[1],o.Metadata.BALLOON,'Invalid balloon')o.Metadata.SCOREINIT=q(E[1],o.Metadata.SCOREINIT,'Invalid scoreinit')o.Metadata.SCOREDIFF=q(E[1],o.Metadata.SCOREDIFF,'Invalid scoreinit')o.Metadata.BALLOONNOR=w(E[1],o.Metadata.BALLOONNOR,'Invalid balloonnor')o.Metadata.BALLOONEXP=w(E[1],o.Metadata.BALLOONEXP,'Invalid balloonexp')o.Metadata.BALLOONMAS=w(E[1],o.Metadata.BALLOONMAS,'Invalid balloonmas')local H=tonumber(o.Metadata.STYLE)if H then r(E[1],Taiko.Data.StyleName[H],'Invalid style id',Taiko.Data.STYLE)o.Metadata.STYLE=H else o.Metadata.STYLE=r(E[1],Taiko.Data.StyleId[string.lower(o.Metadata.STYLE)],'Invalid style name',o.Metadata.STYLE)end;o.Metadata.EXAM1=x(o.Metadata.EXAM1)o.Metadata.EXAM2=x(o.Metadata.EXAM2)o.Metadata.EXAM3=x(o.Metadata.EXAM3)o.Metadata.GAUGEINCR=string.lower(o.Metadata.GAUGEINCR)if o.Metadata.TOTAL then o.Metadata.TOTAL=q(E[1],o.Metadata.TOTAL,'Invalid total')end;o.Metadata.HIDDENBRANCH=s(E[1],o.Metadata.HIDDENBRANCH,'Invalid hiddenbranch')y.bpm=o.Metadata.BPM;y.songstarted=true end elseif E[1]=='END'then if y.songstarted then if#y.currentmeasure~=0 then ParseError(E[1],'Current measure is not empty')end;table.insert(n,o)o={Metadata=Table.Clone(o.OriginalMetadata),Data={}}y=z()y.songstarted=false;y.measurepushto=o.Data else ParseError(E[1],'Song has already ended')end elseif E[1]=='MEASURE'then local F,G=string.match(E[2],'(%d+)/(%d+)')F=q(E[1],F,'Invalid measure')G=q(E[1],G,'Invalid measure')y.sign=(F/G)or y.sign elseif E[1]=='BPMCHANGE'then y.bpm=q(E[1],E[2],'Invalid bpmchange')or y.bpm elseif E[1]=='DELAY'then local F=SToMs((q(E[1],E[2],'Invalid delay')or 0))if y.stopsong then y.delay=y.delay+F end;table.insert(y.currentmeasure,{'DELAY',F})elseif E[1]=='SCROLL'then if y.disablescroll then else y.scroll=q(E[1],E[2],'Invalid scroll')or y.scroll;if y.scroll==0 then ParseError(E[1],'Scroll cannot be 0')end end elseif E[1]=='GOGOSTART'then y.gogo=true elseif E[1]=='GOGOEND'then y.gogo=false elseif E[1]=='BARLINEOFF'then y.barline=false elseif E[1]=='BARLINEON'then y.barline=true elseif E[1]=='BRANCHSTART'then if y.branch.on then y.endbranch()end;y.msbeforebranch=y.ms;y.branch.on=true;o.Metadata.DIVERGENOTES=true;local F=u(E[1],E[2])local G=r(E[1],Taiko.Data.Branch.Requirements[string.lower(F[1])],'Invalid type',F[1])y.branch.requirements={G}local H=2;while true do if not F[H]then break end;local I=Taiko.Data.Branch.PathName[H-1]if I then y.branch.requirements[I]=F[H]else break end;H=H+1 end elseif Taiko.Data.Branch.PathId[E[1]]then if y.branch.on then y.ms=y.msbeforebranch;y.currentbranch=E[1]y.branch.paths[E[1]]={}y.measurepushto=y.branch.paths[E[1]]else ParseError(E[1],'Branch has not started')end elseif E[1]=='BRANCHEND'then if y.branch.on then y.endbranch()else ParseError(E[1],'Branch has already ended')end elseif E[1]=='SECTION'then y.section=true elseif E[1]=='LYRIC'then elseif E[1]=='LEVELHOLD'then elseif E[1]=='BMSCROLL'then y.disablescroll=true;y.stopsong=true elseif E[1]=='HBSCROLL'then y.stopsong=true elseif E[1]=='SENOTECHANGE'then elseif E[1]=='NEXTSONG'then elseif E[1]=='DIRECTION'then elseif E[1]=='SUDDEN'then elseif E[1]=='JPOSSCROLL'then else end;D=true end end;if(y.songstarted)and D==false then y.mpm=y.bpm*y.sign/4;y.mspermeasure=60000 *y.sign*4 /y.bpm;if y.barline and#y.currentmeasure==0 then local E=y.createnote()E.ms=y.ms;E.data='event'E.event='barline'table.insert(y.measurepushto,E)end;for i=1,#B do local E=string.sub(B,i,i)if y.settings.noteparse.noteexceptions[E]then else local F=q('parser.noteparse',tonumber(E)or y.settings.noteparse.notealias[E]or E,'Invalid note')if F then local G=y.createnote(F)G.data='note'table.insert(y.currentmeasure,G)end end end;if EndsWith(TrimRight(B),',')then y.mpm=y.bpm*y.sign/4;y.mspermeasure=60000 *y.sign*4 /y.bpm;if#y.currentmeasure==0 then y.ms=y.ms+y.mspermeasure else local E=0;local F=nil;for i=1,#y.currentmeasure do local H=y.currentmeasure[i]if H.data=='note'then F=F or H.mspermeasure;E=E+1 end end;F=F or y.mspermeasure;local G=F/E;for i=1,#y.currentmeasure do local H=y.currentmeasure[i]if H[1]=='DELAY'then y.ms=y.ms+H[2]else if H.type~=0 then H.ms=y.ms;local I=o.Data[#o.Data]if I then I.nextnote=H end;table.insert(y.measurepushto,H)if H.onnotepush then H.onnotepush()end;G=H.mspermeasure/E end;y.ms=y.ms+G end end end;y.measuredone=true;y.currentmeasure={}else y.measuredone=false end end end end;print('Parsing Took: '..SToMs(os.clock()-m)..'ms')return n end;function Taiko.SerializeTJA(l)local function m(x)return math.floor(x+0.5)end;local n=5;local o=10 ^n;local function p(x)return math.floor(x*o+0.5)/o end;local function q(x,y)if x<y then return q(y,x)end;if math.abs(y)<0.001 then return x else return q(y,x-math.floor(x/y)*y)end end;local function r(x)local y=q(x,1)return m(x/y),m(1 /y)end;local function s(x)local y,z=string.match(x,'(%d+)/(%d+)')return y,z end;local function u(x)for i=1,#x do x[i]=tostring(x[i])end;return table.concat(x,',')end;local function v(x)local y={}local z={OFFSET=true,DEMOSTART=true}for H,I in pairs(x.Metadata)do local J;if type(I)=='number'then if z[H]then J=tostring(MsToS(tonumber(I)))else J=tostring(I)end elseif type(I)=='table'then J=u(I)elseif type(I)=='string'then J=tostring(I)else J=nil end;if J then y[#y+1]=H;y[#y+1]=':'y[#y+1]=J;y[#y+1]='\n'end end;y[#y+1]='\n\n'local A=false;local B=false;local C=x.Metadata.HEADSCROLL;for i=1,#x.Data do local H=x.Data[i]if H.data=='event'and H.event=='barline'then A=true end;if H.delay and H.delay~=0 then B=true end;if H.scroll and H.scroll~=C then C=false end end;if B then if C then y[#y+1]='#BMSCROLL\n'else y[#y+1]='#HBSCROLL\n'end end;y[#y+1]='#START\n'if A then y[#y+1]='#BARLINEON\n'else y[#y+1]='#BARLINEOFF\n'end;local D={startms=nil,barline=nil}local E=nil;local F=0;local G={scroll={'#SCROLL',nil,function(H)return H/x.Metadata.HEADSCROLL end},bpm={'#BPMCHANGE',x.Metadata.BPM},measure={'#MEASURE',nil,function(H,I)local J,K=r(I.bpm*I.mspermeasure/240000)return J..'/'..K end,true}}for i=1,#x.Data do local H=x.Data[i]local I=H.ms;if H.data=='note'then D[#D+1]=H elseif H.data=='event'and H.event=='barline'then D.startms=H.ms;D.barline=H end;local J=x.Data[i+1]if(J and J.data=='event'and J.event=='barline')or(i==#x.Data)then local K=D.barline;for L,M in pairs(G)do if not M[4]and K[L]==M[2]then else local N=K[L]if M[3]then N=M[3](N,K)end;if M[4]and M[2]==N then else M[2]=N;if y[#y]~='\n'then y[#y+1]='\n'end;y[#y+1]=M[1]y[#y+1]=' 'y[#y+1]=N;y[#y+1]='\n'end end end;if#D==0 then y[#y+1]=','y[#y+1]='\n'else local L={}for i=2,#D do local Q=D[i-1]local R=D[i]L[#L+1]=(R.ms-R.delay)- (Q.ms-Q.delay)end;L[#L+1]=(D[1].ms-D[1].delay)-D.startms;L[#L+1]=(D.startms+D[1].mspermeasure)- (D[#D].ms-D[#D].delay)local M=L[1]for i=2,#L do M=q(M,L[i])end;if M==nil then error('gcd invalid, probably delay')M=D[1]and(D[1].ms-F)end;local N=D.startms;local O=N+D[1].mspermeasure;local P=D[1].ms-N;if P>0 then y[#y+1]=string.rep('0',P/M)end;for i2=1,#D do local Q=D[i2]for R,S in pairs(G)do if not S[4]and Q[R]==S[2]then else local T=Q[R]if S[3]then T=S[3](T,Q)end;if S[4]and S[2]==T then else S[2]=T;if y[#y]~='\n'then y[#y+1]='\n'end;y[#y+1]=S[1]y[#y+1]=' 'y[#y+1]=T;y[#y+1]='\n'end end end;y[#y+1]=tostring(Q.type)y[#y+1]=string.rep('0',( (D[i2 +1]and D[i2 +1].ms or O)-Q.ms)/M-1)end;y[#y+1]=','y[#y+1]='\n'D={}end end end;if y[#y]~='\n'then y[#y+1]='\n'end;y[#y+1]='\n#END'return table.concat(y)end;a=v(l[4])print(a)error()local w={'// Automatically Serialized by Taiko.SerializeTJA'}for x,y in pairs(l)do w[#w+1]=v(y)end;w=table.concat(w,'\n\n')return w end;print(Taiko.SerializeTJA(Taiko.ParseTJA(io.open('./tja/SerializeTest.tja','r'):read'*all')))error()function Taiko.Score(l,m,n,o,p)if o==0 then n=0 else n=n+1 end;local q=l.Metadata;return Taiko.Data.ScoreMode[q.SCOREMODE](m,n,q.SCOREINIT,q.SCOREDIFF,o,p),n end;function Taiko.Analyze(l)local m='M'local n={[1]=2,[2]=2,[3]=3,[4]=3}local o={notes={n=0,validn=0},measures=0,lengthms=0,drumrollms=0,drumrollbigms=0,balloonms=0,balloonhit=0,specialms=0,specialhit=0,maxcombo=0,maxscore=0}local p=nil;Taiko.ForAll(l.Data,function(q,r,s)if q.data=='note'then o.notes.n=o.notes.n+1;o.notes[q.type]=o.notes[q.type]and o.notes[q.type]+1 or 1;if n[q.type]then o.maxscore,o.maxcombo=Taiko.Score(l,o.maxscore,o.maxcombo,n[q.type],q.gogo)end;local u=q.endnote;if u then local v=u.ms-q.ms;if q.type==5 then o.drumrollms=o.drumrollms+v elseif q.type==6 then o.drumrollbigms=o.drumrollbigms+v elseif q.type==7 then o.balloonms=o.balloonms+v;o.balloonhit=o.balloonhit+q.requiredhits elseif q.type==9 then o.specialms=o.specialms+v;o.specialhit=o.specialhit+q.requiredhits else end end;p=q elseif q.data=='event'and q.event=='barline'then o.measures=o.measures+1 else end end,m)o.lengthms=p.ms-l.Metadata.OFFSET;o.notes.validn=o.maxcombo;return o end;function Taiko.GetDifficulty(l,m)local n=Taiko.Data.CourseId[string.lower(m)]or m;for o,p in pairs(l)do if p.Metadata.COURSE==n then return p end end;Error('No difficulty found, '..m)return nil end;function Taiko.ForAll(l,m,n)local o=1;for i=1,#l do local p=l[i]if p.branch then if n then local q=p.branch.paths[n]for i2=1,#q do m(q[i2],i2,o)o=o+1 end;o=o-1 else local q=-1;for r,s in pairs(p.branch.paths)do local u=o;for i2=1,#s do m(s[i2],i2,u)u=u+1 end;q=(q<u)and u or q end;o=q end else m(p,i,o)end;o=o+1 end;return l end;function Taiko.GetAllNotes(l)local m={}for n,o in pairs(l)do if o.branch then for p,q in pairs(o.branch.paths)do for i=1,#q do table.insert(m,q[i])end end else table.insert(m,o)end end;return m end;function Taiko.ConnectNotes(l)local m=nil;for i=#l,1,-1 do local o=l[i]o.nextnote=m;m=o end;return l end;function Taiko.ExtractBranch(l,m)return l.branch.paths[m]end;function Taiko.ConnectAll(l)local m=nil;for i=#l,1,-1 do local n=l[i]if n.branch then for o,p in pairs(n.branch.paths)do local q=Taiko.ConnectNotes(p)q[#q].nextnote=m end else n.nextnote=m end;m=n end end;function Taiko.CalculateSpeed(l,m)local n=(m*l.scroll*l.bpm/7500)return n end;function Taiko.CalculateSpeedAll(l,m)for i=1,#l do l[i].speed=Taiko.CalculateSpeed(l[i],m)end;return l end;function Taiko.RenderScale(l)local m={}local n={}local o={}for i=1,#l.Data do local s=l.Data[i]if s.data=='note'then local u=math.floor(s.ms)if math.floor(u)-u==0 then table.insert(m,{u,s.type})table.insert(n,u)else table.insert(o,i)end end end;function gcd2(s,u)if u==0 then return s else return gcd2(u,s%u)end end;function gcdn(s)local u=s[1]for i=2,#s do u=gcd2(u,s[i])end;return u end;local p=gcdn(n)for i=1,#o do local s=m[o[i]]s[1]=math.floor(s[1]/p)*p end;local q=''local r=0;for i=1,#m do m[i][1]=m[i][1]/p;q=q..string.rep(' ',m[i][1]-r)..m[i][2]r=m[i][1]end;return q end;function Taiko.PlaySong(l,m,n,o)local p={on=false,fps=60,frames={}}local q=nil;local r={auto={[1]=false,[2]=true},notespeedmul={[1]=1,[2]=2,[3]=3,[4]=4,[5]=0.25,[6]=0.5,[7]=0.75},songspeedmul={[1]=1,[2]=2,[3]=3,[4]=4,[5]=0.25,[6]=0.5,[7]=0.75}}local s=r.auto[n[2]]or false;local u=false;local v=r.notespeedmul[n[3]]or 1;local w=r.songspeedmul[n[4]]or 1;local x=true;local z=o or{}z={Hit=z.Hit or{['4']=2,['v']=1,['n']=1,['8']=2},Escape=z.Escape or{['\27']=true,ALT_ESC=true},L=z.L or{KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_A2=true},R=z.R or{KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true},Select=z.Select or{KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}}local A=1;local B=2;local C='>'local D='\n\n\n'local E=10;local F=10;local G=1000;local H=4;local I=0;local J=10;local K=0;local L=40;local M=3;local N=1;local O={[1]={color='red'},[2]={color='blue'},[3]={color='red'},[4]={color='blue'},[5]={color='yellow'},[6]={color='yellow'}}local P=200;local Q=P/4;local R=4;local S=20;L=math.floor(L*H)local T=K+L;M=math.floor(M*H)local U=require('taikocurses')local V=m or{window=U.initscr()}U.keypad(V,true)U.echo(false)U.raw(true)U.nl(false)U.cbreak(true)U.nodelay(V,true)local W={[0]={Data={[1]={'0','1','1','1','1','1','1','1'},[2]={[2]='1',[5]='1',[8]='1'},[3]={[2]='1',[5]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={[3]='1',[4]='1',[6]='1',[7]='1'},[8]={'0','0','1','1','1','1','1','1'},[9]={[2]='1',[5]='1'},[10]={[2]='1',[5]='1'},[11]={[2]='1',[5]='1'},[12]={[2]='1',[5]='1'},[13]={'0','0','1','1','1','1','1','1'},[15]={'0','1','1','1','1','1','1','1'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'}},Color={All='blue'},Offset={-1,0}},[1]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[8]='1'},[5]={[2]='1',[8]='1'},[6]={'0','0','1','1','1','1','1','0'},[8]={'0','1','1','1','1','1','1','1'},[9]={[5]='1'},[10]={[4]='1',[6]='1'},[11]={[3]='1',[7]='1'},[12]={[2]='1',[8]='1'}},Color={All='white'},Offset={-1,0}},[2]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={'0','1','0','0','1','1','1','1'},[8]={'0','0','1','1','1','1','1','0'},[9]={[2]='1',[8]='1'},[10]={[2]='1',[8]='1'},[11]={[2]='1',[8]='1'},[12]={[2]='1',[8]='1'},[13]={'0','0','1','1','1','1','1','0'},[15]={'0','0','1','1','1','1','1','0'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'},[22]={'0','1','1','1','1','1','1','1'},[23]={[2]='1',[8]='1'},[24]={[2]='1',[8]='1'},[25]={[2]='1',[8]='1'},[26]={[2]='1',[8]='1'},[27]={'0','0','1','1','1','1','1','0'}},Color={All='yellow'},Offset={-1,0}},Size={27,8}}W[3]=W[2]local X={[0]=nil,[1]={},[2]={}}local Y;if g then Y=g else os.execute('chcp 65001')Y={}local Wb=([[
⠀ ⢀ ⠠ ⢠ ⠐ ⢐ ⠰ ⢰ ⠈ ⢈ ⠨ ⢨ ⠘ ⢘ ⠸ ⢸
⡀ ⣀ ⡠ ⣠ ⡐ ⣐ ⡰ ⣰ ⡈ ⣈ ⡨ ⣨ ⡘ ⣘ ⡸ ⣸
⠄ ⢄ ⠤ ⢤ ⠔ ⢔ ⠴ ⢴ ⠌ ⢌ ⠬ ⢬ ⠜ ⢜ ⠼ ⢼
⡄ ⣄ ⡤ ⣤ ⡔ ⣔ ⡴ ⣴ ⡌ ⣌ ⡬ ⣬ ⡜ ⣜ ⡼ ⣼
⠂ ⢂ ⠢ ⢢ ⠒ ⢒ ⠲ ⢲ ⠊ ⢊ ⠪ ⢪ ⠚ ⢚ ⠺ ⢺
⡂ ⣂ ⡢ ⣢ ⡒ ⣒ ⡲ ⣲ ⡊ ⣊ ⡪ ⣪ ⡚ ⣚ ⡺ ⣺
⠆ ⢆ ⠦ ⢦ ⠖ ⢖ ⠶ ⢶ ⠎ ⢎ ⠮ ⢮ ⠞ ⢞ ⠾ ⢾
⡆ ⣆ ⡦ ⣦ ⡖ ⣖ ⡶ ⣶ ⡎ ⣎ ⡮ ⣮ ⡞ ⣞ ⡾ ⣾
⠁ ⢁ ⠡ ⢡ ⠑ ⢑ ⠱ ⢱ ⠉ ⢉ ⠩ ⢩ ⠙ ⢙ ⠹ ⢹
⡁ ⣁ ⡡ ⣡ ⡑ ⣑ ⡱ ⣱ ⡉ ⣉ ⡩ ⣩ ⡙ ⣙ ⡹ ⣹
⠅ ⢅ ⠥ ⢥ ⠕ ⢕ ⠵ ⢵ ⠍ ⢍ ⠭ ⢭ ⠝ ⢝ ⠽ ⢽
⡅ ⣅ ⡥ ⣥ ⡕ ⣕ ⡵ ⣵ ⡍ ⣍ ⡭ ⣭ ⡝ ⣝ ⡽ ⣽
⠃ ⢃ ⠣ ⢣ ⠓ ⢓ ⠳ ⢳ ⠋ ⢋ ⠫ ⢫ ⠛ ⢛ ⠻ ⢻
⡃ ⣃ ⡣ ⣣ ⡓ ⣓ ⡳ ⣳ ⡋ ⣋ ⡫ ⣫ ⡛ ⣛ ⡻ ⣻
⠇ ⢇ ⠧ ⢧ ⠗ ⢗ ⠷ ⢷ ⠏ ⢏ ⠯ ⢯ ⠟ ⢟ ⠿ ⢿
⡇ ⣇ ⡧ ⣧ ⡗ ⣗ ⡷ ⣷ ⡏ ⣏ ⡯ ⣯ ⡟ ⣟ ⡿ ⣿]]):gsub('\n',' ')function GenerateDotData()function ToBinary(ic)local jc={}while ic>0 do local lc=math.fmod(ic,2)jc[#jc+1]=string.sub(lc,1,1)ic=(ic-lc)/2 end;local kc=string.reverse(table.concat(jc))return string.rep('0',8 -#kc)..kc end;local function cc(ic)return ic end;local dc=Split(Wb,' ')local ec={}local fc=false;local gc=''local hc=' 'for i=1,#dc do ec[i-1]=cc(dc[i])end;return ec end;Y.Data={}Y.Data.Dot=GenerateDotData()Y.ColorData={reset=0,clear=0,space=0,bright=1,bold=1,dim=2,faint=1,italic=3,underline=4,blink=5,reverse=7,invisible=8,hidden=8,strikethrough=9,black=30,red=31,green=32,yellow=33,blue=34,purple=35,magenta=35,cyan=36,white=37,onblack=40,onred=41,ongreen=42,onyellow=43,onblue=44,onpurple=45,onmagenta=45,oncyan=46,onwhite=47}Y.Color={}for cc,dc in pairs(Y.ColorData)do Y.Color[cc]='\27['..dc..'m'end;local Xb,Yb=K,L;local Zb,ac=-J,J;Zb,ac=-20,20;Y.Convert={}Y.Convert.ToDots=function(cc,dc)dc=dc or 0;local ec,fc=Xb+dc,Yb+dc;local gc,hc=cc.Data,cc.Color;local ic={}local jc=0;local kc=Y.Data.Dot[jc]local lc=nil;local mc=nil;local nc=Y.Color['reset']if cc.Color.All then local oc=Y.Color[cc.Color.All]ic[#ic+1]=oc;mc=oc end;if not Zb then return''end;for y=Zb,ac,4 do for x=ec,fc,2 do local oc=gc[x]local pc=gc[x+1]local qc=(oc and( (oc[y]or 0)*128 + (oc[y+1]or 0)*64 + (oc[y+2]or 0)*32 + (oc[y+3]or 0)*16)or 0)+ (pc and( (pc[y]or 0)*8 + (pc[y+1]or 0)*4 + (pc[y+2]or 0)*2 + (pc[y+3]or 0))or 0)if qc~=jc then qc=Y.Data.Dot[qc]if not mc then local rc=hc[x]local sc=hc[x+1]local tc=( (rc)and(rc[y]or rc[y+1]or rc[y+2]or rc[y+3]))or( (sc)and(sc[y]or sc[y+1]or sc[y+2]or sc[y+3]))if tc then tc=Y.Color[tc]else tc=nc end;if lc==tc then else ic[#ic+1]=tc;lc=tc end end;ic[#ic+1]=qc else ic[#ic+1]=kc end end;ic[#ic+1]='\n'end;ic[#ic+1]=nc;return table.concat(ic)end;Y.ToDotsParallel=function(cc,dc,ec)ec=ec or 0;local fc,gc=Xb+ec,Yb+ec;local hc,ic=cc.Data,cc.Color;local jc,kc=dc.Data,dc.Color;local lc={}local mc=0;local nc=Y.Data.Dot[mc]local oc=nil;local pc=nil;local qc=Y.Color['reset']if cc.Color.All then local rc=Y.Color[cc.Color.All]lc[#lc+1]=rc;pc=rc end;if not Zb then return''end;for y=Zb,ac,4 do for x=fc,gc,2 do local rc=hc[x]local sc=hc[x+1]local tc=jc[x]local uc=jc[x+1]local vc=( (rc and tc)and( (rc[y]or tc[y]or 0)*128 + (rc[y+1]or tc[y+1]or 0)*64 + (rc[y+2]or tc[y+2]or 0)*32 + (rc[y+3]or tc[y+3]or 0)*16)or(rc)and( (rc[y]or 0)*128 + (rc[y+1]or 0)*64 + (rc[y+2]or 0)*32 + (rc[y+3]or 0)*16)or(tc)and( (tc[y]or 0)*128 + (tc[y+1]or 0)*64 + (tc[y+2]or 0)*32 + (tc[y+3]or 0)*16)or 0)+ ( (sc and uc)and( (sc[y]or uc[y]or 0)*8 + (sc[y+1]or uc[y+1]or 0)*4 + (sc[y+2]or uc[y+2]or 0)*2 + (sc[y+3]or uc[y+3]or 0))or(sc)and( (sc[y]or 0)*8 + (sc[y+1]or 0)*4 + (sc[y+2]or 0)*2 + (sc[y+3]or 0))or(uc)and( (uc[y]or 0)*8 + (uc[y+1]or 0)*4 + (uc[y+2]or 0)*2 + (uc[y+3]or 0))or 0)if vc~=mc then vc=Y.Data.Dot[vc]if not pc then local wc=kc[x]local xc=kc[x+1]local yc=ic[x]local zc=ic[x+1]local Ac=yc and(yc[y]or yc[y+1]or yc[y+2]or yc[y+3])or zc and(zc[y]or zc[y+1]or zc[y+2]or zc[y+3])or wc and(wc[y]or wc[y+1]or wc[y+2]or wc[y+3])or xc and(xc[y]or xc[y+1]or xc[y+2]or xc[y+3])if Ac then Ac=Y.Color[Ac]else Ac=qc end;if oc==Ac then else lc[#lc+1]=Ac;oc=Ac end end;lc[#lc+1]=vc else lc[#lc+1]=nc end end;lc[#lc+1]='\n'end;lc[#lc+1]=qc;return table.concat(lc)end;Y.CircleGen=function(cc,dc,ec,fc,gc)gc=gc or{}local hc=gc.color;local ic=fc*fc;local jc=fc;for y=0,fc do jc=jc+1;repeat jc=jc-1 until jc*jc+y*y<=ic;for x2=0,jc do cc.Data[dc+x2]=cc.Data[dc+x2]or{}cc.Data[dc-x2]=cc.Data[dc-x2]or{}cc.Data[dc+x2][ec+y]='1'cc.Data[dc-x2][ec+y]='1'cc.Data[dc+x2][ec-y]='1'cc.Data[dc-x2][ec-y]='1'cc.Color[dc+x2]=cc.Color[dc+x2]or{}cc.Color[dc-x2]=cc.Color[dc-x2]or{}cc.Color[dc+x2][ec+y]=hc;cc.Color[dc-x2][ec+y]=hc;cc.Color[dc+x2][ec-y]=hc;cc.Color[dc-x2][ec-y]=hc end end;return cc end;local bc={}Y.Circle=function(cc,dc,ec,fc,gc)local hc=nil;if bc[fc]then else bc[fc]=Y.CircleGen(Y.New(),0,0,fc)end;local ic=gc and gc.color;hc=bc[fc]for jc,kc in pairs(hc.Data)do for lc,mc in pairs(kc)do local nc,oc=jc+dc,lc+ec;cc.Data[nc]=cc.Data[nc]or{}cc.Data[nc][oc]=mc;cc.Color[nc]=cc.Color[nc]or{}cc.Color[nc][oc]=ic end end;return cc end;Y.New=function()return{Data={},Color={}}end;g=Y end;local function Z(Wb,Xb)local Yb=math.floor(Xb.p)local Zb,ac=I-J,I+J;for y=Zb,ac do local bc=Wb.Data[Yb]and Wb.Data[Yb][y]if bc=='0'or bc==nil then Wb.Data[Yb]=Wb.Data[Yb]or{}Wb.Data[Yb][y]='1'end end end;local function ab(Wb,Xb,Yb)Yb=Yb or Xb.p;Y.Circle(Wb,math.floor(Yb),I,H*Xb.radius,O[Xb.type])end;local function bb(Wb,Xb,Yb,Zb,ac,bc)local cc=bc or{}color=cc.color;for y=Zb,ac do for x=Xb,Yb do Wb.Data[x]=Wb.Data[x]or{}Wb.Data[x][y]='1'if color then Wb.Color[x]=Wb.Color[x]or{}Wb.Color[x][y]=color end end end end;local cb=(K-E)local db=(L+E)local function eb(Wb,Xb,Yb)local Zb=Xb.type;if Zb==1 or Zb==2 or Zb==3 or Zb==4 then ab(Wb,Xb)elseif Zb==5 or Zb==6 then ab(Wb,Xb)local ac=Xb.endnote;local bc=(ac.ms-Xb.ms)*Xb.speed;local cc=H*Xb.radius;local dc,ec=math.floor(Xb.p),math.floor(Xb.p+bc)local fc=math.floor(I-cc)local gc=math.floor(I+cc)ab(Wb,ac,ec)if Yb then else if dc>ec then dc,ec=ec,dc end;if dc<cb then dc=cb end;if ec>db then ec=db end end;bb(Wb,dc,ec,fc,gc,O[Xb.type])elseif Zb==8 then end end;local function fb(Wb,Xb,Yb,Zb)local ac=R/ (Q/2)local bc=-ac*math.abs(( (Yb-Xb.startms)/ (P/Q))- (R/ac))+R;local cc=W[Xb.status]local dc=cc.Offset;local ec=cc.Color.All;local fc,gc=0,-math.floor(H*1.6)-8 -math.floor(bc)local hc,ic=dc[1]+fc+Zb,dc[2]+gc;for x=1,W.Size[1]do for y=1,W.Size[2]do local jc,kc=x+hc,y+ic;Wb.Data[jc]=Wb.Data[jc]or{}Wb.Data[jc][kc]=cc.Data[x]and cc.Data[x][y]Wb.Color[jc]=Wb.Color[jc]or{}Wb.Color[jc][kc]=ec end end end;local function gb(Wb,Xb)local Yb=X[Xb.status]local Zb=Yb.Offset;local ac=Yb.Color.All;local bc,cc=0,0;for dc,ec in pairs(Yb.Data)do for fc,gc in pairs(ec)do if gc=='1'then local hc,ic=dc+Zb[1]+bc,fc+Zb[2]+cc;Wb.Data[hc]=Wb.Data[hc]or{}Wb.Data[hc][ic]=gc;Wb.Color[hc]=Wb.Color[hc]or{}Wb.Color[hc][ic]=ac end end end end;local hb={ClearScreen=function()io.write("\27[2J")end,SetCursor=function(Wb,Xb)io.write(string.format("\27[%d;%dH",Xb,Wb))end}local ib=Taiko.GetAllNotes(l.Data)local jb=l.Metadata.OFFSET;local kb=1000 /60;local lb=l.Metadata.TIMING(kb)local function mb(Wb)return(Wb.data=='note')or(Wb.data=='event'and Wb.event=='barline')end;local function nb(Wb,Xb)return Xb- (( (L+E)/math.abs(Wb.speed)))end;local function ob(Wb,Xb)return(Wb.ms-Xb)*Wb.speed+M end;local function pb(Wb,Xb,Yb)return Wb.loadp- (Wb.speed* (Xb-Wb.loadms))end;local qb={}for Wb,Xb in pairs(ib)do Xb.ms=Xb.oms or Xb.ms;Xb.oms=Xb.ms;Xb.ms=(Xb.ms-jb)/w;Xb.s=MsToS(Xb.ms)Xb.delay=Xb.odelay or Xb.delay;Xb.odelay=Xb.delay;Xb.delay=Xb.delay/w;Xb.speed=(Taiko.CalculateSpeed(Xb,H))*v;Xb.loadms=nb(Xb,Xb.ms)Xb.loads=MsToS(Xb.loadms)Xb.loadp=ob(Xb,Xb.loadms)Xb.hit=nil;qb[#qb+1]=Xb.ms end;if x then for Yb,Zb in pairs(l.Data)do if Zb.branch then for ac,bc in pairs(Zb.branch.paths)do table.sort(bc,function(cc,dc)return cc.ms<dc.ms end)end end end;table.sort(l.Data,function(Yb,Zb)if Yb.branch and Zb.branch then for ac,bc in pairs(Yb.branch.paths)do for cc,dc in pairs(Zb.branch.paths)do return bc[1].ms<dc[1].ms end end elseif Yb.branch then for ac,bc in pairs(Yb.branch.paths)do return bc[1].ms<Zb.ms end elseif Zb.branch then for ac,bc in pairs(Zb.branch.paths)do return Yb.ms<bc[1].ms end else return Yb.ms<Zb.ms end end)local Wb;local Xb=true;Taiko.ForAll(l.Data,function(Yb,Zb,ac)if Yb.delay~=0 then Yb.ms=Yb.ms-Yb.delay;Yb.s=MsToS(Yb.ms)Yb.loadms=nb(Yb,Yb.ms)Yb.loads=MsToS(Yb.loadms)Yb.loadp=ob(Yb,Yb.loadms)Yb.ms=Yb.ms+Yb.delay;Yb.s=MsToS(Yb.ms)if Xb then Wb.stopms=Yb.delay-Wb.delay;Wb.stopstart=Wb.ms;Wb.stopend=Wb.stopstart+Wb.stopms;Xb=false end;if Yb.nextnote and Yb.nextnote.delay~=Yb.delay then Yb.stopms=Yb.nextnote.delay-Yb.delay;Yb.stopstart=Yb.ms;Yb.stopend=Yb.stopstart+Yb.stopms end end;Wb=Yb end)end;for Wb,Xb in pairs(l.Data)do if Xb.branch then for Yb,Zb in pairs(Xb.branch.paths)do table.sort(Zb,function(ac,bc)return ac.loadms<bc.loadms end)end end end;table.sort(l.Data,function(Wb,Xb)if Wb.branch and Xb.branch then for Yb,Zb in pairs(Wb.branch.paths)do for ac,bc in pairs(Xb.branch.paths)do return Zb[1].loadms<bc[1].loadms end end elseif Wb.branch then for Yb,Zb in pairs(Wb.branch.paths)do return Zb[1].loadms<Xb.loadms end elseif Xb.branch then for Yb,Zb in pairs(Xb.branch.paths)do return Wb.loadms<Zb[1].loadms end else return Wb.loadms<Xb.loadms end end)Taiko.ConnectAll(l.Data)Taiko.ForAll(l.Data,function(Wb,Xb,Yb)Wb.n=Yb end)local rb=G/w;local sb=qb[1]for i=1,#qb do if qb[i]>sb then sb=qb[i]end end;sb=sb+rb;loaded={}local tb=l.Data[1]local ub=tb.loads;local vb=10;local wb=string.rep(' ',vb)local xb={}local function yb(Wb,Xb)xb[#xb+1]=Wb;xb[#xb+1]=': 'xb[#xb+1]=tostring(Xb)xb[#xb+1]=wb;xb[#xb+1]='\n'end;local function zb()print(table.concat(xb))xb={}end;local Ab={}local function Bb(Wb)Ab[#Ab+1]=Wb end;local function Cb()print(table.concat(Ab,'\n'))Ab={}end;hb.ClearScreen()local Db='M'local Eb={startms=nil,status=nil}local Fb=nil;local Gb=nil;local Hb=nil;local Ib=0;local Jb={-1,nil}local Kb=0;local Lb=0;local Mb=true;local Nb=false;local Ob=false;local Pb=nil;local Qb=nil;local Rb=nil;local Sb=nil;local Tb=nil;local Ub=nil;if q then local Wb=1 /q;local Xb=nil end;local Vb=os.clock()if q then nextframes=Vb+frames end;if not p.on then while true do local Wb=Y.New()local Xb=os.clock()local Yb=Xb-Vb;local Zb=Yb*1000;if Hb and Zb>Hb then Fb,Gb,Hb=nil,nil,nil end;if tb then if tb.loadms<Zb then loaded[#loaded+1]=tb;if Ob and tb.speed~=Pb then Ob=false end;if Ob then tb.p=pb(tb,Tb)if tb.data=='event'then if tb.event=='barline'then Z(Rb,tb,Ob)end elseif tb.data=='note'then eb(Rb,tb,Ob)else error('Invalid note.data')end end;tb=tb.nextnote;if tb and tb.branch then tb=tb.branch.paths[Db][1]end end else if Zb>sb then break end end;if Nb and Ob==false then local ic=nil;for i=1,#loaded do if ic then if loaded[i]and ic~=loaded[i].speed then ic=false;break end else ic=loaded[i].speed end end;if ic then Tb=Zb;Pb=ic;Rb=false;Sb=loaded[1]Ob=true else Ob=false end end;local ac=0;if Ob and Rb then Mb=false;local ic=loaded[1]local jc=Qb or ic.p;Qb=jc;local kc=pb(Sb,Zb)jc=jc or kc;local lc=math.floor(jc-kc+0.5)if lc>=1 then ac=lc else end;Wb=Rb else Qb=nil;Mb=true end;if Mb and Rb~=false then Y.Circle(Wb,math.floor(M),I,H,{color='purple'})end;if Ob then Ub=Y.New()Y.Circle(Ub,math.floor(M)+ac,I,H,{color='purple'})end;local bc={}local cc={}local dc=0;for i=1,#loaded do local ic=i+dc;local jc=loaded[ic]if jc then if jc.data=='note'then if(jc.type==1 or jc.type==3)and(not bc[1]or math.abs(Zb-jc.ms)<bc[1])then bc[1]=math.abs(Zb-jc.ms)cc[1]=jc elseif(jc.type==2 or jc.type==4)and(not bc[2]or math.abs(Zb-jc.ms)<bc[2])then bc[2]=math.abs(Zb-jc.ms)cc[2]=jc end end;jc.p=pb(jc,Fb or(Zb+Ib))if x and(not Gb)and jc.stopstart and Zb>jc.stopstart then Fb=Ib+jc.stopstart;stopms=jc.stopms;Ib=Ib-jc.stopms;Gb=jc.stopstart;Hb=jc.stopend;jc.stopstart=nil end;if math.abs(jc.p-M)> ( (jc.delay*math.abs(jc.speed))+L+F)then if jc.endnote and jc.endnote.done~=true then if Mb then if jc.data=='event'then if jc.event=='barline'then Z(Wb,jc)end elseif jc.data=='note'then eb(Wb,jc)else error('Invalid note.data')end end else jc.done=true;table.remove(loaded,ic)dc=dc-1 end else if Mb then if jc.data=='event'then if jc.event=='barline'then Z(Wb,jc)end elseif jc.data=='note'then eb(Wb,jc)else error('Invalid note.data')end end end end end;if Rb==false then Rb=Wb end;if Eb.status then if Zb>Eb.startms+P then Eb={}else if Ob then fb(Ub,Eb,Zb,ac)else fb(Wb,Eb,Zb,ac)end end end;hb.SetCursor(1,1)if Ob then if Ub then print(Y.ToDotsParallel(Wb,Ub,ac))else print(Y.Convert.ToDots(Wb,ac))end else if q then local ic=Y.Convert.ToDots(Wb,ac)repeat until os.clock()>=nextframes;nextframes=nextframes+frames;print(ic)else print(Y.Convert.ToDots(Wb,ac))end end;Kb=Kb+1;local ec=os.clock()-Xb;Lb=Lb+ec;local fc=U.getch(V)local gc=U.getkeyname(fc)local hc=z.Hit[gc]if s then local ic=bc[1]local jc=bc[2]local kc=(bc[1]and bc[2])and( (bc[1]<bc[2])and 1 or 2)or(bc[1]and 1 or 2)local lc=bc[kc]local mc=cc[kc]if lc and Zb>mc.ms and(not mc.hit)then if u then hc=kc else mc.hit=true;local nc=mc.type;local oc=( (nc==3 or nc==4)and 3)or 2;Eb={startms=Zb,status=oc}end end end;if hc and bc[hc]and(not cc[hc].hit)then local ic=bc[hc]local jc;local kc=cc[hc].type;local lc=( (kc==3 or kc==4)and Taiko.Data.BigLeniency)or 1;if ic< (lb.good)then local mc=cc[hc].type;jc=( (mc==3 or mc==4)and 3)or 2 elseif ic< (lb.ok*lc)then jc=1 elseif ic< (lb.bad*lc)then jc=0 else jc=nil end;if jc then cc[hc].hit=true;Eb={startms=Zb,status=jc}end end;if z.Escape[gc]then local ic=os.clock()hb.ClearScreen()U.nodelay(V,false)local jc={'Back','Retry','Back to Select'}while true do hb.SetCursor(1,1)local kc={}for i=1,#jc do kc[i]=( (i==A)and(C..string.rep(' ',B-#C))or string.rep(' ',B))..jc[i]end;print(table.concat(kc,D))local lc=U.getch(V)local mc=U.getkeyname(lc)if z.L[mc]then A=A==1 and 1 or A-1 elseif z.R[mc]then A=A==3 and 3 or A+1 elseif z.Select[mc]then if A==1 then elseif A==2 then return'Retry'elseif A==3 then return nil end;break elseif z.Escape[mc]then break end end;U.nodelay(V,true)Vb=Vb+ (os.clock()-ic)end;if fc~=-1 then Jb={fc,gc}end;yb('Input (ascii)',Jb[1])yb('Input (key)',Jb[2])yb('S',Yb)yb('Ms',Zb)yb('Loaded',#loaded)yb('Frames Rendered',Kb)yb('Last Frame Render (s)',ec)yb('Last Frame Render (ms)',ec*1000)yb('Frame Render Total (s)',Lb)yb('Frame Render Total (ms)',Lb*1000)yb('Frame Render Total (%)',Lb/Yb*100)yb('FPS (Frame)',Kb/Yb)yb('Memory Usage (mb)',collectgarbage('count')/1000)yb('Finished (%)',Zb/ (sb)*100)yb('Nearest1 (ms)',bc[1])yb('Nearest2 (ms)',bc[2])yb('Stop Start',Gb or'')yb('Stop End',Hb or'')yb('Total Delay',Ib)zb()Cb()end else error('Prerendering has been removed')end;return true end;function Taiko.SongSelect(l,m)local n={}local o,p=10,10;local q,r,s,u=-o,o,-p,p;local v=true;local w=1;local x=1;local y=4;local z=5;local A=5;local B=2;local C='V'local D='>'local E=10;local F=nil;local G='>'local H='>'local I=2;local J=true;local K={[2]={'Normal','Auto'},[3]={'Normal','2x Speed','3x Speed','4x Speed','0.25x Speed','0.5x Speed','0.75x Speed'},[4]={'Normal','2x Speed','3x Speed','4x Speed','0.25x Speed','0.5x Speed','0.75x Speed'},[5]={'TODO Normal'}}local L={4,1,1,1,1,1}local M={nil}for hb,ib in pairs(K)do M[hb]={1,#ib,ib}end;local N=require('./CompactTJA/compactv4')local O=require('taikocurses')local P={window=O.initscr()}O.keypad(P,true)O.echo(false)O.raw(true)O.nl(false)O.cbreak(true)O.nodelay(P,true)O.getch(P)O.nodelay(P,false)local Q,R=O.cols(),O.lines()F=F or Q-2;local S={Escape={['\27']=true,ALT_ESC=true},Scroll={L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_A2=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true}},Select={Init={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Escape={['\27']=true,ALT_ESC=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true},U={KEY_UP=true,KEY_A2=true},D={KEY_DOWN=true,KEY_C2=true},Play={Hit={['4']=2,['v']=1,['n']=1,['8']=2},Escape={['\27']=true,ALT_ESC=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_DOWN=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}}},Search={Init={ALT_F=true,f=true,F=true},Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},FirstResult={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Select={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true},Up={KEY_A2=true,KEY_UP=true},Down={KEY_C2=true,KEY_DOWN=true},Escape={['\27']=true,ALT_ESC=true}},Add={Init={ALT_N=true,n=true,N=true},Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}},StandardInput={Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},Escape={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_DOWN=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true}}}local T={ClearScreen=function()io.write("\27[2J")end,SetCursor=function(hb,ib)io.write(string.format("\27[%d;%dH",ib,hb))end,ClearLine=function()io.write("\27[2K")end,CursorLeft=function(hb)io.write(string.format("\27[%dD",hb))end,CursorRight=function(hb)io.write(string.format("\27[%dC",hb))end,SaveCursor=function()io.write("\27[s")end,RestoreCursor=function()io.write("\27[u")end}local function U(hb)return hb..string.rep(' ',F-#hb)end;local function V()local hb=O.getch(P)local ib=O.getkeyname(hb)return hb,ib end;local function W()local hb=''local ib=0;local jb=ib;while true do local kb,lb=V()if S.StandardInput.Backspace[lb]then hb=string.sub(hb,1,ib-1)..string.sub(hb,ib+1,-1)ib=ib-1 elseif S.StandardInput.Escape[lb]then io.write('\n')return hb elseif S.StandardInput.L[lb]then ib=ib-1 elseif S.StandardInput.R[lb]then ib=ib+1 else hb=string.sub(hb,1,ib)..lb..string.sub(hb,ib+1,-1)ib=ib+1 end;ib=ClipN(ib,0,#hb)local mb=ib-jb;if mb<0 then T.CursorLeft(-mb)elseif mb>0 then T.CursorRight(mb)end;T.SaveCursor()T.ClearLine()io.write('\r')io.write(hb)T.RestoreCursor()jb=ib end end;local function X(hb)return hb>=32 and hb<=126 end;local function Y(hb,ib,jb,kb)return(hb and(ib..string.sub(jb,#ib+1,-1))or jb)..kb end;local function Z(hb,ib,jb)return hb>jb and ib or hb<ib and jb or hb end;local ab={[0]='No',[1]='Yes'}local function bb(hb)return hb and ab[1]or ab[0]end;local function cb(hb)return hb*100 ..'%'end;local function db(hb)return MsToS(hb)..'s'end;local function eb(hb)return db(SToMs(hb))end;local function fb(hb)return tonumber(hb)and tonumber(hb)or 0 end;local gb={}T.ClearScreen()while true do n={}if v then n[q]={}for i=w-z,w+z do local lb=nil;if i<1 then lb=#l+i elseif i>#l then lb=i-#l else lb=i end;local mb=l[lb]if mb then n[0]=n[0]or{}n[0][(i-w)*A]=mb end end;local jb={}local kb=string.rep(' ',B)for y=s,u do jb[#jb+1]=Y(y==0,D,kb,'')jb[#jb+1]=U(n[0][y]or'')jb[#jb+1]='\n'end;T.SetCursor(1,1)print(table.concat(jb))else n[0]={}n[0][s]=C;for i=w-z,w+z do local kb=nil;if i<1 then kb=#l+i elseif i>#l then kb=i-#l else kb=i end;local lb=l[kb]if lb then local mb=(i-w)*A;n[mb]=n[mb]or{}local nb=s+B;for i2=1,#lb do n[mb][nb]=string.sub(lb,i2,i2)nb=nb+1 end end end;local jb={}for y=s,u do for x=q,r do if n[x]and n[x][y]then local kb=n[x][y]if X(string.byte(kb))then jb[#jb+1]=kb else jb[#jb+1]=' 'end else jb[#jb+1]=' 'end end;jb[#jb+1]='\n'end;T.SetCursor(1,1)print(table.concat(jb))end;local hb,ib=V()if S.Scroll.L[ib]then w=w-1 elseif S.Scroll.R[ib]then w=w+1 elseif S.Select.Init[ib]then local jb;if J then if gb[w]then jb=gb[w]else jb=Taiko.ParseTJA(m[w])gb[w]=jb end else jb=Taiko.ParseTJA(m[w])end;local kb={}for ob,pb in pairs(jb)do kb[#kb+1]={ob,pb.Metadata.COURSE}end;table.sort(kb,function(ob,pb)return ob[2]<pb[2]end)min=1;max=#kb;M[1]={min,max,kb}DifficultyMap=kb;L[1]=ClipN(L[1],min,max)local lb=string.rep(' ',I)T.ClearScreen()T.SetCursor(1,1)local mb=nil;local nb=x;while true do x=ClipN(x,1,5)if x~=nb then y=L[x]nb=x end;local ob=M[x]min,max=ob[1],ob[2]y=Z(y,min,max)L[x]=y;T.SetCursor(1,1)local pb=DifficultyMap[L[1]][2]mb=Taiko.GetDifficulty(jb,pb)local qb=mb.Metadata;local rb=Taiko.Analyze(mb)local sb={{'',qb.TITLE},{'\t',qb.SUBTITLE},{'',''},{'','Select Options:'},{Y(x==1,H,lb,'Difficulty: '),Taiko.Data.CourseName[qb.COURSE]},{Y(x==2,H,lb,'Mode: '),K[2][L[2]]},{Y(x==3,H,lb,'Note Speed: '),K[3][L[3]]},{Y(x==4,H,lb,'Song Speed: '),K[4][L[4]]},{Y(x==5,H,lb,'Modifiers: '),K[5][L[5]]},{'',''},{'Difficulty: ',Taiko.Data.CourseName[qb.COURSE]},{'Stars: ',qb.LEVEL},{'Diverge Notes: ',bb(qb.DIVERGENOTES)},{'',''},{'','Statistics:'},{'Don (DON) / Ka (KA): ',fb(rb.notes[1])..' + ('..fb(rb.notes[3])..') / '..fb(rb.notes[2])..' + ('..fb(rb.notes[4])..') = '..cb((fb(rb.notes[1])+fb(rb.notes[3]))/rb.notes.validn)..' / '..cb((fb(rb.notes[2])+fb(rb.notes[4]))/rb.notes.validn)},{'Max Score (without drumroll): ',rb.maxscore},{'Max Combo: ',rb.maxcombo},{'Drumroll Time (total): ',db(rb.drumrollms+rb.drumrollbigms)},{'Balloon Time: ',db(rb.balloonms)},{'Balloon Hits: ',rb.balloonhit},{'Special Time: ',db(rb.specialms)},{'Special Hits: ',rb.specialhit},{'',''},{'','Press Enter to Play!'}}for i=1,#sb do local vb=sb[i]print(U(vb[1]..tostring(vb[2])))end;local tb,ub=V()if S.Select.L[ub]then y=y-1 elseif S.Select.R[ub]then y=y+1 elseif S.Select.U[ub]then x=x-1 elseif S.Select.D[ub]then x=x+1 elseif S.Select.Select[ub]then while true do local vb,wb=Taiko.PlaySong(Taiko.GetDifficulty(jb,pb),P,L,S.Select.Play)if vb and wb then break elseif vb=='Retry'then else break end end;O.nodelay(P,false)T.ClearScreen()elseif S.Select.Escape[ub]then break end end elseif S.Search.Init[ib]then local jb=''local kb={}local lb=1;local mb=nil;local nb=1;T.ClearScreen()T.SetCursor(1,1)print('Searching...')while true do T.SetCursor(#jb+1,2)local ob,pb=V()T.SetCursor(1,2)if S.Search.Backspace[pb]then jb=string.sub(jb,1,-2)elseif S.Search.FirstResult[pb]then mb=kb[1]break elseif S.Search.Select[pb]then mb=kb[nb]break elseif S.Search.Down[pb]then nb=nb+1 elseif S.Search.Up[pb]then nb=nb-1 elseif S.Search.Escape[pb]then break else jb=jb..pb end;print(U(jb))local qb=N.SearchHeaderAll(l,jb)for i=1,E do if qb[i][2]==-math.huge then lb=i-1;break elseif i==E then lb=i end end;nb=ClipN(nb,1,lb)local rb=false;for i=1,E do local sb=qb[i]if rb then print(U(''))else if sb then if sb[2]==-math.huge then rb=true;print(U(''))else print(U((i==nb and G or i)..'. '..qb[i][3]))kb[i]=sb end end end end end;w=(mb and mb[1]or w)or w elseif S.Add.Init[ib]then print('Import a Custom Song')while true do print('Enter a .tja or .tjac file path (with the file extention)')local jb=W()local kb=io.open(jb,'rb')if kb then local lb=kb:read('*all')if EndsWith(jb,'.tja')then print('Enter a song name')local mb=W()l[#l+1]=mb;m[#m+1]=lb;break elseif EndsWith(jb,'.tjac')then local mb,nb=N.Decompress(lb)for i=1,#mb do m[#m+1]=mb[i]l[#l+1]=nb[i]end;break else print('Invalid file type')end;io.close(kb)else print('Unable to read file')end end elseif S.Escape[ib]then return end;w=Z(w,1,#l)end end;function Taiko.Game()end;local h='./CompactTJA/taikobuipm.tjac'h='./CompactTJA/ESE/06 Classical.tjac'h='./CompactTJA/ESE/ESE.tjac'local i=require('./CompactTJA/compactv4')local j,k=i.Decompress(i.Read(h))Taiko.SongSelect(k,j)error()Taiko.PlaySong(Taiko.GetDifficulty(Taiko.ParseTJA(i.InputFile(h)),'Ura'))
#!.\raylua_s.exe 
local k=require('CompactTJA/compact')local l=require('ReplayTaiko/replayv1')Split=function(u,v)local w={}for x,y in u:gmatch("([^"..v.."]*)("..v.."?)")do table.insert(w,x)if y==''then return w end end end;Trim=function(u)local v=u:gsub("^%s*(.-)%s*$","%1")return v end;TrimLeft=function(u)local v=u:gsub("^%s*(.-)$","%1")return v end;TrimRight=function(u)local v=u:gsub("^(.-)%s*$","%1")return v end;StartsWith=function(u,v)return u:sub(1,#v)==v end;EndsWith=function(u,v)return u:sub(-#v,-1)==v end;Table={}function Table.Clone(u,v)v=v or{}local w=type(u)local x;if w=='table'then if v[u]then x=v[u]else x={}v[u]=x;for y,z in next,u,nil do x[Table.Clone(y,v)]=Table.Clone(z,v)end;setmetatable(x,Table.Clone(getmetatable(u),v))end else x=u end;return x end;ClipN=function(u,v,w)if u<v then return v elseif u>w then return w else return u end end;function Error(u)error(u)end;LineN=nil;function ParseError(u,v,w)Error('Line: '..LineN..'\n'..u..': '..v.. (w and(', '..w)or''))end;function MsToS(u)return u/1000 end;function SToMs(u)return u*1000 end;Taiko={}Taiko.Data={Languages={'','EN','JA','CN','TW','KO'},GenreName={Pop={'pop','j-pop'},Anime={'anime','アニメ'},Kids={'kids','どうよう'},Variety={'variety','バラエティ'},VOCALOID={'vocaloid','ボーカロイド'},Classic={'classic','クラシック'},['Game Music']={'game music','ゲームミュージック'},['Namco Original']={'namco original','ナムコオリジナル'}},CourseId={easy=0,normal=1,hard=2,oni=3,edit=4,tower=5,dan=6,ura=4},CourseName={[0]='Easy','Normal','Hard','Oni','Edit','Tower','Dan','Ura'},RatingMultiplier={[0]=0,[1]=0.5,[2]=1,[3]=2},GogoMultiplier=1.2,ScoreMode={Note={[0]=function(u,v,w,x,y,z)return u+ ( ( (v<200)and(w or 1000)or( (w or 1000)+ (x or 1000)))*Taiko.Data.RatingMultiplier[y]* (z and Taiko.Data.GogoMultiplier or 1))end,[1]=function(u,v,w,x,y,z)return u+ ( (w+math.max(0,x*math.floor((math.min(v,100)-1)/10)))*Taiko.Data.RatingMultiplier[y]* (z and Taiko.Data.GogoMultiplier or 1))end,[2]=function(u,v,w,x,y,z)return math.floor((u+ ( (w+x* ( (v>=100)and 8 or(v>=50)and 4 or(v>=30)and 2 or(v>=10)and 1 or 0))*Taiko.Data.RatingMultiplier[y]* (z and Taiko.Data.GogoMultiplier or 1)))/10)*10 end},Drumroll={[0]=function(u,v,w)return u+ ( (v==5 and 300 or v==6 and 600)* (w and Taiko.Data.GogoMultiplier or 1))end,[1]=function(u,v,w)return u+ ( (v==5 and 300 or v==6 and 600)* (w and Taiko.Data.GogoMultiplier or 1))end,[2]=function(u,v,w)return u+ ( (v==5 and 100 or v==6 and 200)* (w and Taiko.Data.GogoMultiplier or 1))end},Balloon={[0]=function(u,v,w)return u+ ( (v==7 and 300)* (w and Taiko.Data.GogoMultiplier or 1))end,[1]=function(u,v,w)return u+ ( (v==7 and 300)* (w and Taiko.Data.GogoMultiplier or 1))end,[2]=function(u,v,w)return u+ ( (v==7 and 300)* (w and Taiko.Data.GogoMultiplier or 1))end},BalloonPop={[0]=function(u,v,w)return u+ ( (v==7 and 5000)* (w and Taiko.Data.GogoMultiplier or 1))end,[1]=function(u,v,w)return u+ ( (v==7 and 5000)* (w and Taiko.Data.GogoMultiplier or 1))end,[2]=function(u,v,w)return u+ ( (v==7 and 5000)* (w and Taiko.Data.GogoMultiplier or 1))end}},Autoscore={[0]=function(u)end,[1]=function(u)end,[2]=function(u)end},SideId={normal=1,ex=2,both=3},SideName={'normal','ex','both'},StyleId={single=1,double=2,couple=2},StyleName={'single','double'},Exam={Condition={g=true,jp=true,jg=true,jb=true,s=true,r=true,h=true,c=true},Scope={m=true,l=true}},Branch={PathId={N=0,E=1,M=2},PathName={[0]='N',[1]='E',[2]='M'},Requirements={r=function()end,p=function()end}},Timing={GetFunction=function(u)return function(v)if u==1 then return{good=5 /2 *v,ok=13 /2 *v,bad=15 /2 *v}else return{good=3 /2 *v,ok=9 /2 *v,bad=13 /2 *v}end end end},StatusId={bad=0,ok=1,good=2,biggood=3},StatusName={[0]='BAD',[1]='OK',[2]='GOOD',[3]='GOOD'},ModeId={['']=0,P1=1,P2=2},ModeName={[0]='',P1,P2},Combo={[1]=true,[2]=true,[3]=true,[4]=true},BigLeniency=2,Notes={ReverseNotes={[0]=0,[1]=2,[2]=1,[3]=4,[4]=3,[5]=5,[6]=6,[7]=7,[8]=8,[9]=9}},BigNoteMul=1.5,Strings={Notes={}}}function Taiko.ParseTJA(u)local v=os.clock()local w=true;local x=true;local y=true;local z={}local A={Metadata={SUBTITLE='',BPM=120,WAVE='main.mp3',OFFSET=0,DEMOSTART=0,SCOREMODE=1,SONGVOL=100,SEVOL=100,SIDE=3,LIFE=0,GAME='Taiko',HEADSCROLL=1,MOVIEOFFSET=0,COURSE='ONI',LEVEL=0,BALLOON=nil,SCOREINIT,SCOREDIFF,BALLOONNOR=nil,BALLOONEXP=nil,BALLOONMAS=nil,STYLE=1,EXAM1=nil,EXAM2=nil,EXAM3=nil,GAUGEINCR='NORMAL',TOTAL=nil,HIDDENBRANCH=0,DIVERGENOTES=false,SCOREINIT=0,SCOREDIFF=0,STOPSONG=false},Data={}}local function B(X)local Y=Taiko.Data.Languages;for i=1,#Y do local Z=A.Metadata[X..Y[i]]if Z then return Z end end;return nil end;local function C(X,Y,Z)local ab=tonumber(Y)if ab then return ab else ParseError(X,Z,Y)end end;local function D(X,Y,Z,ab)if Y then return Y else ParseError(X,Z,ab)end end;local function E(X,Y,Z)local ab={['true']=true,['false']=false,yes=true,no=false,['1']=true,['0']=false,[1]=true,[0]=false}local bb=ab[Y]~=nil;if bb then return bb else ParseError(X,Z,Y)end end;local function F(X,Y)local Z=','local ab='\\'local bb={}local cb=''local db=false;for i=1,#Y do local eb=string.sub(Y,i,i)if db then cb=cb..eb;db=false else if eb==Z then table.insert(bb,cb)cb=''elseif eb==ab then db=true else cb=cb..eb end end end;table.insert(bb,cb)return bb end;local function G(X,Y,Z)local ab=F(X,Y)for i=1,#ab do ab[i]=C(X,ab[i],Z,Y)end;return ab end;local function H(X,Y,Z)if Y and Y~=''then return G(X,Y,Z)else return{}end end;local function I(X,Y,Z)if Y and Y~=''then local ab=F(X,Y,Z)D(X,Taiko.Data.Exam.Condition[ab[1]],Z)ab[2]=C(X,ab[2],Z)ab[3]=C(X,ab[3],Z)D(X,Taiko.Data.Exam.Scope[ab[4]],Z)return ab else return{}end end;local J=error;local function K(X)return string.find(X,'/')end;local function L(X)return string.match(X,'(%d+)/(%d+)')end;local function M(X)local Y=nil;local Z=false;local ab=''for i=1,#X do local bb=string.sub(X,i,i)if bb=='+'or bb=='-'then if Y then J('There are multiple signs')else Y=bb end elseif bb=='.'then if Z then J('There are multiple decimal points')else ab=ab..bb;Z=true end elseif tonumber(bb)then ab=ab..bb end end;if ab==''then J('No number was found')end;return tonumber((Y or'+')..ab)end;local function N(X)local Y=tonumber(X)if Y then return Y end;local Z=string.gsub(X,'[^%d%.%-%+]','')if Z==''then return 0 end;return tonumber(Z)or M(X)or M(Z)end;local function O(X)return string.find(X,'i')end;local function P(X)local Y={0,0}local Z=false;local ab=''for i=1,#X do local bb=string.sub(X,i,i)if bb=='+'or bb=='-'then Y[1]=Y[1]+N(ab)ab=bb elseif bb=='i'then Y[2]=Y[2]+N(ab)ab=''else ab=ab..bb end end;if ab~=''then Y[1]=Y[1]+N(ab)end;return Y end;local function Q(X)local Y=Split(X,'%+')local Z={}for i=1,#Y do local cb=Split(Y[i],'%-')for i=1,#cb do if i==1 then Z[#Z+1]=cb[i]else Z[#Z+1]='-'..cb[i]end end end;Y=Z;local ab={0,0}local bb={false,false}for i=1,#Y do if Y[i]~=''then local cb=false;if string.find(Y[i],'i')then cb=true;Y[i]=string.gsub(Y[i],'i','')end;if K(Y[i])then local db=false;if string.find(Y[i],'%-')then db=true end;local eb,fb=L(Y[i])Y[i]=(eb/fb)bb[cb and 2 or 1]=true;if db then Y[i]=-Y[i]end else Y[i]=tonumber(Y[i])end;if cb then ab[2]=ab[2]+Y[i]else ab[1]=ab[1]+Y[i]end end end;return ab,bb end;local function R(X)return string.find(X,',')end;local function S(X,Y)return{X*math.cos(Y),X*math.sin(Y)}end;local function T(X)return Split(X,' ')end;local U={}local function V()local X={settings={noteparse={notes={[0]=true,[1]=true,[2]=true,[3]=true,[4]=true,[5]=true,[6]=true,[7]=true,[8]=true,[9]=true,['A']=true,['B']=true}},command={matchexceptions={}},directionweight={R=0,U=90,L=180,D=270,['0']=0,['1']=90,['2']=270,['3']=45,['4']=315,['5']=180,['6']=135,['7']=225}},bpm=0,ms=0,songstarted=false,timingpoint=nil,sign=4 /4,mpm=0,mspermeasure=0,scroll=1,scrollx=-1,scrolly=0,measuredone=true,currentmeasure={},measurepushto=A.Data,barline=true,insertbarline=true,gogo=false,lastlong=nil,balloonn=1,currentbranch=nil,branch={on=false,requirements={},paths={}},msbeforebranch=nil,section=false,disablescroll=false,stopsong=false,delay=0,suddenappear=nil,suddenmove=nil,notechain={},jposscroll={lengthms=nil,p=nil,lanep=nil}}function X.createnote(Y)if Y then local Z={ms=nil,data=nil,type=Y,txt=nil,gogo=X.gogo,scroll=(X.scroll*A.Metadata.HEADSCROLL),scrollx=(X.scrollx*A.Metadata.HEADSCROLL),scrolly=(X.scrolly*A.Metadata.HEADSCROLL),mspermeasure=X.mspermeasure,bpm=X.bpm,nextnote=nil,radius=1,requiredhits=nil,lengthms=nil,endnote=nil,section=nil,text=nil,delay=X.delay,appearancems=X.suddenappear,movems=X.suddenmove,dummy=X.dummy,onnotepush=nil,line=LineN}if Y==3 or Y==4 or Y==6 then Z.radius=Z.radius*Taiko.Data.BigNoteMul end;if Y==5 or Y==6 or Y==7 or Y==9 then if X.lastlong then if Y==9 then else ParseError('parser.noteparse','Last long note has not ended')end else X.lastlong=Z;if Y==7 or Y==9 then Z.requiredhits=D('parser.noteparse',A.Metadata.BALLOON[X.balloonn],'Invalid number of balloons',X.balloonn)X.balloonn=X.balloonn+1 end end end;if Y==8 then local ab=X.lastlong;X.lastlong=nil;Z.startnote=ab;if ab then Z.onnotepush=function()ab.lengthms=Z.ms-ab.ms;ab.endnote=Z end else end end;if X.section then Z.section=true;X.section=false end;return Z else return{ms=nil,data=nil,type=nil,txt=nil,gogo=X.gogo,scroll=(X.scroll*A.Metadata.HEADSCROLL),scrollx=(X.scrollx*A.Metadata.HEADSCROLL),scrolly=(X.scrolly*A.Metadata.HEADSCROLL),mspermeasure=X.mspermeasure,bpm=X.bpm,nextnote=nil,delay=X.delay,appearancems=X.suddenappear,movems=X.suddenmove,line=LineN}end end;function X.createbarline()local Y=X.createnote()Y.ms=X.ms;Y.data='event'Y.event='barline'return Y end;function X.endbranch()local Y=X.createnote()Y.data='event'Y.event='branch'Y.branch={requirements=X.branch.requirements,paths=X.branch.paths}X.branch.on=false;X.branch.requirements={}X.branch.paths={}table.insert(A.Data,Y)X.measurepushto=A.Data end;return X end;U=V()local W=Split(u,'\n')for i=1,#W do LineN=i;local X=Trim(W[i])if StartsWith(X,'//')or X==''then else local Y=string.find(X,'//')if Y then X=string.sub(X,1,Y-1)end;local Z=false;if U.songstarted==false and Z==false then local ab={string.match(X,'(%u+):(.*)')}if ab[1]then local bb=Trim(ab[2])if bb~=''then A.Metadata[Trim(ab[1])]=bb end;Z=true end end;if(U.songstarted or StartsWith(X,'#START')or StartsWith(X,'#BMSCROLL')or StartsWith(X,'#HBSCROLL'))and Z==false then local ab={string.match(X,'#(%u-)%s(.*)')}if not ab[1]then ab={string.match(X,'#(%u+)')}end;if ab[1]then if ab[1]=='START'then if U.songstarted then ParseError(ab[1],'Song has already started')else A.OriginalMetadata=Table.Clone(A.Metadata)if ab[2]then A.Metadata.MODE=D(ab[1],Taiko.Data.ModeId[ab[2]],'Invalid mode',ab[2])else A.Metadata.MODE=0 end;A.Metadata.TITLE=D(ab[1],B('TITLE'),'Title is missing')A.Metadata.SUBTITLE=D(ab[1],B('SUBTITLE'),'Subtitle is missing')A.Metadata.BPM=C(ab[1],A.Metadata.BPM,'Invalid bpm')A.Metadata.OFFSET=SToMs(C(ab[1],A.Metadata.OFFSET,'Invalid offset'))A.Metadata.DEMOSTART=SToMs(C(ab[1],A.Metadata.DEMOSTART,'Invalid demostart'))if A.Metadata.DEMOSTART==0 then A.Metadata.DEMOSTART=nil end;for eb,fb in pairs(Taiko.Data.GenreName)do for i=1,#fb do if fb[i]==A.Metadata.GENRE then A.Metadata.GENRE=eb end end end;A.Metadata.SCOREMODE=C(ab[1],A.Metadata.SCOREMODE,'Invalid scoremode')D(ab[1],Taiko.Data.ScoreMode.Note[A.Metadata.SCOREMODE],'Invalid scoremode',A.Metadata.SCOREMODE)if A.Metadata.MAKER then A.Metadata.CREATORURLT={}A.Metadata.CREATOR=Trim(string.gsub(A.Metadata.MAKER,'(<.->)',function(eb)table.insert(A.Metadata.CREATORURLT,string.sub(eb,2,-2))return''end))A.Metadata.CREATORURL=table.concat(A.Metadata.CREATORURLT,', ')A.Metadata.CREATIVE=false else A.Metadata.CREATIVE=false end;A.Metadata.SONGVOL=C(ab[1],A.Metadata.SONGVOL,'Invalid songvol')/100;A.Metadata.SEVOL=C(ab[1],A.Metadata.SEVOL,'Invalid sevol')/100 /2;local bb=tonumber(A.Metadata.SIDE)if bb then D(ab[1],Taiko.Data.SideName[bb],'Invalid side id',A.Metadata.SIDE)A.Metadata.SIDE=bb else A.Metadata.SIDE=D(ab[1],Taiko.Data.SideId[string.lower(A.Metadata.SIDE)],'Invalid side name',A.Metadata.SIDE)end;A.Metadata.LIFE=C(ab[1],A.Metadata.LIFE,'Invalid life')if A.Metadata.LIFE==0 then A.Metadata.LIFE=nil end;A.Metadata.GAME=string.lower(A.Metadata.GAME)if A.Metadata.GAME=='taiko'then elseif A.Metadata.GAME=='jube'then else end;A.Metadata.HEADSCROLL=C(ab[1],A.Metadata.HEADSCROLL,'Invalid headscroll')A.Metadata.MOVIEOFFSET=C(ab[1],A.Metadata.MOVIEOFFSET,'Invalid movieoffset')local cb=tonumber(A.Metadata.COURSE)if cb then D(ab[1],Taiko.Data.CourseName[cb],'Invalid course id',A.Metadata.COURSE)A.Metadata.COURSE=cb else A.Metadata.COURSE=D(ab[1],Taiko.Data.CourseId[string.lower(A.Metadata.COURSE)],'Invalid course name',A.Metadata.COURSE)end;A.Metadata.TIMING=Taiko.Data.Timing.GetFunction(A.Metadata.COURSE)A.Metadata.LEVEL=ClipN(math.floor(C(ab[1],A.Metadata.LEVEL,'Invalid level')),0,10)A.Metadata.BALLOON=H(ab[1],A.Metadata.BALLOON,'Invalid balloon')A.Metadata.SCOREINIT=C(ab[1],A.Metadata.SCOREINIT,'Invalid scoreinit')A.Metadata.SCOREDIFF=C(ab[1],A.Metadata.SCOREDIFF,'Invalid scoreinit')A.Metadata.BALLOONNOR=H(ab[1],A.Metadata.BALLOONNOR,'Invalid balloonnor')A.Metadata.BALLOONEXP=H(ab[1],A.Metadata.BALLOONEXP,'Invalid balloonexp')A.Metadata.BALLOONMAS=H(ab[1],A.Metadata.BALLOONMAS,'Invalid balloonmas')local db=tonumber(A.Metadata.STYLE)if db then D(ab[1],Taiko.Data.StyleName[db],'Invalid style id',Taiko.Data.STYLE)A.Metadata.STYLE=db else A.Metadata.STYLE=D(ab[1],Taiko.Data.StyleId[string.lower(A.Metadata.STYLE)],'Invalid style name',A.Metadata.STYLE)end;A.Metadata.EXAM1=I(A.Metadata.EXAM1)A.Metadata.EXAM2=I(A.Metadata.EXAM2)A.Metadata.EXAM3=I(A.Metadata.EXAM3)A.Metadata.GAUGEINCR=string.lower(A.Metadata.GAUGEINCR)if A.Metadata.TOTAL then A.Metadata.TOTAL=C(ab[1],A.Metadata.TOTAL,'Invalid total')end;A.Metadata.HIDDENBRANCH=E(ab[1],A.Metadata.HIDDENBRANCH,'Invalid hiddenbranch')U.bpm=A.Metadata.BPM;U.songstarted=true end elseif ab[1]=='END'then if U.songstarted then if#U.currentmeasure~=0 then ParseError(ab[1],'Current measure is not empty')end;table.insert(z,A)A={Metadata=Table.Clone(A.OriginalMetadata),Data={}}U=V()U.songstarted=false;U.measurepushto=A.Data else ParseError(ab[1],'Song has already ended')end elseif ab[1]=='MEASURE'then local bb,cb=L(ab[2])bb=C(ab[1],bb,'Invalid measure')cb=C(ab[1],cb,'Invalid measure')U.sign=(bb/cb)or U.sign elseif ab[1]=='BPMCHANGE'then U.bpm=C(ab[1],ab[2],'Invalid bpmchange')or U.bpm elseif ab[1]=='DELAY'then local bb=SToMs((C(ab[1],ab[2],'Invalid delay')or 0))if A.Metadata.STOPSONG then U.delay=U.delay+bb end;table.insert(U.currentmeasure,{'DELAY',bb})elseif ab[1]=='SCROLL'then if U.disablescroll then else if x and O(ab[2])then local bb=P(ab[2])U.scrollx=-bb[1]U.scrolly=-bb[2]elseif x and R(ab[2])then local bb=G(ab[1],ab[2],'Invalid polar scroll')if#bb==3 then local cb=S(bb[1],math.rad(bb[3]/bb[2]*360))U.scrollx=-cb[1]U.scrolly=-cb[2]else ParseError(ab[1],'Invalid polar scroll')end else U.scrollx=- (C(ab[1],ab[2],'Invalid scroll')or-U.scrollx)U.scrolly=0 end;U.scroll=-U.scrollx;if U.scroll==0 and U.scrollx==0 and U.scrolly==0 then ParseError(ab[1],'Scroll cannot be 0')end end elseif ab[1]=='GOGOSTART'then U.gogo=true elseif ab[1]=='GOGOEND'then U.gogo=false elseif ab[1]=='BARLINEOFF'then U.barline=false elseif ab[1]=='BARLINEON'then U.barline=true elseif ab[1]=='BRANCHSTART'then if U.branch.on then U.endbranch()end;U.msbeforebranch=U.ms;U.branch.on=true;A.Metadata.DIVERGENOTES=true;local bb=F(ab[1],ab[2])local cb=D(ab[1],Taiko.Data.Branch.Requirements[string.lower(bb[1])],'Invalid type',bb[1])U.branch.requirements={cb}local db=2;while true do if not bb[db]then break end;local eb=Taiko.Data.Branch.PathName[db-1]if eb then U.branch.requirements[eb]=bb[db]else break end;db=db+1 end elseif Taiko.Data.Branch.PathId[ab[1]]then if U.branch.on then U.ms=U.msbeforebranch;U.currentbranch=ab[1]U.branch.paths[ab[1]]={}U.measurepushto=U.branch.paths[ab[1]]else ParseError(ab[1],'Branch has not started')end elseif ab[1]=='BRANCHEND'then if U.branch.on then U.endbranch()else ParseError(ab[1],'Branch has already ended')end elseif ab[1]=='SECTION'then U.section=true elseif ab[1]=='LYRIC'then elseif ab[1]=='LEVELHOLD'then elseif ab[1]=='BMSCROLL'then U.disablescroll=true;A.Metadata.STOPSONG=true elseif ab[1]=='HBSCROLL'then A.Metadata.STOPSONG=true elseif ab[1]=='SENOTECHANGE'then elseif ab[1]=='NEXTSONG'then elseif ab[1]=='DIRECTION'then local bb=ab[2]local cb=U.settings.directionweight;local db=0;local eb=0;for i=1,#bb do local ib=string.sub(bb,i,i)if cb[ib]then db=db+cb[ib]eb=eb+1 end end;if eb==0 then ParseError(ab[1],'Invalid direction')end;local fb=db/eb;local gb=math.sqrt(U.scrollx^2 +U.scrolly^2)local hb=S(gb,math.rad(fb))U.scrollx=-hb[1]U.scrolly=-hb[2]elseif ab[1]=='SUDDEN'then local bb=T(ab[2])U.suddenappear=SToMs(C(ab[1],bb[1],'Invalid sudden')or(U.suddenappear and MsToS(U.suddenappear)or 0))U.suddenmove=SToMs(C(ab[1],bb[2],'Invalid sudden')or(U.suddenmove and MsToS(U.suddenmove)or 0))elseif ab[1]=='JPOSSCROLL'then local bb=false;local cb=T(ab[2])local function db(eb,fb,gb,hb)if(x and K(fb))or(hb)then U.jposscroll.lanep=U.jposscroll.lanep or{nil,nil}if K(fb)then local ib,jb=L(fb)ib=C(ab[1],ib,'Invalid jposscroll')jb=C(ab[1],jb,'Invalid jposscroll')U.jposscroll.lanep[eb]=(ib/jb)else U.jposscroll.lanep[eb]=fb end;if gb then U.jposscroll.lanep[1]=U.jposscroll.lanep[1]* (D(ab[1],gb=='1'and 1 or gb=='0'and-1,'Invalid jposscroll',gb)or 1)end elseif x and fb=='default'then U.jposscroll.p='default'else U.jposscroll.p=U.jposscroll.p or{nil,nil}U.jposscroll.p[1]=C(ab[1],fb,'Invalid jposscroll')if gb then U.jposscroll.p[1]=U.jposscroll.p[1]* (D(ab[1],gb=='1'and 1 or gb=='0'and-1,'Invalid jposscroll',gb)or 1)end end end;if y then if O(cb[2])then local eb,fb=Q(cb[2])db(1,eb[1],nil,fb[1])db(2,eb[2],nil,fb[2])bb=true elseif R(cb[2])then local eb=F(ab[1],cb[2])if#eb==3 then local fb=false;if K(eb[2])then fb=true;local hb,ib=L(eb[2])hb=C(ab[1],hb,'Invalid polar jposscroll')ib=C(ab[1],ib,'Invalid polar jposscroll')eb[2]=(hb/ib)else eb[2]=C(ab[1],eb[2],'Invalid polar jposscroll')end;eb[1]=C(ab[1],eb[1],'Invalid polar jposscroll')eb[3]=C(ab[1],eb[3],'Invalid polar jposscroll')local gb=S(eb[1],math.rad(eb[3]/eb[2]*360))db(1,gb[1],nil,fb)db(2,gb[2],nil,fb)bb=true else ParseError(ab[1],'Invalid polar jposscroll')end end else end;if bb==false then db(1,cb[2],cb[3])end;U.jposscroll.lengthms=SToMs(C(ab[1],cb[1],'Invalid jposscroll')or 0)table.insert(U.currentmeasure,{'JPOSSCROLL',U.jposscroll})U.jposscroll={}elseif x then if ab[1]=='GAMEMODE'then elseif ab[1]=='SPLITLANE'then elseif ab[1]=='MERGELANE'then elseif ab[1]=='BARLINE'then table.insert(U.measurepushto,U.createbarline())elseif ab[1]=='DUMMYSTART'then U.dummy=true elseif ab[1]=='DUMMYEND'then U.dummy=false elseif ab[1]==''then elseif ab[1]==''then elseif ab[1]==''then elseif ab[1]==''then elseif ab[1]==''then elseif ab[1]==''then elseif ab[1]==''then elseif ab[1]==''then elseif ab[1]==''then elseif ab[1]==''then elseif ab[1]==''then elseif ab[1]==''then elseif ab[1]==''then elseif ab[1]==''then elseif ab[1]==''then elseif ab[1]==''then elseif ab[1]==''then elseif ab[1]=='RESETCOMMAND'then end else end;Z=true end end;if(U.songstarted)and Z==false then U.mpm=U.bpm*U.sign/4;U.mspermeasure=60000 *U.sign*4 /U.bpm;if U.barline and U.insertbarline then table.insert(U.measurepushto,U.createbarline())U.insertbarline=false end;for i=1,#X do local ab=string.sub(X,i,i)local bb=tonumber(ab)or ab;if U.settings.noteparse.notes[bb]then local cb=U.createnote(bb)cb.data='note'table.insert(U.currentmeasure,cb)end end;if EndsWith(TrimRight(X),',')then U.mpm=U.bpm*U.sign/4;U.mspermeasure=60000 *U.sign*4 /U.bpm;if#U.currentmeasure==0 then U.ms=U.ms+U.mspermeasure elseif#U.currentmeasure==1 and U.currentmeasure[1].data=='event'and U.currentmeasure[1].event=='barline'then A.Data[#A.Data+1]=U.currentmeasure[1]U.ms=U.ms+U.mspermeasure else local ab=0;local bb=nil;for i=1,#U.currentmeasure do local eb=U.currentmeasure[i]if eb.data=='note'then bb=bb or eb.mspermeasure;ab=ab+1 end end;bb=bb or U.mspermeasure;local cb=bb/ab;local db=false;for i=1,#U.currentmeasure do local eb=U.currentmeasure[i]if eb[1]=='DELAY'then U.ms=U.ms+eb[2]elseif eb[1]=='JPOSSCROLL'then db=eb[2]else if not w or eb.type~=0 then eb.ms=U.ms;eb.appearancems=eb.appearancems and(eb.ms- (eb.appearancems))eb.movems=eb.movems and(eb.ms- (eb.movems))local fb=U.measurepushto[#U.measurepushto]or A.Data[#A.Data]if fb then fb.nextnote=eb end;table.insert(U.measurepushto,eb)if eb.onnotepush then eb.onnotepush()end;cb=eb.mspermeasure/ab end;if db then eb.jposscroll=db;db=false end;if eb.data=='note'then U.ms=U.ms+cb end end end end;U.measuredone=true;U.currentmeasure={}if nextjposscroll then U.currentmeasure[#U.currentmeasure+1]=nextjposscroll end;U.insertbarline=true else U.measuredone=false end end end end;print('Parsing Took: '..SToMs(os.clock()-v)..'ms')return z end;function Taiko.ParseTJAFile(u)local v=io.open(u,'r')local w=v:read('*all')local x=Taiko.ParseTJA(w)local y=string.find(u,'[/\\]')for z,A in pairs(x)do A.Metadata.SONG=(y and string.sub(u,1,y)or'')..A.Metadata.WAVE end;return x end;function Taiko.SerializeTJA(u)local function v(G)return math.floor(G+0.5)end;local w=5;local x=10 ^w;local function y(G)return math.floor(G*x+0.5)/x end;local function z(G)if math.floor(G)~=G then return string.format('%f',G)else return tostring(G)end end;local function A(G,H)if G<H then return A(H,G)end;if math.abs(H)<0.001 then return G else return A(H,G-math.floor(G/H)*H)end end;local function B(G)local H=A(G,1)return v(G/H),v(1 /H)end;local function C(G)local H,I=string.match(G,'(%d+)/(%d+)')return H,I end;local function D(G)for i=1,#G do G[i]=tostring(G[i])end;return table.concat(G,',')end;local function E(G)local H={}local I={OFFSET=true,DEMOSTART=true}for R,S in pairs(G.Metadata)do local T;if type(S)=='number'then if I[R]then T=tostring(MsToS(tonumber(S)))else T=tostring(S)end elseif type(S)=='table'then T=D(S)elseif type(S)=='string'then T=tostring(S)else T=nil end;if T then H[#H+1]=R;H[#H+1]=':'H[#H+1]=T;H[#H+1]='\n'end end;H[#H+1]='\n\n'local J=false;local K=false;local L=G.Metadata.HEADSCROLL;for i=1,#G.Data do local R=G.Data[i]R.ms=R.ms-R.delay;if R.data=='event'and R.event=='barline'then J=true end;if R.delay and R.delay~=0 then K=true end;if R.scroll and R.scroll~=L then L=false end end;if K then if L then H[#H+1]='#BMSCROLL\n'else H[#H+1]='#HBSCROLL\n'end end;H[#H+1]='#START\n'if J then H[#H+1]='#BARLINEON\n'else H[#H+1]='#BARLINEOFF\n'end;local M={startms=nil}local N=nil;local O=0;local P={scroll=0,bpm=G.Metadata.BPM,measure=nil,gogo=false,delay=0}local Q={scroll={'#SCROLL ',nil,function(R)local S=R.scroll/G.Metadata.HEADSCROLL;if S~=P.scroll then P.scroll=S;return tostring(S)end end},bpm={'#BPMCHANGE ',tostring(G.Metadata.BPM),function(R)local S=R.bpm;if S~=P.bpm then P.bpm=S;return tostring(S)end end},measure={'#MEASURE ',false,function(R)local S,T=B(R.bpm*R.mspermeasure/240000)local U=S..'/'..T;if U~=P.measure then P.measure=U;return U end end},gogo={'#GOGO',false,function(R)local S=R.gogo;if S~=P.gogo then P.gogo=S;if S then return'START'else return'END'end end end},delay={'#DELAY ',nil,function(R)if R.delay~=P.delay then local S=R.delay-P.delay;P.delay=R.delay;return z(MsToS(S))end end}}for i=1,#G.Data do local R=G.Data[i]local S=R.ms;if R.data=='note'then M[#M+1]=R elseif R.data=='event'and R.event=='barline'then M.startms=R.ms;M[#M+1]=R end;local T=G.Data[i+1]if(T and T.data=='event'and T.event=='barline')or(i==#G.Data)then if#M==0 then error('No barline')else local U={}for i=2,#M do local Y=M[i-1]local Z=M[i]U[#U+1]=math.abs(Z.ms-Y.ms)end;U[#U+1]=math.abs((M.startms+M[1].mspermeasure)-M[#M].ms)local V=U[1]for i=2,#U do V=A(V,U[i])end;if V==nil then error('gcd invalid, probably delay')V=M[1]and(M[1].ms-O)end;local W=M.startms;local X=W+M[1].mspermeasure;for i2=1,#M do local Y=M[i2]for Z,ab in pairs(Q)do if Y[Z]==ab[2]then else local bb=ab[3](Y)if bb then ab[2]=bb;if H[#H]~='\n'then H[#H+1]='\n'end;H[#H+1]=ab[1]H[#H+1]=bb;H[#H+1]='\n'end end end;if i2 ~=1 then H[#H+1]=tostring(Y.type)end;if i2 ==1 and#M~=1 then H[#H+1]=string.rep('0',( (M[i2 +1]and M[i2 +1].ms or X)-Y.ms)/V)else H[#H+1]=string.rep('0',( (M[i2 +1]and M[i2 +1].ms or X)-Y.ms)/V-1)end end;H[#H+1]=','H[#H+1]='\n'M={}end end end;if H[#H]~='\n'then H[#H+1]='\n'end;H[#H+1]='\n#END'return table.concat(H)end;local F={'// Automatically Serialized by Taiko.SerializeTJA'}for G,H in pairs(u)do F[#F+1]=E(H)return table.concat(F,'\n\n')end;F=table.concat(F,'\n\n')return F end;function Taiko.Score(u,v,w,x,y)if x==0 then w=0 else w=w+1 end;local z=u.Metadata;return Taiko.Data.ScoreMode.Note[z.SCOREMODE](v,w,z.SCOREINIT,z.SCOREDIFF,x,y),w end;function Taiko.Analyze(u)local v='M'local w={[1]=2,[2]=2,[3]=3,[4]=3}local x={notes={n=0,validn=0},measures=0,lengthms=0,drumrollms=0,drumrollbigms=0,balloonms=0,balloonhit=0,specialms=0,specialhit=0,maxcombo=0,maxscore=0}local y=nil;Taiko.ForAll(u.Data,function(z,A,B)if z.data=='note'then x.notes.n=x.notes.n+1;x.notes[z.type]=x.notes[z.type]and x.notes[z.type]+1 or 1;if w[z.type]then x.maxscore,x.maxcombo=Taiko.Score(u,x.maxscore,x.maxcombo,w[z.type],z.gogo)end;local C=z.endnote;if C then local D=C.ms-z.ms;if z.type==5 then x.drumrollms=x.drumrollms+D elseif z.type==6 then x.drumrollbigms=x.drumrollbigms+D elseif z.type==7 then x.balloonms=x.balloonms+D;x.balloonhit=x.balloonhit+z.requiredhits elseif z.type==9 then x.specialms=x.specialms+D;x.specialhit=x.specialhit+z.requiredhits else end end;y=z elseif z.data=='event'and z.event=='barline'then x.measures=x.measures+1 else end end,v)x.lengthms=y.ms-u.Metadata.OFFSET;x.notes.validn=x.maxcombo;return x end;function Taiko.GetDifficulty(u,v)local w=Taiko.Data.CourseId[string.lower(v)]or v;for x,y in pairs(u)do if y.Metadata.COURSE==w then return y end end;Error('No difficulty found, '..v)return nil end;function Taiko.ForAll(u,v,w)local x=1;for i=1,#u do local y=u[i]if y.branch then if w then local z=y.branch.paths[w]for i2=1,#z do v(z[i2],i2,x)x=x+1 end;x=x-1 else local z=-1;for A,B in pairs(y.branch.paths)do local C=x;for i2=1,#B do v(B[i2],i2,C)C=C+1 end;z=(z<C)and C or z end;x=z end else v(y,i,x)end;x=x+1 end;return u end;function Taiko.GetAllNotes(u)local v={}for w,x in pairs(u)do if x.branch then for y,z in pairs(x.branch.paths)do for i=1,#z do table.insert(v,z[i])end end else table.insert(v,x)end end;return v end;function Taiko.ConnectNotes(u)local v=nil;for i=#u,1,-1 do local w=u[i]w.nextnote=v;v=w end;return u end;function Taiko.ExtractBranch(u,v)return u.branch.paths[v]end;function Taiko.ConnectAll(u)local v=nil;for i=#u,1,-1 do local w=u[i]if w.branch then for x,y in pairs(w.branch.paths)do local z=Taiko.ConnectNotes(y)z[#z].nextnote=v end else w.nextnote=v end;v=w end end;function Taiko.CalculateSpeed(u,v)local w=(v*u.scrollx*u.bpm/7500)local x=(v*u.scrolly*u.bpm/7500)return{w,x}end;function Taiko.CalculateSpeedAll(u,v)for i=1,#u do u[i].speed=Taiko.CalculateSpeed(u[i],v)end;return u end;function Taiko.RenderScale(u)local v={}local w={}local x={}for i=1,#u.Data do local B=u.Data[i]if B.data=='note'then local C=math.floor(B.ms)if math.floor(C)-C==0 then table.insert(v,{C,B.type})table.insert(w,C)else table.insert(x,i)end end end;function gcd2(B,C)if C==0 then return B else return gcd2(C,B%C)end end;function gcdn(B)local C=B[1]for i=2,#B do C=gcd2(C,B[i])end;return C end;local y=gcdn(w)for i=1,#x do local B=v[x[i]]B[1]=math.floor(B[1]/y)*y end;local z=''local A=0;for i=1,#v do v[i][1]=v[i][1]/y;z=z..string.rep(' ',v[i][1]-A)..v[i][2]A=v[i][1]end;return z end;function Taiko.PlaySong(u,v,w,x)local z=true;local A=nil;local B=w or{}local C={auto={[1]=false,[2]=true},notespeedmul={[1]=1,[2]=2,[3]=3,[4]=4,[5]=0.25,[6]=0.5,[7]=0.75},songspeedmul={[1]=1,[2]=2,[3]=3,[4]=4,[5]=0.25,[6]=0.5,[7]=0.75}}local D=C.auto[B[2]]or false;local E={[1]=1,[2]=2,[3]=1,[4]=2}local F=C.notespeedmul[B[3]]or 1;local G=C.songspeedmul[B[4]]or 1;local H=u.Metadata.STOPSONG;local I=true;local J=Controls2 or{}J={Hit=J.Hit or{[rl.KEY_FOUR]=2,[rl.KEY_V]=1,[rl.KEY_N]=1,[rl.KEY_EIGHT]=2},Escape=J.Escape or{[rl.KEY_ESCAPE]=true},L=J.L or{[rl.KEY_LEFT]=true,[rl.KEY_UP]=true},R=J.R or{[rl.KEY_RIGHT]=true,[rl.KEY_DOWN]=true},Select=J.Select or{[rl.KEY_ENTER]=true}}local K=x or{}K={Hit=K.Hit or{['4']=2,['v']=1,['n']=1,['8']=2},Escape=K.Escape or{['\27']=true,ALT_ESC=true},L=K.L or{KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_A2=true},R=K.R or{KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true},Select=K.Select or{KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}}local L=1;local M=2;local N='>'local O='\n\n\n'local P;if z then P=1600 else P=160 end;local Q=P;local R=P/16 *9;local S=1 /16 *P;local T=5 /16 *P;local U=1000;local V=1 /40 *P;local W=0 *P;local X=1 /16 *P;local Y=0 *P;local Z={3 /40 *P,0}Z[1]=1 /4 *P;local ab=200;local bb=ab/4;local cb=1 /40 *P;local db=20;local eb={[1]={color='red'},[2]={color='blue'},[3]={color='red'},[4]={color='blue'},[5]={color='yellow'},[6]={color='yellow'},[7]={color='cyan'}}local fb=Y+P;local gb;if z then gb={0,-R/2,Q,R/2}else gb={Y,-X*2,fb,X*2}end;local hb={gb[1]-S,gb[2]-S,gb[3]+S,gb[4]+S}local ib={gb[1]-T,gb[2]-T,gb[3]+T,gb[4]+T}local function jb(gc)return math.floor(gc+0.5)end;local function kb(gc)return gc- (math.floor(gc/360)*360)end;local function lb(gc)return(gc.data=='note')or(gc.data=='event'and gc.event=='barline')end;local function mb(gc,hc,ic,jc,kc,lc)return ic<=gc and gc<=kc and jc<=hc and hc<=lc end;local function nb(gc,hc,ic,jc,kc,lc,mc,nc)kc,lc,mc,nc=kc-gc,lc-hc,mc-gc,nc-hc;local oc=jc/ic;if jc<0 then local pc,qc=lc/oc,lc;if kc<=pc and pc<=mc then return pc,qc end else local pc,qc=nc/oc,nc;if kc<=pc and pc<=mc then return pc,qc end end;if ic<0 then local pc,qc=kc,kc*oc;if lc<=qc and qc<=nc then return pc,qc end else local pc,qc=mc,mc*oc;if lc<=qc and qc<=nc then return pc,qc end end;return nil end;local function ob(gc,hc)local ic,jc=nb(Z[1],Z[2],-gc.scrollx,-gc.scrolly,hb[1],hb[2],hb[3],hb[4])return hc- (ic~=0 and ic/-gc.speed[1]or jc/-gc.speed[2])end;local function pb(gc,hc)return Z[1]- (gc.speed[1]* (gc.ms-hc-gc.delay)),Z[2]- (gc.speed[2]* (gc.ms-hc-gc.delay))end;local qb=Taiko.GetAllNotes(u.Data)local rb=u.Metadata.OFFSET;local sb=1000 /60;local tb=u.Metadata.TIMING(sb/G)local ub={}for gc,hc in pairs(qb)do hc.ms=hc.oms or hc.ms;hc.oms=hc.ms;hc.ms=(hc.ms-rb)/G;hc.s=MsToS(hc.ms)hc.delay=hc.odelay or hc.delay;hc.odelay=hc.delay;hc.p={}hc.delay=hc.delay/G;hc.speed=Taiko.CalculateSpeed(hc,V)hc.speed[1]=hc.speed[1]*F;hc.speed[2]=hc.speed[2]*F;if hc.jposscroll then hc.jposscroll.lengthms=hc.jposscroll.olengthms or hc.jposscroll.lengthms;hc.jposscroll.olengthms=hc.jposscroll.lengthms;hc.jposscroll.lengthms=hc.jposscroll.lengthms/G end;hc.loadms=ob(hc,hc.ms)hc.loads=MsToS(hc.loadms)hc.hit=nil;hc.timeshit=nil;hc.brokecombo=false;hc.setdelay=false;ub[#ub+1]=hc.ms end;if H then for jc,kc in pairs(u.Data)do if kc.branch then for lc,mc in pairs(kc.branch.paths)do table.sort(mc,function(nc,oc)return nc.ms<oc.ms end)end end end;table.sort(u.Data,function(jc,kc)if jc.branch and kc.branch then for lc,mc in pairs(jc.branch.paths)do for nc,oc in pairs(kc.branch.paths)do return mc[1].ms<oc[1].ms end end elseif jc.branch then for lc,mc in pairs(jc.branch.paths)do return mc[1].ms<kc.ms end elseif kc.branch then for lc,mc in pairs(kc.branch.paths)do return jc.ms<mc[1].ms end else return jc.ms<kc.ms end end)local gc=nil;local hc=0;local ic={}Taiko.ForAll(u.Data,function(jc,kc,lc)if jc.delay~=hc then if gc then gc.stopms=jc.delay-gc.delay;gc.stopstart=gc.ms;gc.stopend=gc.stopstart+gc.stopms end;hc=jc.delay end;if gc and gc.delay~=0 then gc.ms=gc.ms-gc.delay;gc.s=MsToS(gc.ms)gc.loadms=ob(gc,gc.ms)gc.loads=MsToS(gc.loadms)gc.ms=gc.ms+gc.delay;gc.s=MsToS(gc.ms)end;gc=jc end)end;for gc,hc in pairs(u.Data)do if hc.branch then for ic,jc in pairs(hc.branch.paths)do table.sort(jc,function(kc,lc)return kc.loadms<lc.loadms end)end end end;table.sort(u.Data,function(gc,hc)if gc.branch and hc.branch then for ic,jc in pairs(gc.branch.paths)do for kc,lc in pairs(hc.branch.paths)do return jc[1].loadms<lc[1].loadms end end elseif gc.branch then for ic,jc in pairs(gc.branch.paths)do return jc[1].loadms<hc.loadms end elseif hc.branch then for ic,jc in pairs(hc.branch.paths)do return gc.loadms<jc[1].loadms end else return gc.loadms<hc.loadms end end)Taiko.ConnectAll(u.Data)Taiko.ForAll(u.Data,function(gc,hc,ic)gc.n=ic end)local vb=U/G;local wb=ub[1]for i=1,#ub do if ub[i]>wb then wb=ub[i]end end;wb=wb+vb;local xb={}local yb={barline={},drumroll={},notes={}}local zb={}local Ab=u.Data[1]local Bb=Ab.loads;local Cb='M'local Db=0;local Eb,Fb,Gb=u.Metadata.SCOREINIT,u.Metadata.SCOREDIFF,Taiko.Data.ScoreMode.Note[u.Metadata.SCOREMODE]local Hb=0;local Ib=false;local Jb=nil;local Kb=nil;local Lb=nil;local Mb=Taiko.Data.ScoreMode.Balloon[u.Metadata.SCOREMODE]local Nb=Taiko.Data.ScoreMode.BalloonPop[u.Metadata.SCOREMODE]local Ob=nil;local Pb=nil;local Qb=nil;local Rb=Taiko.Data.ScoreMode.Drumroll[u.Metadata.SCOREMODE]local Sb={startms=nil,status=nil}local Tb=nil;local Ub=nil;local Vb=nil;local Wb=0;local Xb=nil;local Yb=nil;local Zb={nil,nil}local ac={nil,nil}local bc={}local cc={-1,nil}local dc=0;local ec=0;local fc=true;if z then local gc='Assets/'local function hc()rl.CloseWindow()rl.CloseAudioDevice()end;local function ic(Ad)return string.reverse(string.match(string.reverse(Ad),'(.-%.)'))end;local function jc(Ad)local Bd=io.open(Ad,'rb')if Bd then Bd:close()return true else return false end end;local function kc(Ad)local Bd=io.open(Ad,'rb')if Bd then local Cd=Bd:read('*all')Bd:close()return Cd else error('Unable to find file'..Ad)end end;local function lc(Ad)return kc(gc..Ad)end;local function mc(Ad)return rl.LoadMusicStream(Ad)end;local function nc(Ad)local Bd=lc(Ad)return rl.LoadImageFromMemory(ic(Ad),Bd,#Bd)end;local function oc(Ad)local Bd=lc(Ad)return rl.LoadWaveFromMemory(ic(Ad),Bd,#Bd)end;local function pc(Ad)local Bd=oc(Ad)local Cd=rl.LoadSoundFromWave(Bd)rl.UnloadWave(Bd)return Cd end;local function qc(Ad,Bd,Cd,Dd)local Ed={}for i=Cd,Dd do Ed[i]=nc(Ad..tostring(i)..Bd)end;return Ed end;local function rc(Ad,Bd)local Cd={Ad,Bd}return Cd end;rl.SetConfigFlags(rl.FLAG_VSYNC_HINT)rl.InitWindow(Q,R,'Taiko')rl.SetExitKey(rl.KEY_NULL)local sc,tc=0,R/2;local uc=Taiko.Data.BigNoteMul;local vc=54;local wc={Z[1],Z[2]}local xc={}local yc=R/45;local zc=0.5;local Ac=60;local Bc=1000 /Ac;local Cc=require('texturemap')local Dc={Notes=nc('Graphics/5_Game/Notes.png'),ChipEffect=nc('Graphics/5_Game/ChipEffect.png'),Barlines={bar=nc('Graphics/5_Game/Bar.png'),bar_branch=nc('Graphics/5_Game/Bar_Branch.png')},Judges=nc('Graphics/5_Game/Judge.png'),Balloons={Anim=qc('Graphics/5_Game/11_Balloon/Breaking_','.png',0,5)},Effects={Hit={[1]={Anim=qc('Graphics/5_Game/10_Effects/Hit/Good/','.png',0,14)},[2]={Anim=qc('Graphics/5_Game/10_Effects/Hit/Great/','.png',0,14)},[3]={Anim=qc('Graphics/5_Game/10_Effects/Hit/Good_Big/','.png',0,14)},[4]={Anim=qc('Graphics/5_Game/10_Effects/Hit/Great_Big/','.png',0,14)}},Explosion=nc('Graphics/5_Game/10_Effects/Hit/Explosion.png'),ExplosionBig=nc('Graphics/5_Game/10_Effects/Hit/Explosion_Big.png')}}local Ec={Notes={target={0,0},[1]={1,0},[2]={2,0},[3]={3,0},[4]={4,0},drumrollnote={5,0},drumrollrect={6,0},drumrollend={7,0},DRUMROLLnote={8,0},DRUMROLLrect={9,0},DRUMROLLend={10,0},balloon={11,0},balloonend={12,0}},Barlines={bar=nil,bar_branch=nil},Judges={great={0,0},good={0,1},bad={0,2},adlib={0,3}},Effects={Explosion={[1]={Anim={[0]={0,1},[1]={1,1},[2]={2,1},[3]={3,1},[4]={4,1},[5]={5,1},[6]={6,1}}},[2]={Anim={[0]={0,0},[1]={1,0},[2]={2,0},[3]={3,0},[4]={4,0},[5]={5,0},[6]={6,0}}},[3]={Anim={[0]={0,3},[1]={1,3},[2]={2,3},[3]={3,3},[4]={4,3},[5]={5,3},[6]={6,3}}},[4]={Anim={[0]={0,2},[1]={1,2},[2]={2,2},[3]={3,2},[4]={4,2},[5]={5,2},[6]={6,2}}}}}}local Fc={130,130}local Gc={130,130}Dc.Notes=Cc.SplitUsingMap(Dc.Notes,Ec.Notes,Fc,Gc)Dc.Notes.drumrollstart=rl.ImageCopy(Dc.Notes.drumrollend)rl.ImageFlipHorizontal(Dc.Notes.drumrollstart)Dc.Notes.DRUMROLLstart=rl.ImageCopy(Dc.Notes.DRUMROLLend)rl.ImageFlipHorizontal(Dc.Notes.DRUMROLLstart)local Hc=(V*2)/ (vc*2 /uc)local function Ic(Ad)for Bd,Cd in pairs(Ad)do if type(Cd)=='table'then Cd=Ic(Cd)else rl.ImageResize(Cd,Hc*Cd.width,Hc*Cd.height)end end;return Ad end;Dc.Notes=Ic(Dc.Notes)local Jc,Kc=Dc.Notes.target.width,Dc.Notes.target.height;local Lc=rl.new('Rectangle',0,0,Jc,Kc)local Mc=rl.new('Vector2',Jc/2,Kc/2)local Nc,Oc=sc- (Jc/2),tc- (Kc/2)local Pc,Qc=1,-1;Dc.Notes=Cc.ReplaceWithTexture(Dc.Notes)Dc.Barlines=Ic(Dc.Barlines)Dc.Barlines=Cc.ReplaceWithTexture(Dc.Barlines)local Rc,Sc=Dc.Barlines.bar.width,Dc.Barlines.bar.height;local Tc=rl.new('Rectangle',0,0,Rc,Sc)local Uc=rl.new('Vector2',Rc/2,Sc/2)Dc.Balloons=Ic(Dc.Balloons)Dc.Balloons.Anim=Cc.ReplaceWithTexture(Dc.Balloons.Anim)local Vc={90,60}local Wc={90,60}Dc.Judges=Cc.SplitUsingMap(Dc.Judges,Ec.Judges,Vc,Wc)Dc.Judges=Ic(Dc.Judges)Dc.Judges=Cc.ReplaceWithTexture(Dc.Judges)local Xc=rl.new('Color',255,255,255,255 /2)Dc.Effects.Hit=Ic(Dc.Effects.Hit)local Yc=Dc.Effects.Hit[1].Anim[0]local Zc=sc- (Yc.width/2)local ad=tc- (Yc.height/2)Dc.Effects.Hit=Cc.ReplaceWithTexture(Dc.Effects.Hit)local bd={260,260}local cd={260,260}Dc.Effects.Explosion=Cc.SplitUsingMap(Dc.Effects.Explosion,Ec.Effects.Explosion,bd,cd)Dc.Effects.Explosion=Ic(Dc.Effects.Explosion)Dc.Effects.Explosion=Cc.ReplaceWithTexture(Dc.Effects.Explosion)local dd={Dc.Effects.ExplosionBig}Dc.Effects.ExplosionBig=Ic(dd)Dc.Effects.ExplosionBig={Anim={[0]=Cc.ReplaceWithTexture(dd)[1]}}local ed=u.Metadata.SONG;rl.InitAudioDevice()local fd;if ed then if jc(u.Metadata.SONG)then fd=mc(u.Metadata.SONG)rl.SetMusicVolume(fd,u.Metadata.SONGVOL)else ed=false end end;local gd={Combo={},Notes={[1]=pc('Sounds/Taiko/dong.ogg'),[2]=pc('Sounds/Taiko/ka.ogg'),adlib=pc('Sounds/Taiko/Adlib.ogg')}}for Ad,Bd in pairs(gd.Combo)do rl.SetSoundVolume(Bd,u.Metadata.SEVOL)end;for Ad,Bd in pairs(gd.Notes)do rl.SetSoundVolume(Bd,u.Metadata.SEVOL)end;local hd=false;local id;local jd='test.trp'local kd=true;local ld;local md='test.trp'local nd;local od;local pd;local qd;if hd then id={[1]={},[2]={}}end;if kd then ld,nd=l.Load(l.Read(md))local function Ad(Bd,Cd)if Bd then else error(Cd..' does not match')end end;Ad(l.Version==nd.version,'Version')Ad(u.Metadata.TITLE==nd.title,'Title')od={}for Bd,Cd in pairs(ld)do od[#od+1]=Bd end;table.sort(od)qd=1;pd=od[qd]end;Taiko.ForAll(u.Data,function(Ad,Bd,Cd)local Dd=kb(math.deg(math.atan2(-Ad.scrollx,-Ad.scrolly))-90)if Dd<90 or Dd>=270 then Ad.rotationr=Dd else Ad.rotationr=180 +Dd end;if Ad.type==3 or Ad.type==4 or Ad.type==6 then Ad.radiusr=Ad.radius/uc else Ad.radiusr=Ad.radius or 1 end;if Ad.data=='event'and Ad.event=='barline'then Ad.type='bar'Ad.pr=rl.new('Rectangle',0,0,Rc,Sc)Ad.tcenter=rl.new('Vector2',Uc.x*Ad.radiusr,Uc.y*Ad.radiusr)else Ad.pr=rl.new('Rectangle',0,0,Jc,Kc)Ad.tcenter=rl.new('Vector2',Mc.x*Ad.radiusr,Mc.y*Ad.radiusr)end;Ad.pr.width=Ad.pr.width*Ad.radiusr;Ad.pr.height=Ad.pr.height*Ad.radiusr;if Ad.startnote then local Ed=Ad.startnote;if Ed.type==5 or Ed.type==6 then Ad.rotationr=Dd;Ad.drumrollrect=rl.new('Rectangle',0,0,0,0)Ad.drumrollrect2=rl.new('Rectangle',0,0,0,0)if Ed.type==5 then Ed.notetype='drumrollnote'Ed.recttype='drumrollrect'Ed.endtype='drumrollend'elseif Ed.type==6 then Ed.notetype='DRUMROLLnote'Ed.recttype='DRUMROLLrect'Ed.endtype='DRUMROLLend'end elseif Ed.type==7 then Ad.balloonrect=rl.new('Rectangle',0,0,0,0)end end end)local rd;local sd,td={},{}local function ud(Ad)rl.PlaySound(gd.Notes[Ad])if hd then id[Ad][#id[Ad]+1]=rd end;if td[Ad]and(not td[Ad].hit)then local Bd=td[Ad]local Cd=Bd.type;local Dd=sd[Ad]local Ed;local Fd=( (Cd==3 or Cd==4)and Taiko.Data.BigLeniency)or 1;local Gd=nil;local Hd=(Cd==3 or Cd==4)if Dd< (tb.good)then Ed=(Hd and 3)or 2;Hb=Hb+1;Gd=(Hd and 4)or 2 elseif Dd< (tb.ok*Fd)then Ed=(Hd and 2)or 1;Hb=Hb+1;Gd=(Hd and 3)or 1 elseif Dd< (tb.bad*Fd)then Ed=0;Hb=0;Gd=0 else Ed=nil end;if Ed then Db=Gb(Db,Hb,Eb,Fb,Ed,Bd.gogo)td[Ad].hit=true;Sb={startms=rd,status=Gd,statusanim=Gd~=0 and Dc.Effects.Hit[Gd].Anim,explosionanim=Gd~=0 and Dc.Effects.Explosion[Gd].Anim,explosionbiganim=(Hd and Dc.Effects.ExplosionBig.Anim)or nil}end end;if(Ad==1)and Kb and(rd>Kb and rd<Lb)then Jb.timeshit=Jb.timeshit and Jb.timeshit+1 or 1;Db=Mb(Db,Jb.type,notegogo)end;if(Ad==1 or Ad==2)and Pb and(rd>Pb and rd<Qb)then Ob.timeshit=Ob.timeshit and Ob.timeshit+1 or 1;Db=Rb(Db,Ob.type,notegogo)end end;local function vd(Ad)local Bd=E[Ad.type]sd[Bd]=0;td[Bd]=Ad;ud(Bd)end;local function wd(Ad,Bd)return Ad.ms>Bd.ms end;local xd=table.concat({'Title: ',u.Metadata.TITLE,'\nSubtitle: ','','\nDifficulty: ',Taiko.Data.CourseName[u.Metadata.COURSE],'\nStars: ',tostring(u.Metadata.LEVEL),'\n\nAuto: ',tostring(D),'\nRecording: ',tostring(hd),'\nReplaying: ',tostring(kd)})local yd={'Combo: ','','\nScore: ',''}while not rl.WindowShouldClose()do rl.BeginDrawing()rl.ClearBackground(rl.RAYWHITE)rl.DrawText('Press SPACE to start',Q/2,R/2,50,rl.BLACK)rl.EndDrawing()if rl.IsKeyPressed(32)then break end end;if ed then rl.SetMusicPitch(fd,G)rl.PlayMusicStream(fd)end;local zd=os.clock()while true do if ed then rl.UpdateMusicStream(fd)end;rl.BeginDrawing()rl.ClearBackground(rl.RAYWHITE)rl.DrawFPS(10,10)rl.DrawText(xd,10,40,yc,rl.BLACK)rl.DrawText(table.concat(yd),10,R- (yc*5),yc,rl.BLACK)local Ad=os.clock()local Bd=Ad-zd;rd=Bd*1000;if ed then local Fd=Bd- (rl.GetMusicTimePlayed(fd)/G)if Fd>zc or Fd<-zc then print('RESYNC',Fd)rl.SeekMusicStream(fd,Bd*G)end end;if kd and pd and rd>=pd then local Fd=ld[pd]for i=1,#Fd do ud(tonumber(Fd[i]))end;qd=qd+1;pd=od[qd]end;if Vb and rd>Vb then Tb,Ub,Vb=nil,nil,nil end;if Lb and rd>Lb then Jb,Kb,Lb=nil,nil,nil end;if Qb and rd>Qb then Ob,Pb,Qb=nil,nil,nil end;if I then for i=1,#bc do local Fd=bc[i]if(Fd.jposscroll and(rd>=Fd.ms))then Xb=Fd.ms;Yb=Fd.ms+Fd.jposscroll.lengthms;if Fd.jposscroll.p=='default'then Zb[1]=(wc[1]-Z[1])/Fd.jposscroll.lengthms;Zb[2]=(wc[2]-Z[2])/Fd.jposscroll.lengthms else Zb[1]=( (Fd.jposscroll.p and Fd.jposscroll.p[1])and Fd.jposscroll.p[1]or(Fd.jposscroll.lanep and Fd.jposscroll.lanep[1])and(Fd.jposscroll.lanep[1]*P)or 0)/Fd.jposscroll.lengthms;Zb[2]=( (Fd.jposscroll.p and Fd.jposscroll.p[2])and Fd.jposscroll.p[2]or(Fd.jposscroll.lanep and Fd.jposscroll.lanep[2])and(Fd.jposscroll.lanep[2]*P)or 0)/Fd.jposscroll.lengthms end;ac[1]=Z[1]ac[2]=Z[2]table.remove(bc,i)break end end;if Yb and rd>Yb then local Fd=Yb-Xb;Z[1]=ac[1]+ (Zb[1]*Fd)Z[2]=ac[2]+ (Zb[2]*Fd)Xb,Yb=nil,nil end end;if Ab then while true do if Ab and Ab.loadms<rd+Wb then xb[#xb+1]=Ab;if Ab.endnote then xb[#xb+1]=Ab.endnote end;Ab=Ab.nextnote;if Ab then if Ab.startnote then Ab=Ab.nextnote end;if Ab and Ab.branch then Ab=Ab.branch.paths[Cb][1]end end else break end end else if rd>wb then break end end;if Xb and rd>=Xb then Z[1]=ac[1]+ (Zb[1]* (rd-Xb))Z[2]=ac[2]+ (Zb[2]* (rd-Xb))end;local Cd=Z[1]-wc[1]local Dd=Z[2]-wc[2]xc[1]=ib[1]+Cd;xc[2]=ib[2]+Dd;xc[3]=ib[3]+Cd;xc[4]=ib[4]+Dd;rl.DrawTexture(Dc.Notes.target,jb(Z[1]*Pc)+Nc,jb(Z[2]*Qc)+Oc,rl.WHITE)sd={}td={}yb={barline={},drumroll={},balloon={},notes={}}local Ed=0;for i=1,#xb do local Fd=i+Ed;local Gd=xb[Fd]if Gd then if not(Gd.hit)and Gd.data=='note'then if(Gd.type==1 or Gd.type==3)and(not sd[1]or math.abs(rd-Gd.ms)<sd[1])then sd[1]=math.abs(rd-Gd.ms)td[1]=Gd elseif(Gd.type==2 or Gd.type==4)and(not sd[2]or math.abs(rd-Gd.ms)<sd[2])then sd[2]=math.abs(rd-Gd.ms)td[2]=Gd end end;local Hd,Id=pb(Gd,Tb or(rd+Wb))Gd.p[1]=Hd*Pc;Gd.p[2]=Id*Qc;if rd>Gd.ms then Ib=Gd.gogo;if Gd.type==7 then if Jb then if Jb.n==Gd.n then Gd.p[1]=Z[1]Gd.p[2]=Z[2]if not Jb.setdelay then Jb.delay=Jb.delay-Jb.lengthms;Jb.setdelay=true end else end end;Jb=Gd;Kb=Gd.ms;Lb=Gd.ms+Gd.lengthms elseif Gd.type==5 or Gd.type==6 then Ob=Gd;Pb=Gd.ms;Qb=Gd.ms+Gd.lengthms end end;Gd.pr.x=jb(Gd.p[1])+sc;Gd.pr.y=jb(Gd.p[2])+tc;if H and Gd.stopstart and rd>Gd.stopstart then Tb=Wb+Gd.stopstart;stopms=Gd.stopms;Wb=Wb-Gd.stopms;Ub=Gd.stopstart;Vb=Gd.stopend;Gd.stopstart=nil end;if D then if not Gd.hit and E[Gd.type]and rd>=Gd.ms then vd(Gd)end end;if(I)and Gd.jposscroll and(not Gd.jposscrolldone)then bc[#bc+1]=Gd;Gd.jposscrolldone=true end;if(Gd.hit and not(H and Gd.stopstart and not(rd>Gd.stopstart)))or(rd>Gd.ms and mb(Gd.p[1],Gd.p[2],xc[1],xc[2],xc[3],xc[4])==false)then Gd.done=true;table.remove(xb,Fd)Ed=Ed-1 else if Gd.data=='event'then if Gd.event=='barline'then yb.barline[#yb.barline+1]=Gd end else if Gd.type==8 then yb.drumroll[#yb.drumroll+1]=Gd elseif Gd.type==7 then yb.balloon[#yb.balloon+1]=Gd else yb.notes[#yb.notes+1]=Gd end end end end end;if D then local Fd=sd[1]local Gd=sd[2]local Hd=(Fd and Gd)and( (Fd<Gd)and 1 or 2)or(Fd and 1 or 2)local Id=sd[Hd]local Jd=td[Hd]if not Id or(Id and Id> (tb.bad* ( ( (Jd.type==3 or Jd.type==4)and Taiko.Data.BigLeniency)or 1)))then if Kb and(rd>Kb and rd<Lb)then ud(1)elseif Pb and(rd>Pb and rd<Qb)then ud(1)end end end;for Fd,Gd in pairs(J.Hit)do if rl.IsKeyPressed(Fd)then ud(Gd)end end;yd[2]=tostring(Hb)yd[4]=tostring(Db)zb=yb.barline;table.sort(yb.drumroll,wd)table.sort(yb.notes,wd)table.sort(yb.balloon,wd)for i=1,#yb.drumroll do zb[#zb+1]=yb.drumroll[i]end;for i=1,#yb.notes do zb[#zb+1]=yb.notes[i]end;for i=1,#yb.balloon do zb[#zb+1]=yb.balloon[i]end;if Sb.statusanim then local Fd=rd-Sb.startms;local Gd=math.floor(Fd/Bc)local Hd=Sb.statusanim[Gd]if Hd then rl.DrawTexture(Hd,jb(Z[1]*Pc)+Zc,jb(Z[2]*Qc)+ad,Xc)else Sb.statusanim=nil end end;for i=1,#zb do local Fd=zb[i]if Fd then if not Fd.hit then local Gd=( (notetype==3 or notetype==4)and Taiko.Data.BigLeniency)or 1;if(not Fd.brokecombo)and(Fd.type==1 or Fd.type==2 or Fd.type==3 or Fd.type==4)and rd-Fd.ms> (tb.bad*Gd)then Hb=0;Fd.brokecombo=true end;if fc then if Fd.data=='event'then if Fd.event=='barline'then rl.DrawTexturePro(Dc.Barlines[Fd.type],Tc,Fd.pr,Fd.tcenter,Fd.rotationr,rl.WHITE)end elseif Fd.data=='note'then if Dc.Notes[Fd.type]then rl.DrawTexturePro(Dc.Notes[Fd.type],Lc,Fd.pr,Fd.tcenter,Fd.rotationr,rl.WHITE)elseif Fd.type==8 then local Hd=Fd.startnote;if Hd.type==5 or Hd.type==6 then local Id=V*Fd.radius;local Jd,Kd=Hd.p[1],Fd.p[1]local Ld,Md=Hd.p[2],Fd.p[2]if jb(Kd-Jd)~=0 or jb(Md-Ld)~=0 then local Nd=Hd.scrollx>0;local Od=Hd.scrolly<=0;local Pd=Dc.Notes.drumrollrect.width;local Qd=Dc.Notes.drumrollrect.height;local Rd=math.sqrt((Kd-Jd)^2 + (Md-Ld)^2)local Sd=(Kd-Jd)/Rd;local Td=(Md-Ld)/Rd;local Ud=Pd*Sd;local Vd=Pd*Td;local Wd=Fd.tcenter.x*Sd;local Xd=Fd.tcenter.y*Td;Kd=Kd-Wd;Md=Md-Xd;Rd=math.sqrt((Kd-Jd)^2 + (Md-Ld)^2)local Yd=math.floor(Rd/Pd)local Zd=Rd- (Yd*Pd)local ae=Zd*Sd;local be=Zd*Td;Fd.drumrollrect.width=Pd;Fd.drumrollrect.height=Qd;local ce=Jd+sc+Wd;local de=Ld+tc+Xd;for i=1,Yd do Fd.drumrollrect.x=ce;Fd.drumrollrect.y=de;rl.DrawTexturePro(Dc.Notes[Hd.recttype],Lc,Fd.drumrollrect,Fd.tcenter,Fd.rotationr,rl.WHITE)ce=ce+Ud;de=de+Vd end;Fd.drumrollrect.width=Zd;Fd.drumrollrect.x=ce;Fd.drumrollrect.y=de;Fd.drumrollrect2.x=0;Fd.drumrollrect2.y=0;Fd.drumrollrect2.width=Fd.drumrollrect.width;Fd.drumrollrect2.height=Fd.drumrollrect.height;rl.DrawTexturePro(Dc.Notes[Hd.recttype],Fd.drumrollrect2,Fd.drumrollrect,Fd.tcenter,Fd.rotationr,rl.WHITE)ce=ce+ae;de=de+be;rl.DrawTexturePro(Dc.Notes[Hd.endtype],Lc,Fd.pr,Fd.tcenter,Fd.rotationr,rl.WHITE)end;rl.DrawTexturePro(Dc.Notes[Hd.notetype],Lc,Hd.pr,Hd.tcenter,Hd.rotationr,rl.WHITE)elseif Hd.type==7 then if Hd.timeshit==nil or Hd.timeshit==0 then rl.DrawTexturePro(Dc.Notes.balloon,Lc,Hd.pr,Hd.tcenter,Hd.rotationr,rl.WHITE)Hd.pr.x=Hd.pr.x+Hd.pr.width;rl.DrawTexturePro(Dc.Notes.balloonend,Lc,Hd.pr,Hd.tcenter,Hd.rotationr,rl.WHITE)else end end end else error('Invalid note.data')end end end end end;if Sb.explosionanim then local Fd=rd-Sb.startms;local Gd=math.floor(Fd/Bc)local Hd=Sb.explosionanim[Gd]if Hd then rl.DrawTexture(Hd,jb(Z[1]*Pc)+Zc,jb(Z[2]*Qc)+ad,Xc)else Sb.explosionanim=nil end end;if Sb.explosionbiganim then local Fd=rd-Sb.startms;local Gd=math.floor(Fd/Bc)local Hd=Sb.explosionbiganim[Gd]if Hd then rl.DrawTexture(Hd,jb(Z[1]*Pc)+Zc,jb(Z[2]*Qc)+ad,Xc)else Sb.explosionbiganim=nil end end;rl.EndDrawing()if rl.WindowShouldClose()then rl.CloseWindow()break end end;if hd then id=l.Save(l.TranscodeRawKey(id),{'\ntitle ',u.Metadata.TITLE,'\nsubtitle ','','\ndifficulty ',Taiko.Data.CourseName[u.Metadata.COURSE],'\nstars ',tostring(u.Metadata.LEVEL),'\ntime ',tostring(os.time())})l.Write(jd,id)end;return true else local gc=v or{window=curses.initscr()}curses.keypad(gc,true)curses.echo(false)curses.raw(true)curses.nl(false)curses.cbreak(true)curses.nodelay(gc,true)local hc={[0]={Data={[1]={'0','1','1','1','1','1','1','1'},[2]={[2]='1',[5]='1',[8]='1'},[3]={[2]='1',[5]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={[3]='1',[4]='1',[6]='1',[7]='1'},[8]={'0','0','1','1','1','1','1','1'},[9]={[2]='1',[5]='1'},[10]={[2]='1',[5]='1'},[11]={[2]='1',[5]='1'},[12]={[2]='1',[5]='1'},[13]={'0','0','1','1','1','1','1','1'},[15]={'0','1','1','1','1','1','1','1'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'}},Color={All='blue'},Offset={-1,0}},[1]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[8]='1'},[5]={[2]='1',[8]='1'},[6]={'0','0','1','1','1','1','1','0'},[8]={'0','1','1','1','1','1','1','1'},[9]={[5]='1'},[10]={[4]='1',[6]='1'},[11]={[3]='1',[7]='1'},[12]={[2]='1',[8]='1'}},Color={All='white'},Offset={-1,0}},[2]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={'0','1','0','0','1','1','1','1'},[8]={'0','0','1','1','1','1','1','0'},[9]={[2]='1',[8]='1'},[10]={[2]='1',[8]='1'},[11]={[2]='1',[8]='1'},[12]={[2]='1',[8]='1'},[13]={'0','0','1','1','1','1','1','0'},[15]={'0','0','1','1','1','1','1','0'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'},[22]={'0','1','1','1','1','1','1','1'},[23]={[2]='1',[8]='1'},[24]={[2]='1',[8]='1'},[25]={[2]='1',[8]='1'},[26]={[2]='1',[8]='1'},[27]={'0','0','1','1','1','1','1','0'}},Color={All='yellow'},Offset={-1,0}},Size={27,8}}hc[3]=hc[2]local ic={[0]=nil,[1]={},[2]={}}local jc;os.execute('chcp 65001')jc={}local kc=([[
⠀ ⢀ ⠠ ⢠ ⠐ ⢐ ⠰ ⢰ ⠈ ⢈ ⠨ ⢨ ⠘ ⢘ ⠸ ⢸
⡀ ⣀ ⡠ ⣠ ⡐ ⣐ ⡰ ⣰ ⡈ ⣈ ⡨ ⣨ ⡘ ⣘ ⡸ ⣸
⠄ ⢄ ⠤ ⢤ ⠔ ⢔ ⠴ ⢴ ⠌ ⢌ ⠬ ⢬ ⠜ ⢜ ⠼ ⢼
⡄ ⣄ ⡤ ⣤ ⡔ ⣔ ⡴ ⣴ ⡌ ⣌ ⡬ ⣬ ⡜ ⣜ ⡼ ⣼
⠂ ⢂ ⠢ ⢢ ⠒ ⢒ ⠲ ⢲ ⠊ ⢊ ⠪ ⢪ ⠚ ⢚ ⠺ ⢺
⡂ ⣂ ⡢ ⣢ ⡒ ⣒ ⡲ ⣲ ⡊ ⣊ ⡪ ⣪ ⡚ ⣚ ⡺ ⣺
⠆ ⢆ ⠦ ⢦ ⠖ ⢖ ⠶ ⢶ ⠎ ⢎ ⠮ ⢮ ⠞ ⢞ ⠾ ⢾
⡆ ⣆ ⡦ ⣦ ⡖ ⣖ ⡶ ⣶ ⡎ ⣎ ⡮ ⣮ ⡞ ⣞ ⡾ ⣾
⠁ ⢁ ⠡ ⢡ ⠑ ⢑ ⠱ ⢱ ⠉ ⢉ ⠩ ⢩ ⠙ ⢙ ⠹ ⢹
⡁ ⣁ ⡡ ⣡ ⡑ ⣑ ⡱ ⣱ ⡉ ⣉ ⡩ ⣩ ⡙ ⣙ ⡹ ⣹
⠅ ⢅ ⠥ ⢥ ⠕ ⢕ ⠵ ⢵ ⠍ ⢍ ⠭ ⢭ ⠝ ⢝ ⠽ ⢽
⡅ ⣅ ⡥ ⣥ ⡕ ⣕ ⡵ ⣵ ⡍ ⣍ ⡭ ⣭ ⡝ ⣝ ⡽ ⣽
⠃ ⢃ ⠣ ⢣ ⠓ ⢓ ⠳ ⢳ ⠋ ⢋ ⠫ ⢫ ⠛ ⢛ ⠻ ⢻
⡃ ⣃ ⡣ ⣣ ⡓ ⣓ ⡳ ⣳ ⡋ ⣋ ⡫ ⣫ ⡛ ⣛ ⡻ ⣻
⠇ ⢇ ⠧ ⢧ ⠗ ⢗ ⠷ ⢷ ⠏ ⢏ ⠯ ⢯ ⠟ ⢟ ⠿ ⢿
⡇ ⣇ ⡧ ⣧ ⡗ ⣗ ⡷ ⣷ ⡏ ⣏ ⡯ ⣯ ⡟ ⣟ ⡿ ⣿]]):gsub('\n',' ')function GenerateDotData()function ToBinary(Oc)local Pc={}while Oc>0 do local Rc=math.fmod(Oc,2)Pc[#Pc+1]=string.sub(Rc,1,1)Oc=(Oc-Rc)/2 end;local Qc=string.reverse(table.concat(Pc))return string.rep('0',8 -#Qc)..Qc end;local function Ic(Oc)return Oc end;local Jc=Split(kc,' ')local Kc={}local Lc=false;local Mc=''local Nc=' 'for i=1,#Jc do Kc[i-1]=Ic(Jc[i])end;return Kc end;jc.Data={}jc.Data.Dot=GenerateDotData()jc.ColorData={reset=0,clear=0,space=0,bright=1,bold=1,dim=2,faint=1,italic=3,underline=4,blink=5,reverse=7,invisible=8,hidden=8,strikethrough=9,black=30,red=31,green=32,yellow=33,blue=34,purple=35,magenta=35,cyan=36,white=37,onblack=40,onred=41,ongreen=42,onyellow=43,onblue=44,onpurple=45,onmagenta=45,oncyan=46,onwhite=47}jc.Color={}for Ic,Jc in pairs(jc.ColorData)do jc.Color[Ic]='\27['..Jc..'m'end;local lc,mc=gb[1],gb[3]local nc,oc=-gb[4],-gb[2]jc.Convert={}jc.Convert.ToDots=function(Ic)local Jc,Kc=Ic.Data,Ic.Color;local Lc={}local Mc=0;local Nc=jc.Data.Dot[Mc]local Oc=nil;local Pc=nil;local Qc=jc.Color['reset']if Ic.Color.All then local Rc=jc.Color[Ic.Color.All]Lc[#Lc+1]=Rc;Pc=Rc end;if not nc then return''end;for y=oc,nc,-4 do for x=lc,mc,2 do local Rc=Jc[x]local Sc=Jc[x+1]local Tc=(Rc and( (Rc[y]or 0)*128 + (Rc[y-1]or 0)*64 + (Rc[y-2]or 0)*32 + (Rc[y-3]or 0)*16)or 0)+ (Sc and( (Sc[y]or 0)*8 + (Sc[y-1]or 0)*4 + (Sc[y-2]or 0)*2 + (Sc[y-3]or 0))or 0)if Tc~=Mc then Tc=jc.Data.Dot[Tc]if not Pc then local Uc=Kc[x]local Vc=Kc[x+1]local Wc=( (Uc)and(Uc[y]or Uc[y-1]or Uc[y-2]or Uc[y-3]))or( (Vc)and(Vc[y]or Vc[y-1]or Vc[y-2]or Vc[y-3]))if Wc then Wc=jc.Color[Wc]else Wc=Qc end;if Oc==Wc then else Lc[#Lc+1]=Wc;Oc=Wc end end;Lc[#Lc+1]=Tc else Lc[#Lc+1]=Nc end end;Lc[#Lc+1]='\n'end;Lc[#Lc+1]=Qc;return table.concat(Lc)end;jc.ToDotsParallel=function(Ic,Jc)local Kc,Lc=Ic.Data,Ic.Color;local Mc,Nc=Jc.Data,Jc.Color;local Oc={}local Pc=0;local Qc=jc.Data.Dot[Pc]local Rc=nil;local Sc=nil;local Tc=jc.Color['reset']if Ic.Color.All then local Uc=jc.Color[Ic.Color.All]Oc[#Oc+1]=Uc;Sc=Uc end;if not nc then return''end;for y=oc,nc,-4 do for x=lc,mc,2 do local Uc=Kc[x]local Vc=Kc[x+1]local Wc=Mc[x]local Xc=Mc[x+1]local Yc=( (Uc and Wc)and( (Uc[y]or Wc[y]or 0)*128 + (Uc[y-1]or Wc[y-1]or 0)*64 + (Uc[y-2]or Wc[y-2]or 0)*32 + (Uc[y-3]or Wc[y-3]or 0)*16)or(Uc)and( (Uc[y]or 0)*128 + (Uc[y-1]or 0)*64 + (Uc[y-2]or 0)*32 + (Uc[y-3]or 0)*16)or(Wc)and( (Wc[y]or 0)*128 + (Wc[y-1]or 0)*64 + (Wc[y-2]or 0)*32 + (Wc[y-3]or 0)*16)or 0)+ ( (Vc and Xc)and( (Vc[y]or Xc[y]or 0)*8 + (Vc[y-1]or Xc[y-1]or 0)*4 + (Vc[y-2]or Xc[y-2]or 0)*2 + (Vc[y-3]or Xc[y-3]or 0))or(Vc)and( (Vc[y]or 0)*8 + (Vc[y-1]or 0)*4 + (Vc[y-2]or 0)*2 + (Vc[y-3]or 0))or(Xc)and( (Xc[y]or 0)*8 + (Xc[y-1]or 0)*4 + (Xc[y-2]or 0)*2 + (Xc[y-3]or 0))or 0)if Yc~=Pc then Yc=jc.Data.Dot[Yc]if not Sc then local Zc=Nc[x]local ad=Nc[x+1]local bd=Lc[x]local cd=Lc[x+1]local dd=bd and(bd[y]or bd[y-1]or bd[y-2]or bd[y-3])or cd and(cd[y]or cd[y-1]or cd[y-2]or cd[y-3])or Zc and(Zc[y]or Zc[y-1]or Zc[y-2]or Zc[y-3])or ad and(ad[y]or ad[y-1]or ad[y-2]or ad[y-3])if dd then dd=jc.Color[dd]else dd=Tc end;if Rc==dd then else Oc[#Oc+1]=dd;Rc=dd end end;Oc[#Oc+1]=Yc else Oc[#Oc+1]=Qc end end;Oc[#Oc+1]='\n'end;Oc[#Oc+1]=Tc;return table.concat(Oc)end;jc.CircleGen=function(Ic,Jc,Kc,Lc,Mc)Mc=Mc or{}local Nc=Mc.color;local Oc=Lc*Lc;local Pc=Lc;for y=0,Lc do Pc=Pc+1;repeat Pc=Pc-1 until Pc*Pc+y*y<=Oc;for x2=0,Pc do Ic.Data[Jc+x2]=Ic.Data[Jc+x2]or{}Ic.Data[Jc-x2]=Ic.Data[Jc-x2]or{}Ic.Data[Jc+x2][Kc+y]='1'Ic.Data[Jc-x2][Kc+y]='1'Ic.Data[Jc+x2][Kc-y]='1'Ic.Data[Jc-x2][Kc-y]='1'Ic.Color[Jc+x2]=Ic.Color[Jc+x2]or{}Ic.Color[Jc-x2]=Ic.Color[Jc-x2]or{}Ic.Color[Jc+x2][Kc+y]=Nc;Ic.Color[Jc-x2][Kc+y]=Nc;Ic.Color[Jc+x2][Kc-y]=Nc;Ic.Color[Jc-x2][Kc-y]=Nc end end;return Ic end;local pc={}jc.Circle=function(Ic,Jc,Kc,Lc,Mc)local Nc=nil;if pc[Lc]then else pc[Lc]=jc.CircleGen(jc.New(),0,0,Lc)end;local Oc=Mc and Mc.color;Nc=pc[Lc]for Pc,Qc in pairs(Nc.Data)do for Rc,Sc in pairs(Qc)do local Tc,Uc=Pc+Jc,Rc+Kc;Ic.Data[Tc]=Ic.Data[Tc]or{}Ic.Data[Tc][Uc]=Sc;Ic.Color[Tc]=Ic.Color[Tc]or{}Ic.Color[Tc][Uc]=Oc end end;return Ic end;jc.New=function()return{Data={},Color={}}end;local function qc(Ic,Jc)local Kc=math.floor(Jc.p[1])local Lc=math.floor(Jc.p[2])local Mc,Nc=Lc-X,Lc+X;for y=Mc,Nc do Ic.Data[Kc]=Ic.Data[Kc]or{}Ic.Data[Kc][y]='1'end end;local function rc(Ic,Jc,Kc)Kc=Kc or Jc.p;jc.Circle(Ic,math.floor(Kc[1]),math.floor(Kc[2]),V*Jc.radius,eb[Jc.type])end;local function sc(Ic,Jc,Kc,Lc,Mc,Nc)Jc=math.floor(Jc)Kc=math.floor(Kc)Lc=math.floor(Lc)Mc=math.floor(Mc)local Oc=Nc or{}color=Oc.color;for y=Kc,Mc do for x=Jc,Lc do Ic.Data[x]=Ic.Data[x]or{}Ic.Data[x][y]='1'if color then Ic.Color[x]=Ic.Color[x]or{}Ic.Color[x][y]=color end end end end;local function tc(Ic,Jc,Kc)local Lc=Jc.type;if Lc==1 or Lc==2 or Lc==3 or Lc==4 then rc(Ic,Jc)elseif Lc==5 or Lc==6 then elseif Lc==7 then Jc.radius=0.8;rc(Ic,Jc)elseif Lc==8 then rc(Ic,Jc)local Mc=Jc.startnote;rc(Ic,Mc)local Nc=V*Jc.radius;local Oc,Pc=math.floor(Mc.p[1]),math.floor(Jc.p[1])rc(Ic,Mc,Jc.p)local Qc=math.floor(W-Nc)local Rc=math.floor(W+Nc)if Kc then else if Oc>Pc then Oc,Pc=Pc,Oc end;if Oc<hb[1]then Oc=hb[1]end;if Pc>hb[3]then Pc=hb[3]end end;sc(Ic,Oc,Qc,Pc,Rc,eb[Mc.type])end end;local function uc(Ic,Jc,Kc)local Lc=cb/ (bb/2)local Mc=-Lc*math.abs(( (Kc-Jc.startms)/ (ab/bb))- (cb/Lc))+cb;local Nc=hc[Jc.status]local Oc=Nc.Offset;local Pc=Nc.Color.All;local Qc,Rc=0,-math.floor(V*Taiko.Data.BigNoteMul)-8 -math.floor(Mc)local Sc,Tc=Oc[1]+Qc,Oc[2]+Rc;for x=1,hc.Size[1]do for y=1,hc.Size[2]do local Uc,Vc=x+Sc,y+Tc;Ic.Data[Uc]=Ic.Data[Uc]or{}Ic.Data[Uc][-Vc]=Nc.Data[x]and Nc.Data[x][y]Ic.Color[Uc]=Ic.Color[Uc]or{}Ic.Color[Uc][-Vc]=Pc end end end;local function vc(Ic,Jc)local Kc=ic[Jc.status]local Lc=Kc.Offset;local Mc=Kc.Color.All;local Nc,Oc=0,0;for Pc,Qc in pairs(Kc.Data)do for Rc,Sc in pairs(Qc)do if Sc=='1'then local Tc,Uc=Pc+Lc[1]+Nc,Rc+Lc[2]+Oc;Ic.Data[Tc]=Ic.Data[Tc]or{}Ic.Data[Tc][Uc]=Sc;Ic.Color[Tc]=Ic.Color[Tc]or{}Ic.Color[Tc][Uc]=Mc end end end end;local wc={ClearScreen=function()io.write("\27[2J")end,SetCursor=function(Ic,Jc)io.write(string.format("\27[%d;%dH",Jc,Ic))end}local xc=10;local yc=string.rep(' ',xc)local zc={}local function Ac(Ic,Jc)zc[#zc+1]=Ic;zc[#zc+1]=': 'zc[#zc+1]=tostring(Jc)zc[#zc+1]=yc;zc[#zc+1]='\n'end;local function Bc()print(table.concat(zc))zc={}end;local Cc={}local function Dc(Ic)Cc[#Cc+1]=Ic end;local function Ec()print(table.concat(Cc,'\n'))Cc={}end;wc.ClearScreen()local Fc=os.clock()local Gc,Hc;if A then Gc=1 /A;Hc=Fc+Gc end;while true do local Ic=jc.New()local Jc=os.clock()local Kc=Jc-Fc;local Lc=Kc*1000;if Vb and Lc>Vb then Tb,Ub,Vb=nil,nil,nil end;if Lb and Lc>Lb then Jb,Kb,Lb=nil,nil,nil end;if Qb and Lc>Qb then Ob,Pb,Qb=nil,nil,nil end;if Ab then while true do if Ab and Ab.loadms<Lc+Wb then xb[#xb+1]=Ab;if Ab.endnote then xb[#xb+1]=Ab.endnote end;Ab=Ab.nextnote;if Ab then if Ab.startnote then Ab=Ab.nextnote end;if Ab and Ab.branch then Ab=Ab.branch.paths[Cb][1]end end else break end end else if Lc>wb then break end end;jc.Circle(Ic,math.floor(Z[1]),math.floor(Z[2]),V,{color='purple'})local Mc={}local Nc={}local Oc=0;for i=1,#xb do local Tc=i+Oc;local Uc=xb[Tc]if Uc then if not(Uc.hit)and Uc.data=='note'then if(Uc.type==1 or Uc.type==3)and(not Mc[1]or math.abs(Lc-Uc.ms)<Mc[1])then Mc[1]=math.abs(Lc-Uc.ms)Nc[1]=Uc elseif(Uc.type==2 or Uc.type==4)and(not Mc[2]or math.abs(Lc-Uc.ms)<Mc[2])then Mc[2]=math.abs(Lc-Uc.ms)Nc[2]=Uc end end;local Vc,Wc=pb(Uc,Tb or(Lc+Wb))Uc.p[1]=Vc;Uc.p[2]=Wc;if Lc>Uc.ms then Ib=Uc.gogo;if Uc.type==7 then if Jb then if Jb.n==Uc.n then Uc.p[1]=Z else end end;Jb=Uc;Kb=Uc.ms;Lb=Uc.ms+Uc.lengthms elseif Uc.type==5 or Uc.type==6 then Ob=Uc;Pb=Uc.ms;Qb=Uc.ms+Uc.lengthms end end;if H and Uc.stopstart and Lc>Uc.stopstart then Tb=Wb+Uc.stopstart;stopms=Uc.stopms;Wb=Wb-Uc.stopms;Ub=Uc.stopstart;Vb=Uc.stopend;Uc.stopstart=nil end;if D then if not Uc.hit and E[Uc.type]and Lc>=Uc.ms then local Xc;Xc=( (notetype==3 or notetype==4)and 3)or 2;Hb=Hb+1;if Xc then Db=Gb(Db,Hb,Eb,Fb,Xc,Uc.gogo)Uc.hit=true;Sb={startms=Lc,status=Xc}end end end;if(Uc.hit and not(H and Uc.stopstart and not(Lc>Uc.stopstart)))or mb(Uc.p[1],Uc.p[2],ib[1],ib[2],ib[3],ib[4])==false and(not(Uc.type==8 and Lc<Uc.ms))then Uc.done=true;table.remove(xb,Tc)Oc=Oc-1 else if not Uc.hit then local Xc=( (notetype==3 or notetype==4)and Taiko.Data.BigLeniency)or 1;if(Uc.type==1 or Uc.type==2 or Uc.type==3 or Uc.type==4)and Lc-Uc.ms> (tb.bad*Xc)then Hb=0 end;if fc then if Uc.data=='event'then if Uc.event=='barline'then qc(Ic,Uc)end elseif Uc.data=='note'then tc(Ic,Uc)else error('Invalid note.data')end end end end end end;if Sb.status then if Lc>Sb.startms+ab then Sb={}else uc(Ic,Sb,Lc,0)end end;wc.SetCursor(1,1)if A then local Tc=jc.Convert.ToDots(Ic)repeat until os.clock()>=Hc;Hc=Hc+Gc;print(Tc)else print(jc.Convert.ToDots(Ic))end;dc=dc+1;local Pc=os.clock()-Jc;ec=ec+Pc;local Qc=curses.getch(gc)local Rc=curses.getkeyname(Qc)local Sc=K.Hit[Rc]if D then local Tc=Mc[1]local Uc=Mc[2]local Vc=(Tc and Uc)and( (Tc<Uc)and 1 or 2)or(Tc and 1 or 2)local Wc=Mc[Vc]local Xc=Nc[Vc]if not Wc or(Wc and Wc> (tb.bad* ( ( (Xc.type==3 or Xc.type==4)and Taiko.Data.BigLeniency)or 1)))then if Kb and(Lc>Kb and Lc<Lb)then Sc=1 elseif Pb and(Lc>Pb and Lc<Qb)then Sc=1 end end end;if Sc then if Mc[Sc]and(not Nc[Sc].hit)then local Tc=Nc[Sc]local Uc=Tc.type;local Vc=Mc[Sc]local Wc;local Xc=( (Uc==3 or Uc==4)and Taiko.Data.BigLeniency)or 1;if Vc< (tb.good)then Wc=( (Uc==3 or Uc==4)and 3)or 2;Hb=Hb+1 elseif Vc< (tb.ok*Xc)then Wc=1;Hb=Hb+1 elseif Vc< (tb.bad*Xc)then Wc=0;Hb=0 else Wc=nil end;if Wc then Db=Gb(Db,Hb,Eb,Fb,Wc,Tc.gogo)Nc[Sc].hit=true;Sb={startms=Lc,status=Wc}end end;if(Sc==1)and Kb and(Lc>Kb and Lc<Lb)then Db=Mb(Db,Jb.type,notegogo)end;if(Sc==1 or Sc==2)and Pb and(Lc>Pb and Lc<Qb)then Db=Rb(Db,Ob.type,notegogo)end end;if K.Escape[Rc]then local Tc=os.clock()wc.ClearScreen()curses.nodelay(gc,false)local Uc={'Back','Retry','Back to Select'}while true do wc.SetCursor(1,1)local Vc={}for i=1,#Uc do Vc[i]=( (i==L)and(N..string.rep(' ',M-#N))or string.rep(' ',M))..Uc[i]end;print(table.concat(Vc,O))local Wc=curses.getch(gc)local Xc=curses.getkeyname(Wc)if K.L[Xc]then L=L==1 and 1 or L-1 elseif K.R[Xc]then L=L==3 and 3 or L+1 elseif K.Select[Xc]then if L==1 then elseif L==2 then return'Retry'elseif L==3 then return nil end;break elseif K.Escape[Xc]then break end end;curses.nodelay(gc,true)Fc=Fc+ (os.clock()-Tc)end;if Qc~=-1 then cc={Qc,Rc}end;Ac('Input (ascii)',cc[1])Ac('Input (key)',cc[2])Ac('S',Kc)Ac('Ms',Lc)Ac('Loaded',#xb)Ac('Frames Rendered',dc)Ac('Last Frame Render (ms)',Pc*1000)Ac('Frame Render Total (ms)',ec*1000)Ac('Frame Render Total (%)',ec/Kc*100)Ac('FPS (Frame)',dc/Kc)Ac('Stop Start',Ub or'')Ac('Stop End',Vb or'')Ac('Total Delay',Wb)Ac('Score',Db)Ac('Combo',Hb)Ac('Gogo',Ib)Ac('Drumroll Start',Pb)Ac('Drumroll End',Qb)Bc()Ec()end;return true end end;a='tja/neta/ekiben/neta.tja'a='tja/neta/ekiben/loadingtest2.tja'a='tja/neta/ekiben/updowntest.tja'a='tja/neta/ekiben/drumrolltest.tja'a='tja/saitama.tja'a='tja/neta/ekiben/neta.tja'a='tja/neta/ekiben/jposscrolltest.tja'a='taikobuipm/Ekiben 2000.tja'a='taikobuipm/Donkama 2000.tja'a='tja/neta/ekiben/jposscrolltest.tja'a='tja/neta/ekiben/neta.tja'a='taikobuipm/Donkama 2000.tja'a='tja/neta/ekiben/neta.tja'a='tja/neta/donkama/neta.tja'local function m(u)local v=io.open(u,'rb')if v then v:close()return true else return false end end;local n=Taiko.ParseTJAFile(a)local o='taikobuipm/EkiBEN 2000.ogg'o='taikobuipm/Donkama 2000.ogg'local q={[2]=1,[3]=1,[4]=1}if not m(n[1].Metadata.SONG)then for u,w in pairs(n)do w.Metadata.SONG=o end end;Taiko.PlaySong(Taiko.GetDifficulty(n,'Oni'),nil,q)error()Taiko.PlaySong(Taiko.GetDifficulty(Taiko.ParseTJA(io.open(a,'r'):read('*all')),'Oni'),nil,q)error()Taiko.PlaySong(Taiko.GetDifficulty(Taiko.ParseTJA(io.open(a,'r'):read('*all')),'Edit'),nil,q)error()function Taiko.SongSelect(u,v,w)local x={}local y,z=10,10;local A,B,C,D=-y,y,-z,z;local E=true;local F=1;local G=1;local H=4;local I=5;local J=5;local K=2;local L='V'local M='>'local N=10;local O=nil;local P='>'local Q='>'local R=2;local S=true;local T='_Original_'local U=w or{}local V=false;local W={[2]={'Normal','Auto'},[3]={'Normal','2x Speed','3x Speed','4x Speed','0.25x Speed','0.5x Speed','0.75x Speed'},[4]={'Normal','2x Speed','3x Speed','4x Speed','0.25x Speed','0.5x Speed','0.75x Speed'},[5]={'Normal','Reverse','Invisible','Messy'}}local X={4,1,1,1,1,1}local Y={nil}for ub,vb in pairs(W)do Y[ub]={1,#vb,vb}end;local Z={[1]=nil,[2]={function(ub)return ub,'type',ub.type and(Taiko.Data.Notes.ReverseNotes[ub.type]or ub.type)or ub.type end,function(ub)return ub,'type'end},[3]={function(ub)return ub,'scrollx',10000 end,function(ub)return ub,'scrollx'end},[4]={function(ub)return ub,'type',ub.type and(ub.type==1 and math.random(1,2)or ub.type==2 and math.random(1,2)or ub.type==3 and math.random(3,4)or ub.type==4 and math.random(3,4)or ub.type)end,function(ub)return ub,'type'end}}local ab={window=curses.initscr()}curses.keypad(ab,true)curses.echo(false)curses.raw(true)curses.nl(false)curses.cbreak(true)curses.nodelay(ab,true)curses.getch(ab)curses.nodelay(ab,false)local bb,cb=curses.cols(),curses.lines()O=O or bb-2;local db={Escape={['\27']=true,ALT_ESC=true},Scroll={L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_A2=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true}},Select={Init={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Escape={['\27']=true,ALT_ESC=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true},U={KEY_UP=true,KEY_A2=true},D={KEY_DOWN=true,KEY_C2=true},Play={Hit={['4']=2,['v']=1,['n']=1,['8']=2},Escape={['\27']=true,ALT_ESC=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_DOWN=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}}},Search={Init={ALT_F=true,f=true,F=true},Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},FirstResult={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Select={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true},Up={KEY_A2=true,KEY_UP=true},Down={KEY_C2=true,KEY_DOWN=true},Escape={['\27']=true,ALT_ESC=true}},Add={Init={ALT_N=true,n=true,N=true},Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}},StandardInput={Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},Escape={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_DOWN=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true}},Reload={Init={r=true}},ReloadAll={Init={R=true}},Rename={Init={KEY_F2=true}}}local eb={ClearScreen=function()io.write("\27[2J")end,SetCursor=function(ub,vb)io.write(string.format("\27[%d;%dH",vb,ub))end,ClearLine=function()io.write("\27[2K")end,CursorLeft=function(ub)io.write(string.format("\27[%dD",ub))end,CursorRight=function(ub)io.write(string.format("\27[%dC",ub))end,SaveCursor=function()io.write("\27[s")end,RestoreCursor=function()io.write("\27[u")end}local function fb(ub)return ub..string.rep(' ',O-#ub)end;local function gb()local ub=curses.getch(ab)local vb=curses.getkeyname(ub)return ub,vb end;local function hb()local ub=''local vb=0;local wb=vb;while true do local xb,yb=gb()if db.StandardInput.Backspace[yb]then ub=string.sub(ub,1,vb-1)..string.sub(ub,vb+1,-1)vb=vb-1 elseif db.StandardInput.Escape[yb]then io.write('\n')return ub elseif db.StandardInput.L[yb]then vb=vb-1 elseif db.StandardInput.R[yb]then vb=vb+1 else ub=string.sub(ub,1,vb)..yb..string.sub(ub,vb+1,-1)vb=vb+1 end;vb=ClipN(vb,0,#ub)local zb=vb-wb;if zb<0 then eb.CursorLeft(-zb)elseif zb>0 then eb.CursorRight(zb)end;eb.SaveCursor()eb.ClearLine()io.write('\r')io.write(ub)eb.RestoreCursor()wb=vb end end;local function ib(ub)return ub>=32 and ub<=126 end;local function jb(ub,vb,wb,xb)return(ub and(vb..string.sub(wb,#vb+1,-1))or wb)..xb end;local function kb(ub,vb,wb)return ub>wb and vb or ub<vb and wb or ub end;local lb={[0]='No',[1]='Yes'}local function mb(ub)return ub and lb[1]or lb[0]end;local function nb(ub)return ub*100 ..'%'end;local function ob(ub)return MsToS(ub)..'s'end;local function pb(ub)return ob(SToMs(ub))end;local function qb(ub)return tonumber(ub)and tonumber(ub)or 0 end;local function rb(ub,vb,wb)ub[T..vb]=ub[vb]ub[vb]=wb end;local function sb(ub,vb)ub[vb]=ub[T..vb]end;local tb={}eb.ClearScreen()while true do x={}if E then x[A]={}for i=F-I,F+I do local yb=nil;if i<1 then yb=#u+i elseif i>#u then yb=i-#u else yb=i end;local zb=u[yb]if zb then x[0]=x[0]or{}x[0][(i-F)*J]=zb end end;local wb={}local xb=string.rep(' ',K)for y=C,D do wb[#wb+1]=jb(y==0,M,xb,'')wb[#wb+1]=fb(x[0]and x[0][y]or'')wb[#wb+1]='\n'end;eb.SetCursor(1,1)print(table.concat(wb))else x[0]={}x[0][C]=L;for i=F-I,F+I do local xb=nil;if i<1 then xb=#u+i elseif i>#u then xb=i-#u else xb=i end;local yb=u[xb]if yb then local zb=(i-F)*J;x[zb]=x[zb]or{}local Ab=C+K;for i2=1,#yb do x[zb][Ab]=string.sub(yb,i2,i2)Ab=Ab+1 end end end;local wb={}for y=C,D do for x=A,B do if x[x]and x[x][y]then local xb=x[x][y]if ib(string.byte(xb))then wb[#wb+1]=xb else wb[#wb+1]=' 'end else wb[#wb+1]=' 'end end;wb[#wb+1]='\n'end;eb.SetCursor(1,1)print(table.concat(wb))end;local ub,vb=gb()if db.Scroll.L[vb]then F=F-1 elseif db.Scroll.R[vb]then F=F+1 elseif db.Select.Init[vb]then local wb;if S then if tb[F]then wb=tb[F]else wb=Taiko.ParseTJA(v[F])tb[F]=wb end else wb=Taiko.ParseTJA(v[F])end;local xb={}for Bb,Cb in pairs(wb)do xb[#xb+1]={Bb,Cb.Metadata.COURSE}end;table.sort(xb,function(Bb,Cb)return Bb[2]<Cb[2]end)min=1;max=#xb;Y[1]={min,max,xb}DifficultyMap=xb;X[1]=ClipN(X[1],min,max)local yb=string.rep(' ',R)eb.ClearScreen()eb.SetCursor(1,1)local zb=nil;local Ab=G;while true do G=ClipN(G,1,5)if G~=Ab then H=X[G]Ab=G end;local Bb=Y[G]min,max=Bb[1],Bb[2]H=kb(H,min,max)X[G]=H;eb.SetCursor(1,1)local Cb=DifficultyMap[X[1]][2]zb=Taiko.GetDifficulty(wb,Cb)local Db=zb.Metadata;local Eb=Taiko.Analyze(zb)local Fb={{'',Db.TITLE},{'\t',Db.SUBTITLE},{'',''},{'','Select Options:'},{jb(G==1,Q,yb,'Difficulty: '),Taiko.Data.CourseName[Db.COURSE]},{jb(G==2,Q,yb,'Mode: '),W[2][X[2]]},{jb(G==3,Q,yb,'Note Speed: '),W[3][X[3]]},{jb(G==4,Q,yb,'Song Speed: '),W[4][X[4]]},{jb(G==5,Q,yb,'Modifiers: '),W[5][X[5]]},{'',''},{'Difficulty: ',Taiko.Data.CourseName[Db.COURSE]},{'Stars: ',Db.LEVEL},{'Diverge Notes: ',mb(Db.DIVERGENOTES)},{'',''},{'','Statistics:'},{'Length: ',ob(Eb.lengthms)},{'Don (DON) / Ka (KA): ',qb(Eb.notes[1])..' + ('..qb(Eb.notes[3])..') / '..qb(Eb.notes[2])..' + ('..qb(Eb.notes[4])..') = '..nb((qb(Eb.notes[1])+qb(Eb.notes[3]))/Eb.notes.validn)..' / '..nb((qb(Eb.notes[2])+qb(Eb.notes[4]))/Eb.notes.validn)},{'Max Score (without drumroll): ',Eb.maxscore},{'Max Combo: ',Eb.maxcombo},{'Drumroll Time (total): ',ob(Eb.drumrollms+Eb.drumrollbigms)},{'Balloon Time: ',ob(Eb.balloonms)},{'Balloon Hits: ',Eb.balloonhit},{'Special Time: ',ob(Eb.specialms)},{'Special Hits: ',Eb.specialhit},{'',''},{'','Press Enter to Play!'}}for i=1,#Fb do local Ib=Fb[i]print(fb(Ib[1]..tostring(Ib[2])))end;local Gb,Hb=gb()if db.Select.L[Hb]then H=H-1 elseif db.Select.R[Hb]then H=H+1 elseif db.Select.U[Hb]then G=G-1 elseif db.Select.D[Hb]then G=G+1 elseif db.Select.Select[Hb]then local Ib=Z[X[5]]if Ib and Ib[1]then local Jb=Ib[1]Taiko.ForAll(zb.Data,function(Kb,Lb,Mb)rb(Jb(Kb))end)end;while true do local Jb,Kb=Taiko.PlaySong(zb,ab,X,db.Select.Play)if Jb and Kb then break elseif Jb=='Retry'then else break end end;curses.nodelay(ab,false)eb.ClearScreen()if Ib and Ib[2]then local Jb=Ib[2]Taiko.ForAll(zb.Data,function(Kb,Lb,Mb)sb(Jb(Kb))end)end elseif db.Select.Escape[Hb]then break end end elseif db.Search.Init[vb]then local wb=''local xb={}local yb=1;local zb=nil;local Ab=1;eb.ClearScreen()eb.SetCursor(1,1)print('Searching...')while true do eb.SetCursor(#wb+1,2)local Bb,Cb=gb()eb.SetCursor(1,2)if db.Search.Backspace[Cb]then wb=string.sub(wb,1,-2)elseif db.Search.FirstResult[Cb]then zb=xb[1]break elseif db.Search.Select[Cb]then zb=xb[Ab]break elseif db.Search.Down[Cb]then Ab=Ab+1 elseif db.Search.Up[Cb]then Ab=Ab-1 elseif db.Search.Escape[Cb]then break else wb=wb..Cb end;print(fb(wb))local Db=k.SearchHeaderAll(u,wb)for i=1,N do if Db[i]and Db[i][2]==-math.huge then yb=i-1;break elseif i==N then yb=i end end;Ab=ClipN(Ab,1,yb)local Eb=false;for i=1,N do local Fb=Db[i]if Eb then print(fb(''))else if Fb then if Fb[2]==-math.huge then Eb=true;print(fb(''))else print(fb((i==Ab and P or i)..'. '..Db[i][3]))xb[i]=Fb end end end end end;F=(zb and zb[1]or F)or F elseif db.Add.Init[vb]then print('Import a Custom Song')while true do print('Enter a .tja or .tjac file path (with the file extention)')local wb=hb()local xb=io.open(wb,'rb')if xb then local yb=xb:read('*all')if EndsWith(wb,'.tja')then print('Enter a song name')local zb=hb()local Ab=#u+1;u[Ab]=zb;v[Ab]=yb;U[Ab]={wb}break elseif EndsWith(wb,'.tjac')then local zb,Ab=k.Decompress(yb)for i=1,#zb do local Bb=#u+1;u[Bb]=Ab[i]v[Bb]=zb[i]U[Bb]={wb,zb}end;break else print('Invalid file type')end;xb:close()else print('Unable to read file')end end elseif db.Reload.Init[vb]then print('Reloading selected file...')if U[F]then local wb=U[F]local xb=io.open(wb[1],'rb')if xb then local yb=xb:read('*all')local zb=F;if wb[2]then local Ab,Bb=k.Decompress(yb)if V then u[zb]=Bb[i]end;v[zb]=Ab[i]else v[zb]=yb end;if S then tb[zb]=nil end;xb:close()else print('Unable to read file')end else print('File source not found')end elseif db.ReloadAll.Init[vb]then print('Reloading all files...')local wb={}for xb,yb in pairs(U)do wb[yb[1]]=wb[yb[1]]and wb[yb[1]]or{}wb[yb[1]][#wb[yb[1]]+1]={xb,yb[2]}end;for xb,yb in pairs(wb)do local zb=io.open(xb,'rb')if zb then local Ab=zb:read('*all')if yb[1][2]then local Bb,Cb=k.Decompress(Ab)for i=1,#yb do local Db=yb[i]if V then u[Db[1]]=Cb[Db[2]]end;v[Db[1]]=Bb[Db[2]]if S then tb[Db[1]]=nil end end else for i=1,#yb do local Bb=yb[i]v[Bb[1]]=Ab;if S then tb[Bb[1]]=nil end end end;zb:close()else print('Unable to read file')end end elseif db.Rename.Init[vb]then print('Enter a song name')local wb=hb()u[F]=wb elseif db.Escape[vb]then return end;F=kb(F,1,#u)end end;function Taiko.Game()end;local r='./CompactTJA/taikobuipm.tjac'r='./CompactTJA/ESE/06 Classical.tjac'r='./CompactTJA/ESE/ESE.tjac'local function t(u)local v,w,x={},{},{}for i=1,#u do local y=u[i]v[#v+1]=y:gsub('(.-)/','')local z=io.open(y,'r')local A=z:read('*all')z:close()w[#w+1]=A;x[#x+1]=y end;return v,w,x end;Taiko.SongSelect(t({'./tja/neta/ekiben/spiraltest.tja','./tja/neta/ekiben/delay.tja','./tja/neta/ekiben/neta.tja','./tja/neta/kita/kita.tja','./taikobuipm/Kita Saitama 2000.tja'}))error()
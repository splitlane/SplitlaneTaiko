local k=nil;local l=require('taikocurses')local m=require('./CompactTJA/compactv4')Split=function(r,s)local t={}for u,v in r:gmatch("([^"..s.."]*)("..s.."?)")do table.insert(t,u)if v==''then return t end end end;Trim=function(r)local t=r:gsub("^%s*(.-)%s*$","%1")return t end;TrimLeft=function(r)local t=r:gsub("^%s*(.-)$","%1")return t end;TrimRight=function(r)local t=r:gsub("^(.-)%s*$","%1")return t end;StartsWith=function(r,s)return r:sub(1,#s)==s end;EndsWith=function(r,s)return r:sub(-#s,-1)==s end;Table={}function Table.Clone(r,s)s=s or{}local t=type(r)local u;if t=='table'then if s[r]then u=s[r]else u={}s[r]=u;for v,w in next,r,nil do u[Table.Clone(v,s)]=Table.Clone(w,s)end;setmetatable(u,Table.Clone(getmetatable(r),s))end else u=r end;return u end;ClipN=function(r,s,t)if r<s then return s elseif r>t then return t else return r end end;function Error(r)error(r)end;LineN=nil;function ParseError(r,s,t)Error('Line: '..LineN..'\n'..r..': '..s.. (t and(', '..t)or''))end;function MsToS(r)return r/1000 end;function SToMs(r)return r*1000 end;Taiko={}Taiko.Data={Languages={'','EN','JA','CN','TW','KO'},GenreName={Pop={'pop','j-pop'},Anime={'anime','アニメ'},Kids={'kids','どうよう'},Variety={'variety','バラエティ'},VOCALOID={'vocaloid','ボーカロイド'},Classic={'classic','クラシック'},['Game Music']={'game music','ゲームミュージック'},['Namco Original']={'namco original','ナムコオリジナル'}},CourseId={easy=0,normal=1,hard=2,oni=3,edit=4,tower=5,dan=6,ura=4},CourseName={[0]='Easy','Normal','Hard','Oni','Edit','Tower','Dan','Ura'},RatingMultiplier={[0]=0,[1]=0.5,[2]=1,[3]=2},GogoMultiplier=1.2,ScoreMode={Note={[0]=function(r,s,t,u,v,w)return r+ ( ( (s<200)and(t or 1000)or( (t or 1000)+ (u or 1000)))*Taiko.Data.RatingMultiplier[v]* (w and Taiko.Data.GogoMultiplier or 1))end,[1]=function(r,s,t,u,v,w)return r+ ( (t+math.max(0,u*math.floor((math.min(s,100)-1)/10)))*Taiko.Data.RatingMultiplier[v]* (w and Taiko.Data.GogoMultiplier or 1))end,[2]=function(r,s,t,u,v,w)return math.floor(r+ ( (t+u* ( (s>=100)and 8 or(s>=50)and 4 or(s>=30)and 2 or(s>=10)and 1 or 0))*Taiko.Data.RatingMultiplier[v]* (w and Taiko.Data.GogoMultiplier or 1))/10)*10 end},Drumroll={[0]=function(r,s,t)return r+ ( (s==5 and 300 or s==6 and 600)* (t and Taiko.Data.GogoMultiplier or 1))end,[1]=function(r,s,t)return r+ ( (s==5 and 300 or s==6 and 600)* (t and Taiko.Data.GogoMultiplier or 1))end,[2]=function(r,s,t)return r+ ( (s==5 and 100 or s==6 and 200)* (t and Taiko.Data.GogoMultiplier or 1))end},Balloon={[0]=function(r,s,t)return r+ ( (s==7 and 300)* (t and Taiko.Data.GogoMultiplier or 1))end,[1]=function(r,s,t)return r+ ( (s==7 and 300)* (t and Taiko.Data.GogoMultiplier or 1))end,[2]=function(r,s,t)return r+ ( (s==7 and 300)* (t and Taiko.Data.GogoMultiplier or 1))end},BalloonPop={[0]=function(r,s,t)return r+ ( (s==7 and 5000)* (t and Taiko.Data.GogoMultiplier or 1))end,[1]=function(r,s,t)return r+ ( (s==7 and 5000)* (t and Taiko.Data.GogoMultiplier or 1))end,[2]=function(r,s,t)return r+ ( (s==7 and 5000)* (t and Taiko.Data.GogoMultiplier or 1))end}},Autoscore={[0]=function(r)end,[1]=function(r)end,[2]=function(r)end},SideId={normal=1,ex=2,both=3},SideName={'normal','ex','both'},StyleId={single=1,double=2,couple=2},StyleName={'single','double'},Exam={Condition={g=true,jp=true,jg=true,jb=true,s=true,r=true,h=true,c=true},Scope={m=true,l=true}},Branch={PathId={N=0,E=1,M=2},PathName={[0]='N',[1]='E',[2]='M'},Requirements={r=function()end,p=function()end}},Timing={GetFunction=function(r)return function(s)if r==1 then return{good=5 /2 *s,ok=13 /2 *s,bad=15 /2 *s}else return{good=3 /2 *s,ok=9 /2 *s,bad=13 /2 *s}end end end},StatusId={bad=0,ok=1,good=2,biggood=3},StatusName={[0]='BAD',[1]='OK',[2]='GOOD',[3]='GOOD'},ModeId={['']=0,P1=1,P2=2},ModeName={[0]='',P1,P2},Combo={[1]=true,[2]=true,[3]=true,[4]=true},BigLeniency=2,Strings={Notes={}}}function Taiko.ParseTJA(r)local s=os.clock()local t=true;local u=true;local v={}local w={Metadata={SUBTITLE='',BPM=120,WAVE='main.mp3',OFFSET=0,DEMOSTART=0,SCOREMODE=1,SONGVOL=100,SEVOL=100,SIDE=3,LIFE=0,GAME='Taiko',HEADSCROLL=1,MOVIEOFFSET=0,COURSE='ONI',LEVEL=0,BALLOON=nil,SCOREINIT,SCOREDIFF,BALLOONNOR=nil,BALLOONEXP=nil,BALLOONMAS=nil,STYLE=1,EXAM1=nil,EXAM2=nil,EXAM3=nil,GAUGEINCR='NORMAL',TOTAL=nil,HIDDENBRANCH=0,DIVERGENOTES=false,SCOREINIT=0,SCOREDIFF=0,STOPSONG=false},Data={}}local function x(Q)local R=Taiko.Data.Languages;for i=1,#R do local S=w.Metadata[Q..R[i]]if S then return S end end;return nil end;local function y(Q,R,S)local T=tonumber(R)if T then return T else ParseError(Q,S,R)end end;local function z(Q,R,S,T)if R then return R else ParseError(Q,S,T)end end;local function A(Q,R,S)local T={['true']=true,['false']=false,yes=true,no=false,['1']=true,['0']=false,[1]=true,[0]=false}local U=T[R]~=nil;if U then return U else ParseError(Q,S,R)end end;local function B(Q,R)local S=','local T='\\'local U={}local V=''local W=false;for i=1,#R do local X=string.sub(R,i,i)if W then V=V..X;W=false else if X==S then table.insert(U,V)V=''elseif X==T then W=true else V=V..X end end end;table.insert(U,V)return U end;local function C(Q,R,S)local T=B(Q,R)for i=1,#T do T[i]=y(Q,T[i],S,R)end;return T end;local function D(Q,R,S)if R and R~=''then return C(Q,R,S)else return{}end end;local function E(Q,R,S)if R and R~=''then local T=B(Q,R,S)z(Q,Taiko.Data.Exam.Condition[T[1]],S)T[2]=y(Q,T[2],S)T[3]=y(Q,T[3],S)z(Q,Taiko.Data.Exam.Scope[T[4]],S)return T else return{}end end;local F=error;local function G(Q)local R=nil;local S=false;local T=''for i=1,#Q do local U=string.sub(Q,i,i)if U=='+'or U=='-'then if R then F('There are multiple signs')else R=U end elseif U=='.'then if S then F('There are multiple decimal points')else T=T..U;S=true end elseif tonumber(U)then T=T..U end end;if T==''then F('No number was found')end;return tonumber((R or'+')..T)end;local function H(Q)local R=tonumber(Q)if R then return R end;local S=string.gsub(Q,'[^%d%.%-%+]','')if S==''then return 0 end;return tonumber(S)or G(Q)or G(S)end;local function I(Q)return string.find(Q,'i')end;local function J(Q)local R={0,0}local S=false;local T=''for i=1,#Q do local U=string.sub(Q,i,i)if U=='+'or U=='-'then R[1]=R[1]+H(T)T=U elseif U=='i'then R[2]=R[2]+H(T)T=''else T=T..U end end;if T~=''then R[1]=R[1]+H(T)end;return R end;local function K(Q)return string.find(Q,',')end;local function L(Q,R)return{Q*math.cos(R),Q*math.sin(R)}end;local function M(Q)return Split(Q,',')end;local N={}local function O()local Q={settings={noteparse={notes={[0]=true,[1]=true,[2]=true,[3]=true,[4]=true,[5]=true,[6]=true,[7]=true,[8]=true,[9]=true,['A']=true,['B']=true}},command={matchexceptions={}},directionweight={R=0,U=90,L=180,D=270,['0']=0,['1']=90,['2']=270,['3']=45,['4']=315,['5']=180,['6']=135,['7']=225}},bpm=0,ms=0,songstarted=false,timingpoint=nil,sign=4 /4,mpm=0,mspermeasure=0,scroll=1,scrollx=-1,scrolly=0,measuredone=true,currentmeasure={},measurepushto=w.Data,barline=true,insertbarline=true,gogo=false,lastlong=nil,balloonn=1,currentbranch=nil,branch={on=false,requirements={},paths={}},msbeforebranch=nil,section=false,disablescroll=false,stopsong=false,delay=0,suddenappear=nil,suddenmove=nil,notechain={}}function Q.createnote(R)if R then local S={ms=nil,data=nil,type=R,txt=nil,gogo=Q.gogo,scroll=(Q.scroll*w.Metadata.HEADSCROLL),scrolly=(Q.scrolly*w.Metadata.HEADSCROLL),mspermeasure=Q.mspermeasure,bpm=Q.bpm,nextnote=nil,radius=1,requiredhits=nil,length=nil,endnote=nil,section=nil,text=nil,delay=Q.delay,appearancems=Q.suddenappear,movems=Q.suddenmove,dummy=Q.dummy,onnotepush=nil,line=LineN}if R==3 or R==4 or R==6 then S.radius=S.radius*1.6 end;if R==5 or R==6 or R==7 or R==9 then if Q.lastlong then if R==9 then else ParseError('parser.noteparse','Last long note has not ended')end else Q.lastlong=S;if R==7 or R==9 then S.requiredhits=z('parser.noteparse',w.Metadata.BALLOON[Q.balloonn],'Invalid number of balloons',Q.balloonn)Q.balloonn=Q.balloonn+1 end end end;if R==8 then local T=Q.lastlong;Q.lastlong=nil;S.startnote=T;if T then S.onnotepush=function()T.length=S.ms-T.ms;T.endnote=S end else end end;if Q.section then S.section=true;Q.section=false end;return S else return{ms=nil,data=nil,type=nil,txt=nil,gogo=Q.gogo,scroll=(Q.scroll*w.Metadata.HEADSCROLL),scrolly=(Q.scrolly*w.Metadata.HEADSCROLL),mspermeasure=Q.mspermeasure,bpm=Q.bpm,nextnote=nil,delay=Q.delay,appearancems=Q.suddenappear,movems=Q.suddenmove,line=LineN}end end;function Q.createbarline()local R=Q.createnote()R.ms=Q.ms;R.data='event'R.event='barline'return R end;function Q.endbranch()local R=Q.createnote()R.data='event'R.event='branch'R.branch={requirements=Q.branch.requirements,paths=Q.branch.paths}Q.branch.on=false;Q.branch.requirements={}Q.branch.paths={}table.insert(w.Data,R)Q.measurepushto=w.Data end;return Q end;N=O()local P=Split(r,'\n')for i=1,#P do LineN=i;local Q=Trim(P[i])if StartsWith(Q,'//')or Q==''then else local R=string.find(Q,'//')if R then Q=string.sub(Q,1,R-1)end;local S=false;if N.songstarted==false and S==false then local T={string.match(Q,'(%u+):(.*)')}if T[1]then local U=Trim(T[2])if U~=''then w.Metadata[Trim(T[1])]=U end;S=true end end;if(N.songstarted or StartsWith(Q,'#START')or StartsWith(Q,'#BMSCROLL')or StartsWith(Q,'#HBSCROLL'))and S==false then local T={string.match(Q,'#(%u-)%s(.*)')}if not T[1]then T={string.match(Q,'#(%u+)')}end;if T[1]then if T[1]=='START'then if N.songstarted then ParseError(T[1],'Song has already started')else w.OriginalMetadata=Table.Clone(w.Metadata)if T[2]then w.Metadata.MODE=z(T[1],Taiko.Data.ModeId[T[2]],'Invalid mode',T[2])else w.Metadata.MODE=0 end;w.Metadata.TITLE=z(T[1],x('TITLE'),'Title is missing')w.Metadata.SUBTITLE=z(T[1],x('SUBTITLE'),'Subtitle is missing')w.Metadata.BPM=y(T[1],w.Metadata.BPM,'Invalid bpm')w.Metadata.OFFSET=SToMs(y(T[1],w.Metadata.OFFSET,'Invalid offset'))w.Metadata.DEMOSTART=SToMs(y(T[1],w.Metadata.DEMOSTART,'Invalid demostart'))if w.Metadata.DEMOSTART==0 then w.Metadata.DEMOSTART=nil end;for X,Y in pairs(Taiko.Data.GenreName)do for i=1,#Y do if Y[i]==w.Metadata.GENRE then w.Metadata.GENRE=X end end end;w.Metadata.SCOREMODE=y(T[1],w.Metadata.SCOREMODE,'Invalid scoremode')z(T[1],Taiko.Data.ScoreMode.Note[w.Metadata.SCOREMODE],'Invalid scoremode',w.Metadata.SCOREMODE)if w.Metadata.MAKER then w.Metadata.CREATORURLT={}w.Metadata.CREATOR=Trim(string.gsub(w.Metadata.MAKER,'(<.->)',function(X)table.insert(w.Metadata.CREATORURLT,string.sub(X,2,-2))return''end))w.Metadata.CREATORURL=table.concat(w.Metadata.CREATORURLT,', ')w.Metadata.CREATIVE=false else w.Metadata.CREATIVE=false end;w.Metadata.SONGVOL=y(T[1],w.Metadata.SONGVOL,'Invalid songvol')/100;w.Metadata.SEVOL=y(T[1],w.Metadata.SEVOL,'Invalid sevol')/100;local U=tonumber(w.Metadata.SIDE)if U then z(T[1],Taiko.Data.SideName[U],'Invalid side id',w.Metadata.SIDE)w.Metadata.SIDE=U else w.Metadata.SIDE=z(T[1],Taiko.Data.SideId[string.lower(w.Metadata.SIDE)],'Invalid side name',w.Metadata.SIDE)end;w.Metadata.LIFE=y(T[1],w.Metadata.LIFE,'Invalid life')if w.Metadata.LIFE==0 then w.Metadata.LIFE=nil end;w.Metadata.GAME=string.lower(w.Metadata.GAME)if w.Metadata.GAME=='taiko'then elseif w.Metadata.GAME=='jube'then else end;w.Metadata.HEADSCROLL=y(T[1],w.Metadata.HEADSCROLL,'Invalid headscroll')w.Metadata.MOVIEOFFSET=y(T[1],w.Metadata.MOVIEOFFSET,'Invalid movieoffset')local V=tonumber(w.Metadata.COURSE)if V then z(T[1],Taiko.Data.CourseName[V],'Invalid course id',w.Metadata.COURSE)w.Metadata.COURSE=V else w.Metadata.COURSE=z(T[1],Taiko.Data.CourseId[string.lower(w.Metadata.COURSE)],'Invalid course name',w.Metadata.COURSE)end;w.Metadata.TIMING=Taiko.Data.Timing.GetFunction(w.Metadata.COURSE)w.Metadata.LEVEL=ClipN(math.floor(y(T[1],w.Metadata.LEVEL,'Invalid level')),0,10)w.Metadata.BALLOON=D(T[1],w.Metadata.BALLOON,'Invalid balloon')w.Metadata.SCOREINIT=y(T[1],w.Metadata.SCOREINIT,'Invalid scoreinit')w.Metadata.SCOREDIFF=y(T[1],w.Metadata.SCOREDIFF,'Invalid scoreinit')w.Metadata.BALLOONNOR=D(T[1],w.Metadata.BALLOONNOR,'Invalid balloonnor')w.Metadata.BALLOONEXP=D(T[1],w.Metadata.BALLOONEXP,'Invalid balloonexp')w.Metadata.BALLOONMAS=D(T[1],w.Metadata.BALLOONMAS,'Invalid balloonmas')local W=tonumber(w.Metadata.STYLE)if W then z(T[1],Taiko.Data.StyleName[W],'Invalid style id',Taiko.Data.STYLE)w.Metadata.STYLE=W else w.Metadata.STYLE=z(T[1],Taiko.Data.StyleId[string.lower(w.Metadata.STYLE)],'Invalid style name',w.Metadata.STYLE)end;w.Metadata.EXAM1=E(w.Metadata.EXAM1)w.Metadata.EXAM2=E(w.Metadata.EXAM2)w.Metadata.EXAM3=E(w.Metadata.EXAM3)w.Metadata.GAUGEINCR=string.lower(w.Metadata.GAUGEINCR)if w.Metadata.TOTAL then w.Metadata.TOTAL=y(T[1],w.Metadata.TOTAL,'Invalid total')end;w.Metadata.HIDDENBRANCH=A(T[1],w.Metadata.HIDDENBRANCH,'Invalid hiddenbranch')N.bpm=w.Metadata.BPM;N.songstarted=true end elseif T[1]=='END'then if N.songstarted then if#N.currentmeasure~=0 then ParseError(T[1],'Current measure is not empty')end;table.insert(v,w)w={Metadata=Table.Clone(w.OriginalMetadata),Data={}}N=O()N.songstarted=false;N.measurepushto=w.Data else ParseError(T[1],'Song has already ended')end elseif T[1]=='MEASURE'then local U,V=string.match(T[2],'(%d+)/(%d+)')U=y(T[1],U,'Invalid measure')V=y(T[1],V,'Invalid measure')N.sign=(U/V)or N.sign elseif T[1]=='BPMCHANGE'then N.bpm=y(T[1],T[2],'Invalid bpmchange')or N.bpm elseif T[1]=='DELAY'then local U=SToMs((y(T[1],T[2],'Invalid delay')or 0))N.delay=N.delay+U;table.insert(N.currentmeasure,{'DELAY',U})elseif T[1]=='SCROLL'then if N.disablescroll then else if u and I(T[2])then local U=J(T[2])N.scrollx=-U[1]N.scrolly=-U[2]elseif u and K(T[2])then local U=C(T[1],T[2],'Invalid polar scroll')if#U==3 then local V=L(U[1],math.rad(U[3]/U[2]*360))N.scrollx=-V[1]N.scrolly=-V[2]else ParseError(T[1],'Invalid polar scroll')end else N.scrollx=- (y(T[1],T[2],'Invalid scroll')or-N.scrollx)N.scrolly=0 end;N.scroll=-N.scrollx;if N.scroll==0 and N.scrollx==0 and N.scrolly==0 then ParseError(T[1],'Scroll cannot be 0')end end elseif T[1]=='GOGOSTART'then N.gogo=true elseif T[1]=='GOGOEND'then N.gogo=false elseif T[1]=='BARLINEOFF'then N.barline=false elseif T[1]=='BARLINEON'then N.barline=true elseif T[1]=='BRANCHSTART'then if N.branch.on then N.endbranch()end;N.msbeforebranch=N.ms;N.branch.on=true;w.Metadata.DIVERGENOTES=true;local U=B(T[1],T[2])local V=z(T[1],Taiko.Data.Branch.Requirements[string.lower(U[1])],'Invalid type',U[1])N.branch.requirements={V}local W=2;while true do if not U[W]then break end;local X=Taiko.Data.Branch.PathName[W-1]if X then N.branch.requirements[X]=U[W]else break end;W=W+1 end elseif Taiko.Data.Branch.PathId[T[1]]then if N.branch.on then N.ms=N.msbeforebranch;N.currentbranch=T[1]N.branch.paths[T[1]]={}N.measurepushto=N.branch.paths[T[1]]else ParseError(T[1],'Branch has not started')end elseif T[1]=='BRANCHEND'then if N.branch.on then N.endbranch()else ParseError(T[1],'Branch has already ended')end elseif T[1]=='SECTION'then N.section=true elseif T[1]=='LYRIC'then elseif T[1]=='LEVELHOLD'then elseif T[1]=='BMSCROLL'then N.disablescroll=true;w.Metadata.STOPSONG=true elseif T[1]=='HBSCROLL'then w.Metadata.STOPSONG=true elseif T[1]=='SENOTECHANGE'then elseif T[1]=='NEXTSONG'then elseif T[1]=='DIRECTION'then local U=T[2]local V=N.settings.directionweight;local W=0;local X=0;for i=1,#U do local bb=string.sub(U,i,i)if V[bb]then W=W+V[bb]X=X+1 end end;if X==0 then ParseError(T[1],'Invalid direction')end;local Y=W/X;local Z=math.sqrt(N.scrollx^2 +N.scrolly^2)local ab=L(Z,math.rad(Y))N.scrollx=-ab[1]N.scrolly=-ab[2]elseif T[1]=='SUDDEN'then local U=M(T[2])N.suddenappear=SToMs(tonumber(U[1]))N.suddenmove=SToMs(tonumber(U[2]))elseif T[1]=='JPOSSCROLL'then elseif u then if T[1]=='GAMEMODE'then elseif T[1]=='SPLITLANE'then elseif T[1]=='MERGELANE'then elseif T[1]=='BARLINE'then table.insert(N.measurepushto,N.createbarline())elseif T[1]=='DUMMYSTART'then N.dummy=true elseif T[1]=='DUMMYEND'then N.dummy=false elseif T[1]==''then elseif T[1]==''then elseif T[1]==''then elseif T[1]==''then elseif T[1]==''then elseif T[1]==''then elseif T[1]==''then elseif T[1]==''then elseif T[1]==''then elseif T[1]==''then elseif T[1]==''then elseif T[1]==''then elseif T[1]==''then elseif T[1]==''then elseif T[1]==''then elseif T[1]==''then elseif T[1]==''then elseif T[1]==''then end else end;S=true end end;if(N.songstarted)and S==false then N.mpm=N.bpm*N.sign/4;N.mspermeasure=60000 *N.sign*4 /N.bpm;if N.barline and N.insertbarline then table.insert(N.measurepushto,N.createbarline())N.insertbarline=false end;for i=1,#Q do local T=string.sub(Q,i,i)local U=tonumber(T)or T;if N.settings.noteparse.notes[U]then local V=N.createnote(U)V.data='note'table.insert(N.currentmeasure,V)end end;if EndsWith(TrimRight(Q),',')then N.mpm=N.bpm*N.sign/4;N.mspermeasure=60000 *N.sign*4 /N.bpm;if#N.currentmeasure==0 then N.ms=N.ms+N.mspermeasure elseif#N.currentmeasure==1 and N.currentmeasure[1].data=='event'and N.currentmeasure[1].event=='barline'then w.Data[#w.Data+1]=N.currentmeasure[1]N.ms=N.ms+N.mspermeasure else local T=0;local U=nil;for i=1,#N.currentmeasure do local W=N.currentmeasure[i]if W.data=='note'then U=U or W.mspermeasure;T=T+1 end end;U=U or N.mspermeasure;local V=U/T;for i=1,#N.currentmeasure do local W=N.currentmeasure[i]if W[1]=='DELAY'then N.ms=N.ms+W[2]else if not t or W.type~=0 then W.ms=N.ms;W.appearancems=W.appearancems and(W.ms- (W.appearancems))W.movems=W.movems and(W.ms- (W.movems))local X=N.measurepushto[#N.measurepushto]or w.Data[#w.Data]if X then X.nextnote=W end;table.insert(N.measurepushto,W)if W.onnotepush then W.onnotepush()end;V=W.mspermeasure/T end;if W.data=='note'then N.ms=N.ms+V end end end end;N.measuredone=true;N.currentmeasure={}N.insertbarline=true else N.measuredone=false end end end end;print('Parsing Took: '..SToMs(os.clock()-s)..'ms')return v end;function Taiko.SerializeTJA(r)local function s(D)return math.floor(D+0.5)end;local t=5;local u=10 ^t;local function v(D)return math.floor(D*u+0.5)/u end;local function w(D)if math.floor(D)~=D then return string.format('%f',D)else return tostring(D)end end;local function x(D,E)if D<E then return x(E,D)end;if math.abs(E)<0.001 then return D else return x(E,D-math.floor(D/E)*E)end end;local function y(D)local E=x(D,1)return s(D/E),s(1 /E)end;local function z(D)local E,F=string.match(D,'(%d+)/(%d+)')return E,F end;local function A(D)for i=1,#D do D[i]=tostring(D[i])end;return table.concat(D,',')end;local function B(D)local E={}local F={OFFSET=true,DEMOSTART=true}for O,P in pairs(D.Metadata)do local Q;if type(P)=='number'then if F[O]then Q=tostring(MsToS(tonumber(P)))else Q=tostring(P)end elseif type(P)=='table'then Q=A(P)elseif type(P)=='string'then Q=tostring(P)else Q=nil end;if Q then E[#E+1]=O;E[#E+1]=':'E[#E+1]=Q;E[#E+1]='\n'end end;E[#E+1]='\n\n'local G=false;local H=false;local I=D.Metadata.HEADSCROLL;for i=1,#D.Data do local O=D.Data[i]O.ms=O.ms-O.delay;if O.data=='event'and O.event=='barline'then G=true end;if O.delay and O.delay~=0 then H=true end;if O.scroll and O.scroll~=I then I=false end end;if H then if I then E[#E+1]='#BMSCROLL\n'else E[#E+1]='#HBSCROLL\n'end end;E[#E+1]='#START\n'if G then E[#E+1]='#BARLINEON\n'else E[#E+1]='#BARLINEOFF\n'end;local J={startms=nil}local K=nil;local L=0;local M={scroll=0,bpm=D.Metadata.BPM,measure=nil,gogo=false,delay=0}local N={scroll={'#SCROLL ',nil,function(O)local P=O.scroll/D.Metadata.HEADSCROLL;if P~=M.scroll then M.scroll=P;return tostring(P)end end},bpm={'#BPMCHANGE ',tostring(D.Metadata.BPM),function(O)local P=O.bpm;if P~=M.bpm then M.bpm=P;return tostring(P)end end},measure={'#MEASURE ',false,function(O)local P,Q=y(O.bpm*O.mspermeasure/240000)local R=P..'/'..Q;if R~=M.measure then M.measure=R;return R end end},gogo={'#GOGO',false,function(O)local P=O.gogo;if P~=M.gogo then M.gogo=P;if P then return'START'else return'END'end end end},delay={'#DELAY ',nil,function(O)if O.delay~=M.delay then local P=O.delay-M.delay;M.delay=O.delay;return w(MsToS(P))end end}}for i=1,#D.Data do local O=D.Data[i]local P=O.ms;if O.data=='note'then J[#J+1]=O elseif O.data=='event'and O.event=='barline'then J.startms=O.ms;J[#J+1]=O end;local Q=D.Data[i+1]if(Q and Q.data=='event'and Q.event=='barline')or(i==#D.Data)then if#J==0 then error('No barline')else local R={}for i=2,#J do local V=J[i-1]local W=J[i]R[#R+1]=math.abs(W.ms-V.ms)end;R[#R+1]=math.abs((J.startms+J[1].mspermeasure)-J[#J].ms)local S=R[1]for i=2,#R do S=x(S,R[i])end;if S==nil then error('gcd invalid, probably delay')S=J[1]and(J[1].ms-L)end;local T=J.startms;local U=T+J[1].mspermeasure;for i2=1,#J do local V=J[i2]for W,X in pairs(N)do if V[W]==X[2]then else local Y=X[3](V)if Y then X[2]=Y;if E[#E]~='\n'then E[#E+1]='\n'end;E[#E+1]=X[1]E[#E+1]=Y;E[#E+1]='\n'end end end;if i2 ~=1 then E[#E+1]=tostring(V.type)end;if i2 ==1 and#J~=1 then E[#E+1]=string.rep('0',( (J[i2 +1]and J[i2 +1].ms or U)-V.ms)/S)else E[#E+1]=string.rep('0',( (J[i2 +1]and J[i2 +1].ms or U)-V.ms)/S-1)end end;E[#E+1]=','E[#E+1]='\n'J={}end end end;if E[#E]~='\n'then E[#E+1]='\n'end;E[#E+1]='\n#END'return table.concat(E)end;local C={'// Automatically Serialized by Taiko.SerializeTJA'}for D,E in pairs(r)do C[#C+1]=B(E)return table.concat(C,'\n\n')end;C=table.concat(C,'\n\n')return C end;function Taiko.Score(r,s,t,u,v)if u==0 then t=0 else t=t+1 end;local w=r.Metadata;return Taiko.Data.ScoreMode.Note[w.SCOREMODE](s,t,w.SCOREINIT,w.SCOREDIFF,u,v),t end;function Taiko.Analyze(r)local s='M'local t={[1]=2,[2]=2,[3]=3,[4]=3}local u={notes={n=0,validn=0},measures=0,lengthms=0,drumrollms=0,drumrollbigms=0,balloonms=0,balloonhit=0,specialms=0,specialhit=0,maxcombo=0,maxscore=0}local v=nil;Taiko.ForAll(r.Data,function(w,x,y)if w.data=='note'then u.notes.n=u.notes.n+1;u.notes[w.type]=u.notes[w.type]and u.notes[w.type]+1 or 1;if t[w.type]then u.maxscore,u.maxcombo=Taiko.Score(r,u.maxscore,u.maxcombo,t[w.type],w.gogo)end;local z=w.endnote;if z then local A=z.ms-w.ms;if w.type==5 then u.drumrollms=u.drumrollms+A elseif w.type==6 then u.drumrollbigms=u.drumrollbigms+A elseif w.type==7 then u.balloonms=u.balloonms+A;u.balloonhit=u.balloonhit+w.requiredhits elseif w.type==9 then u.specialms=u.specialms+A;u.specialhit=u.specialhit+w.requiredhits else end end;v=w elseif w.data=='event'and w.event=='barline'then u.measures=u.measures+1 else end end,s)u.lengthms=v.ms-r.Metadata.OFFSET;u.notes.validn=u.maxcombo;return u end;function Taiko.GetDifficulty(r,s)local t=Taiko.Data.CourseId[string.lower(s)]or s;for u,w in pairs(r)do if w.Metadata.COURSE==t then return w end end;Error('No difficulty found, '..s)return nil end;function Taiko.ForAll(r,s,t)local u=1;for i=1,#r do local w=r[i]if w.branch then if t then local x=w.branch.paths[t]for i2=1,#x do s(x[i2],i2,u)u=u+1 end;u=u-1 else local x=-1;for y,z in pairs(w.branch.paths)do local A=u;for i2=1,#z do s(z[i2],i2,A)A=A+1 end;x=(x<A)and A or x end;u=x end else s(w,i,u)end;u=u+1 end;return r end;function Taiko.GetAllNotes(r)local s={}for u,w in pairs(r)do if w.branch then for x,y in pairs(w.branch.paths)do for i=1,#y do table.insert(s,y[i])end end else table.insert(s,w)end end;return s end;function Taiko.ConnectNotes(r)local s=nil;for i=#r,1,-1 do local t=r[i]t.nextnote=s;s=t end;return r end;function Taiko.ExtractBranch(r,s)return r.branch.paths[s]end;function Taiko.ConnectAll(r)local s=nil;for i=#r,1,-1 do local t=r[i]if t.branch then for u,w in pairs(t.branch.paths)do local x=Taiko.ConnectNotes(w)x[#x].nextnote=s end else t.nextnote=s end;s=t end end;function Taiko.CalculateSpeed(r,s)local t=(s*r.scroll*r.bpm/7500)return t end;function Taiko.CalculateSpeedAll(r,s)for i=1,#r do r[i].speed=Taiko.CalculateSpeed(r[i],s)end;return r end;function Taiko.RenderScale(r)local s={}local u={}local v={}for i=1,#r.Data do local z=r.Data[i]if z.data=='note'then local A=math.floor(z.ms)if math.floor(A)-A==0 then table.insert(s,{A,z.type})table.insert(u,A)else table.insert(v,i)end end end;function gcd2(z,A)if A==0 then return z else return gcd2(A,z%A)end end;function gcdn(z)local A=z[1]for i=2,#z do A=gcd2(A,z[i])end;return A end;local w=gcdn(u)for i=1,#v do local z=s[v[i]]z[1]=math.floor(z[1]/w)*w end;local x=''local y=0;for i=1,#s do s[i][1]=s[i][1]/w;x=x..string.rep(' ',s[i][1]-y)..s[i][2]y=s[i][1]end;return x end;function Taiko.PlaySong(r,s,t,u)local v={on=false,fps=60,frames={}}local w=nil;local x={auto={[1]=false,[2]=true},notespeedmul={[1]=1,[2]=2,[3]=3,[4]=4,[5]=0.25,[6]=0.5,[7]=0.75},songspeedmul={[1]=1,[2]=2,[3]=3,[4]=4,[5]=0.25,[6]=0.5,[7]=0.75}}local z=x.auto[t[2]]or false;local A=x.notespeedmul[t[3]]or 1;local B=x.songspeedmul[t[4]]or 1;local C=r.Metadata.STOPSONG;local D=u or{}D={Hit=D.Hit or{['4']=2,['v']=1,['n']=1,['8']=2},Escape=D.Escape or{['\27']=true,ALT_ESC=true},L=D.L or{KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_A2=true},R=D.R or{KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true},Select=D.Select or{KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}}local E=1;local F=2;local G='>'local H='\n\n\n'local I=10;local J=10;local K=1000;local L=4;local M=0;local N=10;local O=0;local P=40;local Q=3;local R=1;local S={[1]={color='red'},[2]={color='blue'},[3]={color='red'},[4]={color='blue'},[5]={color='yellow'},[6]={color='yellow'},[7]={color='cyan'}}local T=200;local U=T/4;local V=4;local W=20;P=math.floor(P*L)local X=O+P;Q=math.floor(Q*L)local Y=s or{window=l.initscr()}l.keypad(Y,true)l.echo(false)l.raw(true)l.nl(false)l.cbreak(true)l.nodelay(Y,true)local Z={[0]={Data={[1]={'0','1','1','1','1','1','1','1'},[2]={[2]='1',[5]='1',[8]='1'},[3]={[2]='1',[5]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={[3]='1',[4]='1',[6]='1',[7]='1'},[8]={'0','0','1','1','1','1','1','1'},[9]={[2]='1',[5]='1'},[10]={[2]='1',[5]='1'},[11]={[2]='1',[5]='1'},[12]={[2]='1',[5]='1'},[13]={'0','0','1','1','1','1','1','1'},[15]={'0','1','1','1','1','1','1','1'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'}},Color={All='blue'},Offset={-1,0}},[1]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[8]='1'},[5]={[2]='1',[8]='1'},[6]={'0','0','1','1','1','1','1','0'},[8]={'0','1','1','1','1','1','1','1'},[9]={[5]='1'},[10]={[4]='1',[6]='1'},[11]={[3]='1',[7]='1'},[12]={[2]='1',[8]='1'}},Color={All='white'},Offset={-1,0}},[2]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={'0','1','0','0','1','1','1','1'},[8]={'0','0','1','1','1','1','1','0'},[9]={[2]='1',[8]='1'},[10]={[2]='1',[8]='1'},[11]={[2]='1',[8]='1'},[12]={[2]='1',[8]='1'},[13]={'0','0','1','1','1','1','1','0'},[15]={'0','0','1','1','1','1','1','0'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'},[22]={'0','1','1','1','1','1','1','1'},[23]={[2]='1',[8]='1'},[24]={[2]='1',[8]='1'},[25]={[2]='1',[8]='1'},[26]={[2]='1',[8]='1'},[27]={'0','0','1','1','1','1','1','0'}},Color={All='yellow'},Offset={-1,0}},Size={27,8}}Z[3]=Z[2]local ab={[0]=nil,[1]={},[2]={}}local bb;if k then bb=k else os.execute('chcp 65001')bb={}local qc=([[
⠀ ⢀ ⠠ ⢠ ⠐ ⢐ ⠰ ⢰ ⠈ ⢈ ⠨ ⢨ ⠘ ⢘ ⠸ ⢸
⡀ ⣀ ⡠ ⣠ ⡐ ⣐ ⡰ ⣰ ⡈ ⣈ ⡨ ⣨ ⡘ ⣘ ⡸ ⣸
⠄ ⢄ ⠤ ⢤ ⠔ ⢔ ⠴ ⢴ ⠌ ⢌ ⠬ ⢬ ⠜ ⢜ ⠼ ⢼
⡄ ⣄ ⡤ ⣤ ⡔ ⣔ ⡴ ⣴ ⡌ ⣌ ⡬ ⣬ ⡜ ⣜ ⡼ ⣼
⠂ ⢂ ⠢ ⢢ ⠒ ⢒ ⠲ ⢲ ⠊ ⢊ ⠪ ⢪ ⠚ ⢚ ⠺ ⢺
⡂ ⣂ ⡢ ⣢ ⡒ ⣒ ⡲ ⣲ ⡊ ⣊ ⡪ ⣪ ⡚ ⣚ ⡺ ⣺
⠆ ⢆ ⠦ ⢦ ⠖ ⢖ ⠶ ⢶ ⠎ ⢎ ⠮ ⢮ ⠞ ⢞ ⠾ ⢾
⡆ ⣆ ⡦ ⣦ ⡖ ⣖ ⡶ ⣶ ⡎ ⣎ ⡮ ⣮ ⡞ ⣞ ⡾ ⣾
⠁ ⢁ ⠡ ⢡ ⠑ ⢑ ⠱ ⢱ ⠉ ⢉ ⠩ ⢩ ⠙ ⢙ ⠹ ⢹
⡁ ⣁ ⡡ ⣡ ⡑ ⣑ ⡱ ⣱ ⡉ ⣉ ⡩ ⣩ ⡙ ⣙ ⡹ ⣹
⠅ ⢅ ⠥ ⢥ ⠕ ⢕ ⠵ ⢵ ⠍ ⢍ ⠭ ⢭ ⠝ ⢝ ⠽ ⢽
⡅ ⣅ ⡥ ⣥ ⡕ ⣕ ⡵ ⣵ ⡍ ⣍ ⡭ ⣭ ⡝ ⣝ ⡽ ⣽
⠃ ⢃ ⠣ ⢣ ⠓ ⢓ ⠳ ⢳ ⠋ ⢋ ⠫ ⢫ ⠛ ⢛ ⠻ ⢻
⡃ ⣃ ⡣ ⣣ ⡓ ⣓ ⡳ ⣳ ⡋ ⣋ ⡫ ⣫ ⡛ ⣛ ⡻ ⣻
⠇ ⢇ ⠧ ⢧ ⠗ ⢗ ⠷ ⢷ ⠏ ⢏ ⠯ ⢯ ⠟ ⢟ ⠿ ⢿
⡇ ⣇ ⡧ ⣧ ⡗ ⣗ ⡷ ⣷ ⡏ ⣏ ⡯ ⣯ ⡟ ⣟ ⡿ ⣿]]):gsub('\n',' ')function GenerateDotData()function ToBinary(Cc)local Dc={}while Cc>0 do local Fc=math.fmod(Cc,2)Dc[#Dc+1]=string.sub(Fc,1,1)Cc=(Cc-Fc)/2 end;local Ec=string.reverse(table.concat(Dc))return string.rep('0',8 -#Ec)..Ec end;local function wc(Cc)return Cc end;local xc=Split(qc,' ')local yc={}local zc=false;local Ac=''local Bc=' 'for i=1,#xc do yc[i-1]=wc(xc[i])end;return yc end;bb.Data={}bb.Data.Dot=GenerateDotData()bb.ColorData={reset=0,clear=0,space=0,bright=1,bold=1,dim=2,faint=1,italic=3,underline=4,blink=5,reverse=7,invisible=8,hidden=8,strikethrough=9,black=30,red=31,green=32,yellow=33,blue=34,purple=35,magenta=35,cyan=36,white=37,onblack=40,onred=41,ongreen=42,onyellow=43,onblue=44,onpurple=45,onmagenta=45,oncyan=46,onwhite=47}bb.Color={}for wc,xc in pairs(bb.ColorData)do bb.Color[wc]='\27['..xc..'m'end;local rc,sc=O,P;local tc,uc=-N,N;tc,uc=-20,20;bb.Convert={}bb.Convert.ToDots=function(wc,xc)xc=xc or 0;local yc,zc=rc+xc,sc+xc;local Ac,Bc=wc.Data,wc.Color;local Cc={}local Dc=0;local Ec=bb.Data.Dot[Dc]local Fc=nil;local Gc=nil;local Hc=bb.Color['reset']if wc.Color.All then local Ic=bb.Color[wc.Color.All]Cc[#Cc+1]=Ic;Gc=Ic end;if not tc then return''end;for y=tc,uc,4 do for x=yc,zc,2 do local Ic=Ac[x]local Jc=Ac[x+1]local Kc=(Ic and( (Ic[y]or 0)*128 + (Ic[y+1]or 0)*64 + (Ic[y+2]or 0)*32 + (Ic[y+3]or 0)*16)or 0)+ (Jc and( (Jc[y]or 0)*8 + (Jc[y+1]or 0)*4 + (Jc[y+2]or 0)*2 + (Jc[y+3]or 0))or 0)if Kc~=Dc then Kc=bb.Data.Dot[Kc]if not Gc then local Lc=Bc[x]local Mc=Bc[x+1]local Nc=( (Lc)and(Lc[y]or Lc[y+1]or Lc[y+2]or Lc[y+3]))or( (Mc)and(Mc[y]or Mc[y+1]or Mc[y+2]or Mc[y+3]))if Nc then Nc=bb.Color[Nc]else Nc=Hc end;if Fc==Nc then else Cc[#Cc+1]=Nc;Fc=Nc end end;Cc[#Cc+1]=Kc else Cc[#Cc+1]=Ec end end;Cc[#Cc+1]='\n'end;Cc[#Cc+1]=Hc;return table.concat(Cc)end;bb.ToDotsParallel=function(wc,xc,yc)yc=yc or 0;local zc,Ac=rc+yc,sc+yc;local Bc,Cc=wc.Data,wc.Color;local Dc,Ec=xc.Data,xc.Color;local Fc={}local Gc=0;local Hc=bb.Data.Dot[Gc]local Ic=nil;local Jc=nil;local Kc=bb.Color['reset']if wc.Color.All then local Lc=bb.Color[wc.Color.All]Fc[#Fc+1]=Lc;Jc=Lc end;if not tc then return''end;for y=tc,uc,4 do for x=zc,Ac,2 do local Lc=Bc[x]local Mc=Bc[x+1]local Nc=Dc[x]local Oc=Dc[x+1]local Pc=( (Lc and Nc)and( (Lc[y]or Nc[y]or 0)*128 + (Lc[y+1]or Nc[y+1]or 0)*64 + (Lc[y+2]or Nc[y+2]or 0)*32 + (Lc[y+3]or Nc[y+3]or 0)*16)or(Lc)and( (Lc[y]or 0)*128 + (Lc[y+1]or 0)*64 + (Lc[y+2]or 0)*32 + (Lc[y+3]or 0)*16)or(Nc)and( (Nc[y]or 0)*128 + (Nc[y+1]or 0)*64 + (Nc[y+2]or 0)*32 + (Nc[y+3]or 0)*16)or 0)+ ( (Mc and Oc)and( (Mc[y]or Oc[y]or 0)*8 + (Mc[y+1]or Oc[y+1]or 0)*4 + (Mc[y+2]or Oc[y+2]or 0)*2 + (Mc[y+3]or Oc[y+3]or 0))or(Mc)and( (Mc[y]or 0)*8 + (Mc[y+1]or 0)*4 + (Mc[y+2]or 0)*2 + (Mc[y+3]or 0))or(Oc)and( (Oc[y]or 0)*8 + (Oc[y+1]or 0)*4 + (Oc[y+2]or 0)*2 + (Oc[y+3]or 0))or 0)if Pc~=Gc then Pc=bb.Data.Dot[Pc]if not Jc then local Qc=Ec[x]local Rc=Ec[x+1]local Sc=Cc[x]local Tc=Cc[x+1]local Uc=Sc and(Sc[y]or Sc[y+1]or Sc[y+2]or Sc[y+3])or Tc and(Tc[y]or Tc[y+1]or Tc[y+2]or Tc[y+3])or Qc and(Qc[y]or Qc[y+1]or Qc[y+2]or Qc[y+3])or Rc and(Rc[y]or Rc[y+1]or Rc[y+2]or Rc[y+3])if Uc then Uc=bb.Color[Uc]else Uc=Kc end;if Ic==Uc then else Fc[#Fc+1]=Uc;Ic=Uc end end;Fc[#Fc+1]=Pc else Fc[#Fc+1]=Hc end end;Fc[#Fc+1]='\n'end;Fc[#Fc+1]=Kc;return table.concat(Fc)end;bb.CircleGen=function(wc,xc,yc,zc,Ac)Ac=Ac or{}local Bc=Ac.color;local Cc=zc*zc;local Dc=zc;for y=0,zc do Dc=Dc+1;repeat Dc=Dc-1 until Dc*Dc+y*y<=Cc;for x2=0,Dc do wc.Data[xc+x2]=wc.Data[xc+x2]or{}wc.Data[xc-x2]=wc.Data[xc-x2]or{}wc.Data[xc+x2][yc+y]='1'wc.Data[xc-x2][yc+y]='1'wc.Data[xc+x2][yc-y]='1'wc.Data[xc-x2][yc-y]='1'wc.Color[xc+x2]=wc.Color[xc+x2]or{}wc.Color[xc-x2]=wc.Color[xc-x2]or{}wc.Color[xc+x2][yc+y]=Bc;wc.Color[xc-x2][yc+y]=Bc;wc.Color[xc+x2][yc-y]=Bc;wc.Color[xc-x2][yc-y]=Bc end end;return wc end;local vc={}bb.Circle=function(wc,xc,yc,zc,Ac)local Bc=nil;if vc[zc]then else vc[zc]=bb.CircleGen(bb.New(),0,0,zc)end;local Cc=Ac and Ac.color;Bc=vc[zc]for Dc,Ec in pairs(Bc.Data)do for Fc,Gc in pairs(Ec)do local Hc,Ic=Dc+xc,Fc+yc;wc.Data[Hc]=wc.Data[Hc]or{}wc.Data[Hc][Ic]=Gc;wc.Color[Hc]=wc.Color[Hc]or{}wc.Color[Hc][Ic]=Cc end end;return wc end;bb.New=function()return{Data={},Color={}}end;k=bb end;local function cb(qc)return(qc.data=='note')or(qc.data=='event'and qc.event=='barline')end;local function db(qc,rc)return rc- (( (P+I)/math.abs(qc.speed)))end;local function eb(qc,rc)return(qc.ms-rc)*qc.speed+Q end;local function fb(qc,rc)return qc.loadp- (qc.speed* (rc-qc.loadms))end;local function gb(qc,rc)local sc=math.floor(rc.p)local tc,uc=M-N,M+N;for y=tc,uc do qc.Data[sc]=qc.Data[sc]or{}qc.Data[sc][y]='1'end end;local function hb(qc,rc,sc)sc=sc or rc.p;bb.Circle(qc,math.floor(sc),M,L*rc.radius,S[rc.type])end;local function ib(qc,rc,sc,tc,uc,vc)local wc=vc or{}color=wc.color;for y=tc,uc do for x=rc,sc do qc.Data[x]=qc.Data[x]or{}qc.Data[x][y]='1'if color then qc.Color[x]=qc.Color[x]or{}qc.Color[x][y]=color end end end end;local jb=(O-I)local kb=(P+I)local function lb(qc,rc,sc)local tc=rc.type;if tc==1 or tc==2 or tc==3 or tc==4 then hb(qc,rc)elseif tc==5 or tc==6 then elseif tc==7 then rc.radius=0.8;hb(qc,rc)elseif tc==8 then hb(qc,rc)local uc=rc.startnote;hb(qc,uc)local vc=L*rc.radius;local wc,xc=math.floor(uc.p),math.floor(rc.p)hb(qc,uc,rc.p)local yc=math.floor(M-vc)local zc=math.floor(M+vc)if sc then else if wc>xc then wc,xc=xc,wc end;if wc<jb then wc=jb end;if xc>kb then xc=kb end end;ib(qc,wc,xc,yc,zc,S[uc.type])end end;local function mb(qc,rc,sc,tc)local uc=V/ (U/2)local vc=-uc*math.abs(( (sc-rc.startms)/ (T/U))- (V/uc))+V;local wc=Z[rc.status]local xc=wc.Offset;local yc=wc.Color.All;local zc,Ac=0,-math.floor(L*1.6)-8 -math.floor(vc)local Bc,Cc=xc[1]+zc+tc,xc[2]+Ac;for x=1,Z.Size[1]do for y=1,Z.Size[2]do local Dc,Ec=x+Bc,y+Cc;qc.Data[Dc]=qc.Data[Dc]or{}qc.Data[Dc][Ec]=wc.Data[x]and wc.Data[x][y]qc.Color[Dc]=qc.Color[Dc]or{}qc.Color[Dc][Ec]=yc end end end;local function nb(qc,rc)local sc=ab[rc.status]local tc=sc.Offset;local uc=sc.Color.All;local vc,wc=0,0;for xc,yc in pairs(sc.Data)do for zc,Ac in pairs(yc)do if Ac=='1'then local Bc,Cc=xc+tc[1]+vc,zc+tc[2]+wc;qc.Data[Bc]=qc.Data[Bc]or{}qc.Data[Bc][Cc]=Ac;qc.Color[Bc]=qc.Color[Bc]or{}qc.Color[Bc][Cc]=uc end end end end;local ob={ClearScreen=function()io.write("\27[2J")end,SetCursor=function(qc,rc)io.write(string.format("\27[%d;%dH",rc,qc))end}local pb=Taiko.GetAllNotes(r.Data)local qb=r.Metadata.OFFSET;local rb=1000 /60;local sb=r.Metadata.TIMING(rb/B)local tb={}for qc,rc in pairs(pb)do rc.ms=rc.oms or rc.ms;rc.oms=rc.ms;rc.ms=(rc.ms-qb)/B;rc.s=MsToS(rc.ms)rc.delay=rc.odelay or rc.delay;rc.odelay=rc.delay;rc.delay=rc.delay/B;rc.speed=(Taiko.CalculateSpeed(rc,L))*A;rc.loadms=db(rc,rc.ms)rc.loads=MsToS(rc.loadms)rc.loadp=eb(rc,rc.loadms)rc.hit=nil;tb[#tb+1]=rc.ms end;if C then for sc,tc in pairs(r.Data)do if tc.branch then for uc,vc in pairs(tc.branch.paths)do table.sort(vc,function(wc,xc)return wc.ms<xc.ms end)end end end;table.sort(r.Data,function(sc,tc)if sc.branch and tc.branch then for uc,vc in pairs(sc.branch.paths)do for wc,xc in pairs(tc.branch.paths)do return vc[1].ms<xc[1].ms end end elseif sc.branch then for uc,vc in pairs(sc.branch.paths)do return vc[1].ms<tc.ms end elseif tc.branch then for uc,vc in pairs(tc.branch.paths)do return sc.ms<vc[1].ms end else return sc.ms<tc.ms end end)local qc=nil;local rc=0;Taiko.ForAll(r.Data,function(sc,tc,uc)if sc.delay~=rc then if qc then qc.stopms=sc.delay-qc.delay;qc.stopstart=qc.ms;qc.stopend=qc.stopstart+qc.stopms end;rc=sc.delay end;if qc and qc.delay~=0 then qc.ms=qc.ms-qc.delay;qc.s=MsToS(qc.ms)qc.loadms=db(qc,qc.ms)qc.loads=MsToS(qc.loadms)qc.loadp=eb(qc,qc.loadms)qc.ms=qc.ms+qc.delay;qc.s=MsToS(qc.ms)end;qc=sc end)end;for qc,rc in pairs(r.Data)do if rc.branch then for sc,tc in pairs(rc.branch.paths)do table.sort(tc,function(uc,vc)return uc.loadms<vc.loadms end)end end end;table.sort(r.Data,function(qc,rc)if qc.branch and rc.branch then for sc,tc in pairs(qc.branch.paths)do for uc,vc in pairs(rc.branch.paths)do return tc[1].loadms<vc[1].loadms end end elseif qc.branch then for sc,tc in pairs(qc.branch.paths)do return tc[1].loadms<rc.loadms end elseif rc.branch then for sc,tc in pairs(rc.branch.paths)do return qc.loadms<tc[1].loadms end else return qc.loadms<rc.loadms end end)Taiko.ConnectAll(r.Data)Taiko.ForAll(r.Data,function(qc,rc,sc)qc.n=sc end)local ub=K/B;local vb=tb[1]for i=1,#tb do if tb[i]>vb then vb=tb[i]end end;vb=vb+ub;loaded={}local wb=r.Data[1]local xb=wb.loads;local yb=10;local zb=string.rep(' ',yb)local Ab={}local function Bb(qc,rc)Ab[#Ab+1]=qc;Ab[#Ab+1]=': 'Ab[#Ab+1]=tostring(rc)Ab[#Ab+1]=zb;Ab[#Ab+1]='\n'end;local function Cb()print(table.concat(Ab))Ab={}end;local Db={}local function Eb(qc)Db[#Db+1]=qc end;local function Fb()print(table.concat(Db,'\n'))Db={}end;ob.ClearScreen()local Gb='M'local Hb=0;local Ib,Jb,Kb=r.Metadata.SCOREINIT,r.Metadata.SCOREDIFF,Taiko.Data.ScoreMode.Note[r.Metadata.SCOREMODE]local Lb=0;local Mb=false;local Nb=nil;local Ob=nil;local Pb=nil;local Qb=Taiko.Data.ScoreMode.Balloon[r.Metadata.SCOREMODE]local Rb=Taiko.Data.ScoreMode.BalloonPop[r.Metadata.SCOREMODE]local Sb=nil;local Tb=nil;local Ub=nil;local Vb=Taiko.Data.ScoreMode.Drumroll[r.Metadata.SCOREMODE]local Wb={startms=nil,status=nil}local Xb=nil;local Yb=nil;local Zb=nil;local ac=0;local bc={-1,nil}local cc=0;local dc=0;local ec=true;local fc=false;local gc=false;local hc=nil;local ic=nil;local jc=nil;local kc=nil;local lc=nil;local mc=nil;local nc=os.clock()local oc,pc;if w then oc=1 /w;pc=nc+oc end;if not v.on then while true do local qc=bb.New()local rc=os.clock()local sc=rc-nc;local tc=sc*1000;if Zb and tc>Zb then Xb,Yb,Zb=nil,nil,nil end;if Pb and tc>Pb then Nb,Ob,Pb=nil,nil,nil end;if Ub and tc>Ub then Sb,Tb,Ub=nil,nil,nil end;if wb then if wb.loadms<tc then loaded[#loaded+1]=wb;if gc and wb.speed~=hc then gc=false end;if gc then wb.p=fb(wb,lc)if wb.data=='event'then if wb.event=='barline'then gb(jc,wb,gc)end elseif wb.data=='note'then lb(jc,wb,gc)else error('Invalid note.data')end end;wb=wb.nextnote;if wb and wb.branch then wb=wb.branch.paths[Gb][1]end end else if tc>vb then break end end;if fc and gc==false then local Cc=nil;for i=1,#loaded do if Cc then if loaded[i]and Cc~=loaded[i].speed then Cc=false;break end else Cc=loaded[i].speed end end;if Cc then lc=tc;hc=Cc;jc=false;kc=loaded[1]gc=true else gc=false end end;local uc=0;if gc and jc then ec=false;local Cc=loaded[1]local Dc=ic or Cc.p;ic=Dc;local Ec=fb(kc,tc)Dc=Dc or Ec;local Fc=math.floor(Dc-Ec+0.5)if Fc>=1 then uc=Fc else end;qc=jc else ic=nil;ec=true end;if ec and jc~=false then bb.Circle(qc,math.floor(Q),M,L,{color='purple'})end;if gc then mc=bb.New()bb.Circle(mc,math.floor(Q)+uc,M,L,{color='purple'})end;local vc={}local wc={}local xc=0;for i=1,#loaded do local Cc=i+xc;local Dc=loaded[Cc]if Dc then if Dc.data=='note'then if(Dc.type==1 or Dc.type==3)and(not vc[1]or math.abs(tc-Dc.ms)<vc[1])then vc[1]=math.abs(tc-Dc.ms)wc[1]=Dc elseif(Dc.type==2 or Dc.type==4)and(not vc[2]or math.abs(tc-Dc.ms)<vc[2])then vc[2]=math.abs(tc-Dc.ms)wc[2]=Dc end end;Dc.p=fb(Dc,Xb or(tc+ac))if tc>Dc.ms then Mb=Dc.gogo;if Dc.type==7 then if Nb then if Nb.n==Dc.n then Dc.p=Q else end end;Nb=Dc;Ob=Dc.ms;Pb=Dc.ms+Dc.length elseif Dc.type==5 or Dc.type==6 then Sb=Dc;Tb=Dc.ms;Ub=Dc.ms+Dc.length end end;if C and Dc.stopstart and tc>Dc.stopstart then Xb=ac+Dc.stopstart;stopms=Dc.stopms;ac=ac-Dc.stopms;Yb=Dc.stopstart;Zb=Dc.stopend;Dc.stopstart=nil end;if(Dc.hit or math.abs(Dc.p-Q)> ( (Dc.delay*math.abs(Dc.speed))+P+J))and(not(Dc.endnote and Dc.endnote.done~=true and(not Dc.hit)))then Dc.done=true;table.remove(loaded,Cc)xc=xc-1 else if ec then if Dc.data=='event'then if Dc.event=='barline'then gb(qc,Dc)end elseif Dc.data=='note'then lb(qc,Dc)else error('Invalid note.data')end end end end end;if jc==false then jc=qc end;if Wb.status then if tc>Wb.startms+T then Wb={}else if gc then mb(mc,Wb,tc,uc)else mb(qc,Wb,tc,uc)end end end;ob.SetCursor(1,1)if gc then if mc then print(bb.ToDotsParallel(qc,mc,uc))else print(bb.Convert.ToDots(qc,uc))end else if w then local Cc=bb.Convert.ToDots(qc,uc)repeat until os.clock()>=pc;pc=pc+oc;print(Cc)else print(bb.Convert.ToDots(qc,uc))end end;cc=cc+1;local yc=os.clock()-rc;dc=dc+yc;local zc=l.getch(Y)local Ac=l.getkeyname(zc)local Bc=D.Hit[Ac]if z then local Cc=vc[1]local Dc=vc[2]local Ec=(vc[1]and vc[2])and( (vc[1]<vc[2])and 1 or 2)or(vc[1]and 1 or 2)local Fc=vc[Ec]local Gc=wc[Ec]if Fc and tc>=Gc.ms and(not Gc.hit)then Bc=Ec elseif not Fc or(Fc and Fc> (sb.bad* ( ( (Gc.type==3 or Gc.type==4)and Taiko.Data.BigLeniency)or 1)))then if Ob and(tc>Ob and tc<Pb)then Bc=1 elseif Tb and(tc>Tb and tc<Ub)then Bc=1 end end end;if Bc then if vc[Bc]and(not wc[Bc].hit)then local Cc=wc[Bc]local Dc=Cc.type;local Ec=Cc.gogo;local Fc=vc[Bc]local Gc;local Hc=( (Dc==3 or Dc==4)and Taiko.Data.BigLeniency)or 1;if Fc< (sb.good)then Gc=( (Dc==3 or Dc==4)and 3)or 2;Lb=Lb+1 elseif Fc< (sb.ok*Hc)then Gc=1;Lb=Lb+1 elseif Fc< (sb.bad*Hc)then Gc=0;Lb=0 else Gc=nil end;if Gc then Hb=Kb(Hb,Lb,Ib,Jb,Gc,Ec)wc[Bc].hit=true;Wb={startms=tc,status=Gc}end end;if(Bc==1)and Ob and(tc>Ob and tc<Pb)then Hb=Qb(Hb,Nb.type,notegogo)end;if(Bc==1 or Bc==2)and Tb and(tc>Tb and tc<Ub)then Hb=Vb(Hb,Sb.type,notegogo)end end;if D.Escape[Ac]then local Cc=os.clock()ob.ClearScreen()l.nodelay(Y,false)local Dc={'Back','Retry','Back to Select'}while true do ob.SetCursor(1,1)local Ec={}for i=1,#Dc do Ec[i]=( (i==E)and(G..string.rep(' ',F-#G))or string.rep(' ',F))..Dc[i]end;print(table.concat(Ec,H))local Fc=l.getch(Y)local Gc=l.getkeyname(Fc)if D.L[Gc]then E=E==1 and 1 or E-1 elseif D.R[Gc]then E=E==3 and 3 or E+1 elseif D.Select[Gc]then if E==1 then elseif E==2 then return'Retry'elseif E==3 then return nil end;break elseif D.Escape[Gc]then break end end;l.nodelay(Y,true)nc=nc+ (os.clock()-Cc)end;if zc~=-1 then bc={zc,Ac}end;Bb('Input (ascii)',bc[1])Bb('Input (key)',bc[2])Bb('S',sc)Bb('Ms',tc)Bb('Loaded',#loaded)Bb('Frames Rendered',cc)Bb('Last Frame Render (ms)',yc*1000)Bb('Frame Render Total (ms)',dc*1000)Bb('Frame Render Total (%)',dc/sc*100)Bb('FPS (Frame)',cc/sc)Bb('Score',Hb)Bb('Combo',Lb)Bb('Gogo',Mb)Bb('Drumroll Start',Tb)Bb('Drumroll End',Ub)Cb()Fb()end else error('Prerendering has been removed')end;return true end;function Taiko.SongSelect(r,s,t)local u={}local v,w=10,10;local x,y,z,A=-v,v,-w,w;local B=true;local C=1;local D=1;local E=4;local F=5;local G=5;local H=2;local I='V'local J='>'local K=10;local L=nil;local M='>'local N='>'local O=2;local P=true;local Q=t or{}local R=false;local S={[2]={'Normal','Auto'},[3]={'Normal','2x Speed','3x Speed','4x Speed','0.25x Speed','0.5x Speed','0.75x Speed'},[4]={'Normal','2x Speed','3x Speed','4x Speed','0.25x Speed','0.5x Speed','0.75x Speed'},[5]={'Normal','Reverse','Invisible','Messy'}}local T={4,1,1,1,1,1}local U={nil}for nb,ob in pairs(S)do U[nb]={1,#ob,ob}end;local V={window=l.initscr()}l.keypad(V,true)l.echo(false)l.raw(true)l.nl(false)l.cbreak(true)l.nodelay(V,true)l.getch(V)l.nodelay(V,false)local W,X=l.cols(),l.lines()L=L or W-2;local Y={Escape={['\27']=true,ALT_ESC=true},Scroll={L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_A2=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true}},Select={Init={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Escape={['\27']=true,ALT_ESC=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true},U={KEY_UP=true,KEY_A2=true},D={KEY_DOWN=true,KEY_C2=true},Play={Hit={['4']=2,['v']=1,['n']=1,['8']=2},Escape={['\27']=true,ALT_ESC=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_DOWN=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}}},Search={Init={ALT_F=true,f=true,F=true},Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},FirstResult={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Select={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true},Up={KEY_A2=true,KEY_UP=true},Down={KEY_C2=true,KEY_DOWN=true},Escape={['\27']=true,ALT_ESC=true}},Add={Init={ALT_N=true,n=true,N=true},Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}},StandardInput={Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},Escape={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_DOWN=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true}},Reload={Init={r=true}},ReloadAll={Init={R=true}},Rename={Init={KEY_F2=true}}}local Z={ClearScreen=function()io.write("\27[2J")end,SetCursor=function(nb,ob)io.write(string.format("\27[%d;%dH",ob,nb))end,ClearLine=function()io.write("\27[2K")end,CursorLeft=function(nb)io.write(string.format("\27[%dD",nb))end,CursorRight=function(nb)io.write(string.format("\27[%dC",nb))end,SaveCursor=function()io.write("\27[s")end,RestoreCursor=function()io.write("\27[u")end}local function ab(nb)return nb..string.rep(' ',L-#nb)end;local function bb()local nb=l.getch(V)local ob=l.getkeyname(nb)return nb,ob end;local function cb()local nb=''local ob=0;local pb=ob;while true do local qb,rb=bb()if Y.StandardInput.Backspace[rb]then nb=string.sub(nb,1,ob-1)..string.sub(nb,ob+1,-1)ob=ob-1 elseif Y.StandardInput.Escape[rb]then io.write('\n')return nb elseif Y.StandardInput.L[rb]then ob=ob-1 elseif Y.StandardInput.R[rb]then ob=ob+1 else nb=string.sub(nb,1,ob)..rb..string.sub(nb,ob+1,-1)ob=ob+1 end;ob=ClipN(ob,0,#nb)local sb=ob-pb;if sb<0 then Z.CursorLeft(-sb)elseif sb>0 then Z.CursorRight(sb)end;Z.SaveCursor()Z.ClearLine()io.write('\r')io.write(nb)Z.RestoreCursor()pb=ob end end;local function db(nb)return nb>=32 and nb<=126 end;local function eb(nb,ob,pb,qb)return(nb and(ob..string.sub(pb,#ob+1,-1))or pb)..qb end;local function fb(nb,ob,pb)return nb>pb and ob or nb<ob and pb or nb end;local gb={[0]='No',[1]='Yes'}local function hb(nb)return nb and gb[1]or gb[0]end;local function ib(nb)return nb*100 ..'%'end;local function jb(nb)return MsToS(nb)..'s'end;local function kb(nb)return jb(SToMs(nb))end;local function lb(nb)return tonumber(nb)and tonumber(nb)or 0 end;local mb={}Z.ClearScreen()while true do u={}if B then u[x]={}for i=C-F,C+F do local rb=nil;if i<1 then rb=#r+i elseif i>#r then rb=i-#r else rb=i end;local sb=r[rb]if sb then u[0]=u[0]or{}u[0][(i-C)*G]=sb end end;local pb={}local qb=string.rep(' ',H)for y=z,A do pb[#pb+1]=eb(y==0,J,qb,'')pb[#pb+1]=ab(u[0]and u[0][y]or'')pb[#pb+1]='\n'end;Z.SetCursor(1,1)print(table.concat(pb))else u[0]={}u[0][z]=I;for i=C-F,C+F do local qb=nil;if i<1 then qb=#r+i elseif i>#r then qb=i-#r else qb=i end;local rb=r[qb]if rb then local sb=(i-C)*G;u[sb]=u[sb]or{}local tb=z+H;for i2=1,#rb do u[sb][tb]=string.sub(rb,i2,i2)tb=tb+1 end end end;local pb={}for y=z,A do for x=x,y do if u[x]and u[x][y]then local qb=u[x][y]if db(string.byte(qb))then pb[#pb+1]=qb else pb[#pb+1]=' 'end else pb[#pb+1]=' 'end end;pb[#pb+1]='\n'end;Z.SetCursor(1,1)print(table.concat(pb))end;local nb,ob=bb()if Y.Scroll.L[ob]then C=C-1 elseif Y.Scroll.R[ob]then C=C+1 elseif Y.Select.Init[ob]then local pb;if P then if mb[C]then pb=mb[C]else pb=Taiko.ParseTJA(s[C])mb[C]=pb end else pb=Taiko.ParseTJA(s[C])end;local qb={}for ub,vb in pairs(pb)do qb[#qb+1]={ub,vb.Metadata.COURSE}end;table.sort(qb,function(ub,vb)return ub[2]<vb[2]end)min=1;max=#qb;U[1]={min,max,qb}DifficultyMap=qb;T[1]=ClipN(T[1],min,max)local rb=string.rep(' ',O)Z.ClearScreen()Z.SetCursor(1,1)local sb=nil;local tb=D;while true do D=ClipN(D,1,5)if D~=tb then E=T[D]tb=D end;local ub=U[D]min,max=ub[1],ub[2]E=fb(E,min,max)T[D]=E;Z.SetCursor(1,1)local vb=DifficultyMap[T[1]][2]sb=Taiko.GetDifficulty(pb,vb)local wb=sb.Metadata;local xb=Taiko.Analyze(sb)local yb={{'',wb.TITLE},{'\t',wb.SUBTITLE},{'',''},{'','Select Options:'},{eb(D==1,N,rb,'Difficulty: '),Taiko.Data.CourseName[wb.COURSE]},{eb(D==2,N,rb,'Mode: '),S[2][T[2]]},{eb(D==3,N,rb,'Note Speed: '),S[3][T[3]]},{eb(D==4,N,rb,'Song Speed: '),S[4][T[4]]},{eb(D==5,N,rb,'Modifiers: '),S[5][T[5]]},{'',''},{'Difficulty: ',Taiko.Data.CourseName[wb.COURSE]},{'Stars: ',wb.LEVEL},{'Diverge Notes: ',hb(wb.DIVERGENOTES)},{'',''},{'','Statistics:'},{'Length: ',jb(xb.lengthms)},{'Don (DON) / Ka (KA): ',lb(xb.notes[1])..' + ('..lb(xb.notes[3])..') / '..lb(xb.notes[2])..' + ('..lb(xb.notes[4])..') = '..ib((lb(xb.notes[1])+lb(xb.notes[3]))/xb.notes.validn)..' / '..ib((lb(xb.notes[2])+lb(xb.notes[4]))/xb.notes.validn)},{'Max Score (without drumroll): ',xb.maxscore},{'Max Combo: ',xb.maxcombo},{'Drumroll Time (total): ',jb(xb.drumrollms+xb.drumrollbigms)},{'Balloon Time: ',jb(xb.balloonms)},{'Balloon Hits: ',xb.balloonhit},{'Special Time: ',jb(xb.specialms)},{'Special Hits: ',xb.specialhit},{'',''},{'','Press Enter to Play!'}}for i=1,#yb do local Bb=yb[i]print(ab(Bb[1]..tostring(Bb[2])))end;local zb,Ab=bb()if Y.Select.L[Ab]then E=E-1 elseif Y.Select.R[Ab]then E=E+1 elseif Y.Select.U[Ab]then D=D-1 elseif Y.Select.D[Ab]then D=D+1 elseif Y.Select.Select[Ab]then while true do local Bb,Cb=Taiko.PlaySong(Taiko.GetDifficulty(pb,vb),V,T,Y.Select.Play)if Bb and Cb then break elseif Bb=='Retry'then else break end end;l.nodelay(V,false)Z.ClearScreen()elseif Y.Select.Escape[Ab]then break end end elseif Y.Search.Init[ob]then local pb=''local qb={}local rb=1;local sb=nil;local tb=1;Z.ClearScreen()Z.SetCursor(1,1)print('Searching...')while true do Z.SetCursor(#pb+1,2)local ub,vb=bb()Z.SetCursor(1,2)if Y.Search.Backspace[vb]then pb=string.sub(pb,1,-2)elseif Y.Search.FirstResult[vb]then sb=qb[1]break elseif Y.Search.Select[vb]then sb=qb[tb]break elseif Y.Search.Down[vb]then tb=tb+1 elseif Y.Search.Up[vb]then tb=tb-1 elseif Y.Search.Escape[vb]then break else pb=pb..vb end;print(ab(pb))local wb=m.SearchHeaderAll(r,pb)for i=1,K do if wb[i][2]==-math.huge then rb=i-1;break elseif i==K then rb=i end end;tb=ClipN(tb,1,rb)local xb=false;for i=1,K do local yb=wb[i]if xb then print(ab(''))else if yb then if yb[2]==-math.huge then xb=true;print(ab(''))else print(ab((i==tb and M or i)..'. '..wb[i][3]))qb[i]=yb end end end end end;C=(sb and sb[1]or C)or C elseif Y.Add.Init[ob]then print('Import a Custom Song')while true do print('Enter a .tja or .tjac file path (with the file extention)')local pb=cb()local qb=io.open(pb,'rb')if qb then local rb=qb:read('*all')if EndsWith(pb,'.tja')then print('Enter a song name')local sb=cb()local tb=#r+1;r[tb]=sb;s[tb]=rb;Q[tb]={pb}break elseif EndsWith(pb,'.tjac')then local sb,tb=m.Decompress(rb)for i=1,#sb do local ub=#r+1;r[ub]=tb[i]s[ub]=sb[i]Q[ub]={pb,sb}end;break else print('Invalid file type')end;qb:close()else print('Unable to read file')end end elseif Y.Reload.Init[ob]then print('Reloading selected file...')if Q[C]then local pb=Q[C]local qb=io.open(pb[1],'rb')if qb then local rb=qb:read('*all')local sb=C;if pb[2]then local tb,ub=m.Decompress(rb)if R then r[sb]=ub[i]end;s[sb]=tb[i]else s[sb]=rb end;if P then mb[sb]=nil end;qb:close()else print('Unable to read file')end else print('File source not found')end elseif Y.ReloadAll.Init[ob]then print('Reloading all files...')local pb={}for qb,rb in pairs(Q)do pb[rb[1]]=pb[rb[1]]and pb[rb[1]]or{}pb[rb[1]][#pb[rb[1]]+1]={qb,rb[2]}end;for qb,rb in pairs(pb)do local sb=io.open(qb,'rb')if sb then local tb=sb:read('*all')if rb[1][2]then local ub,vb=m.Decompress(tb)for i=1,#rb do local wb=rb[i]if R then r[wb[1]]=vb[wb[2]]end;s[wb[1]]=ub[wb[2]]if P then mb[wb[1]]=nil end end else for i=1,#rb do local ub=rb[i]s[ub[1]]=tb;if P then mb[ub[1]]=nil end end end;sb:close()else print('Unable to read file')end end elseif Y.Rename.Init[ob]then print('Enter a song name')local pb=cb()r[C]=pb elseif Y.Escape[ob]then return end;C=fb(C,1,#r)end end;function Taiko.Game()end;local n='./CompactTJA/taikobuipm.tjac'n='./CompactTJA/ESE/06 Classical.tjac'n='./CompactTJA/ESE/ESE.tjac'local o='./tja/neta/ekiben/neta.tja'local p=io.open(o)local q=p:read('*all')p:close()Taiko.SongSelect({'neta'},{q},{{o}})error()Taiko.PlaySong(Taiko.GetDifficulty(Taiko.ParseTJA(m.InputFile(n)),'Ura'))
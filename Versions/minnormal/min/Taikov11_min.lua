Split=function(f,g)local h={}for i,j in f:gmatch("([^"..g.."]*)("..g.."?)")do table.insert(h,i)if j==''then return h end end end;Trim=function(f)local g=f:gsub("^%s*(.-)%s*$","%1")return g end;TrimLeft=function(f)local g=f:gsub("^%s*(.-)$","%1")return g end;TrimRight=function(f)local g=f:gsub("^(.-)%s*$","%1")return g end;StartsWith=function(f,g)return f:sub(1,#g)==g end;EndsWith=function(f,g)return f:sub(-#g,-1)==g end;Table={}function Table.Clone(f,g)g=g or{}local h=type(f)local i;if h=='table'then if g[f]then i=g[f]else i={}g[f]=i;for j,k in next,f,nil do i[Table.Clone(j,g)]=Table.Clone(k,g)end;setmetatable(i,Table.Clone(getmetatable(f),g))end else i=f end;return i end;ClipN=function(f,g,h)if f<g then return g elseif f>h then return h else return f end end;function Error(f)print(f)end;LineN=nil;function ParseError(f,g,h)Error('Line: '..LineN..'\n'..f..': '..g.. (h and(', '..h)or''))end;function MsToS(f)return f/1000 end;function SToMs(f)return f*1000 end;Taiko={}Taiko.Data={Languages={'','EN','JA','CN','TW','KO'},GenreName={Pop={'pop','j-pop'},Anime={'anime','アニメ'},Kids={'kids','どうよう'},Variety={'variety','バラエティ'},VOCALOID={'vocaloid','ボーカロイド'},Classic={'classic','クラシック'},['Game Music']={'game music','ゲームミュージック'},['Namco Original']={'namco original','ナムコオリジナル'}},CourseId={easy=0,normal=1,hard=2,oni=3,edit=4,tower=5,dan=6,ura=4},CourseName={[0]='Easy','Normal','Hard','Oni','Edit','Tower','Dan','Ura'},RatingMultiplier={[0]=0,[1]=0.5,[2]=1,[3]=2},ScoreMode={[0]=function(f,g,h,i,j)return f+ ( ( (g<200)and(h or 1000)or( (h or 1000)+ (i or 1000)))*Taiko.Data.RatingMultiplier[j])end,[1]=function(f,g,h,i,j)return f+ (h+math.max(0,i*math.floor((math.min(g,100)-1)/10)))*Taiko.Data.RatingMultiplier[j]end,[2]=function(f,g,h,i,j)return f+ (h+i* ( (g>=100)and 8 or(g>=50)and 4 or(g>=30)and 2 or(g>=10)and 1 or 0))*Taiko.Data.RatingMultiplier[j]end},Autoscore={[0]=function(f)end,[1]=function(f)end,[2]=function(f)end},SideId={normal=1,ex=2,both=3},SideName={'normal','ex','both'},StyleId={single=1,double=2,couple=2},StyleName={'single','double'},Exam={Condition={g=true,jp=true,jg=true,jb=true,s=true,r=true,h=true,c=true},Scope={m=true,l=true}},Branch={PathId={N=0,E=1,M=2},PathName={[0]='N',[1]='E',[2]='M'},Requirements={r=function()end,p=function()end}},Timing={GetFunction=function(f)return function(g)if f==1 then return{good=5 /2 *g,ok=13 /2 *g,bad=15 /2 *g}else return{good=3 /2 *g,ok=9 /2 *g,bad=13 /2 *g}end end end},StatusId={bad=0,ok=1,good=2,biggood=3},StatusName={[0]='BAD',[1]='OK',[2]='GOOD',[3]='GOOD'},ModeId={['']=0,P1=1,P2=2},ModeName={[0]='',P1,P2}}for f,g in pairs(Taiko.Data.ScoreMode)do Taiko.Data.ScoreMode[f]=function(...)return math.floor(g(...)/10)*10 end end;function Taiko.ParseTJA(f)local g=os.clock()local h={}local i={Metadata={BPM=120,WAVE='main.mp3',OFFSET=0,DEMOSTART=0,SCOREMODE=1,SONGVOL=100,SEVOL=100,SIDE=3,LIFE=0,GAME='Taiko',HEADSCROLL=1,MOVIEOFFSET=0,COURSE='ONI',LEVEL=0,BALLOON=nil,SCOREINIT,SCOREDIFF,BALLOONNOR=nil,BALLOONEXP=nil,BALLOONMAS=nil,STYLE=1,EXAM1=nil,EXAM2=nil,EXAM3=nil,GAUGEINCR='NORMAL',TOTAL=nil,HIDDENBRANCH=0,DIVERGENOTES=false,SCOREINIT=0,SCOREDIFF=0},Data={}}local function j(u)local v=Taiko.Data.Languages;for i=1,#v do local w=i.Metadata[u..v[i]]if w then return w end end;return nil end;local function k(u,v,w)local x=tonumber(v)if x then return x else ParseError(u,w,v)end end;local function l(u,v,w,x)if v then return v else ParseError(u,w,x)end end;local function m(u,v,w)local x={['true']=true,['false']=false,yes=true,no=false,['1']=true,['0']=false,[1]=true,[0]=false}local y=x[v]~=nil;if y then return y else ParseError(u,w,v)end end;local function n(u,v)local w=','local x='\\'local y={}local z=''local A=false;for i=1,#v do local B=string.sub(v,i,i)if A then z=z..B;A=false else if B==w then table.insert(y,z)z=''elseif B==x then A=true else z=z..B end end end;table.insert(y,z)return y end;local function o(u,v,w)local x=n(u,v)for i=1,#x do x[i]=k(u,x[i],w,v)end;return x end;local function p(u,v,w)if v and v~=''then return o(u,v,w)else return{}end end;local function q(u,v,w)if v and v~=''then local x=n(u,v,w)l(u,Taiko.Data.Exam.Condition[x[1]],w)x[2]=k(u,x[2],w)x[3]=k(u,x[3],w)l(u,Taiko.Data.Exam.Scope[x[4]],w)return x else return{}end end;local r={}local function s()local u={settings={noteparse={notealias={A=3,B=4},noteexceptions={[',']=true,[' ']=true,['\t']=true}},command={matchexceptions={}}},bpm=0,ms=0,songstarted=false,timingpoint=nil,sign=4 /4,mpm=0,mspermeasure=0,scroll=1,measuredone=true,currentmeasure={},measurepushto=i.Data,barline=true,gogo=false,lastlong=nil,balloonn=1,currentbranch=nil,branch={on=false,requirements={},paths={}},msbeforebranch=nil}function u.createnote(v)if v then local w={ms=nil,data=nil,type=v,txt=nil,gogo=u.gogo,scroll=(u.scroll*i.Metadata.HEADSCROLL),mspermeasure=u.mspermeasure,bpm=u.bpm,nextnote=nil,radius=1,requiredhits=nil,length=nil,endnote=nil,onnotepush=nil}w.type=v;if v==3 or v==4 or v==6 then w.radius=w.radius*1.6 end;if v==5 or v==6 or v==7 or v==9 then if u.lastlong then if v==9 then else ParseError('parser.noteparse','Last long note has not ended')end else u.lastlong=w;if v==7 or v==9 then w.requiredhits=l('parser.noteparse',i.Metadata.BALLOON[u.balloonn],'Invalid number of balloons',u.balloonn)u.balloonn=u.balloonn+1 end end end;if v==8 then local x=u.lastlong;u.lastlong=nil;w.startnote=x;if x then w.onnotepush=function()x.length=w.ms-x.ms;x.endnote=w end else end end;return w else return{ms=nil,data=nil,type=nil,txt=nil,gogo=u.gogo,scroll=(u.scroll*i.Metadata.HEADSCROLL),mspermeasure=u.mspermeasure,bpm=u.bpm,nextnote=nil}end end;function u.endbranch()local v=u.createnote()v.data='event'v.event='branch'v.branch={requirements=u.branch.requirements,paths=u.branch.paths}u.branch.on=false;u.branch.requirements={}u.branch.paths={}table.insert(i.Data,v)u.measurepushto=i.Data end;return u end;r=s()local t=Split(f,'\n')for i=1,#t do LineN=i;local u=Trim(t[i])if StartsWith(u,'//')or u==''then else local v=string.find(u,'//')if v then u=string.sub(u,1,v-1)end;local w=false;if r.songstarted==false and w==false then local x={string.match(u,'(%u+):(.*)')}if x[1]then local y=Trim(x[2])if y~=''then i.Metadata[Trim(x[1])]=y end;w=true end end;if(r.songstarted or StartsWith(u,'#START'))and w==false then local x={string.match(u,'#(%u-)%s(.*)')}if not x[1]then x={string.match(u,'#(%u+)')}end;if x[1]then if x[1]=='START'then if r.songstarted then ParseError(x[1],'Song has already started')else i.OriginalMetadata=Table.Clone(i.Metadata)if x[2]then i.Metadata.MODE=l(x[1],Taiko.Data.ModeId[x[2]],'Invalid mode',x[2])else i.Metadata.MODE=0 end;i.Metadata.TITLE=l(x[1],j('TITLE'),'Title is missing')i.Metadata.SUBTITLE=l(x[1],j('SUBTITLE'),'Subtitle is missing')i.Metadata.BPM=k(x[1],i.Metadata.BPM,'Invalid bpm')i.Metadata.OFFSET=SToMs(k(x[1],i.Metadata.OFFSET,'Invalid offset'))i.Metadata.DEMOSTART=SToMs(k(x[1],i.Metadata.DEMOSTART,'Invalid demostart'))if i.Metadata.DEMOSTART==0 then i.Metadata.DEMOSTART=nil end;for B,C in pairs(Taiko.Data.GenreName)do for i=1,#C do if C[i]==i.Metadata.GENRE then i.Metadata.GENRE=B end end end;i.Metadata.SCOREMODE=k(x[1],i.Metadata.SCOREMODE,'Invalid scoremode')l(x[1],Taiko.Data.ScoreMode[i.Metadata.SCOREMODE],'Invalid scoremode',i.Metadata.SCOREMODE)if i.Metadata.MAKER then i.Metadata.CREATORURLT={}i.Metadata.CREATOR=Trim(string.gsub(i.Metadata.MAKER,'(<.->)',function(B)table.insert(i.Metadata.CREATORURLT,string.sub(B,2,-2))return''end))i.Metadata.CREATORURL=table.concat(i.Metadata.CREATORURLT,', ')i.Metadata.CREATIVE=false else i.Metadata.CREATIVE=false end;i.Metadata.SONGVOL=k(x[1],i.Metadata.SONGVOL,'Invalid songvol')/100;i.Metadata.SEVOL=k(x[1],i.Metadata.SEVOL,'Invalid sevol')/100;local y=tonumber(i.Metadata.SIDE)if y then l(x[1],Taiko.Data.SideName[y],'Invalid side id',i.Metadata.SIDE)i.Metadata.SIDE=y else i.Metadata.SIDE=l(x[1],Taiko.Data.SideId[string.lower(i.Metadata.SIDE)],'Invalid side name',i.Metadata.SIDE)end;i.Metadata.LIFE=k(x[1],i.Metadata.LIFE,'Invalid life')if i.Metadata.LIFE==0 then i.Metadata.LIFE=nil end;i.Metadata.GAME=string.lower(i.Metadata.GAME)if i.Metadata.GAME=='taiko'then elseif i.Metadata.GAME=='jube'then else end;i.Metadata.HEADSCROLL=k(x[1],i.Metadata.HEADSCROLL,'Invalid headscroll')i.Metadata.MOVIEOFFSET=k(x[1],i.Metadata.MOVIEOFFSET,'Invalid movieoffset')local z=tonumber(i.Metadata.COURSE)if z then l(x[1],Taiko.Data.CourseName[z],'Invalid course id',i.Metadata.COURSE)i.Metadata.COURSE=z else i.Metadata.COURSE=l(x[1],Taiko.Data.CourseId[string.lower(i.Metadata.COURSE)],'Invalid course name',i.Metadata.COURSE)end;i.Metadata.TIMING=Taiko.Data.Timing.GetFunction(i.Metadata.COURSE)i.Metadata.LEVEL=ClipN(math.floor(k(x[1],i.Metadata.LEVEL,'Invalid level')),0,10)i.Metadata.BALLOON=p(x[1],i.Metadata.BALLOON,'Invalid balloon')i.Metadata.SCOREINIT=k(x[1],i.Metadata.SCOREINIT,'Invalid scoreinit')i.Metadata.SCOREDIFF=k(x[1],i.Metadata.SCOREDIFF,'Invalid scoreinit')i.Metadata.BALLOONNOR=p(x[1],i.Metadata.BALLOONNOR,'Invalid balloonnor')i.Metadata.BALLOONEXP=p(x[1],i.Metadata.BALLOONEXP,'Invalid balloonexp')i.Metadata.BALLOONMAS=p(x[1],i.Metadata.BALLOONMAS,'Invalid balloonmas')local A=tonumber(i.Metadata.STYLE)if A then l(x[1],Taiko.Data.StyleName[A],'Invalid style id',Taiko.Data.STYLE)i.Metadata.STYLE=A else i.Metadata.STYLE=l(x[1],Taiko.Data.StyleId[string.lower(i.Metadata.STYLE)],'Invalid style name',i.Metadata.STYLE)end;i.Metadata.EXAM1=q(i.Metadata.EXAM1)i.Metadata.EXAM2=q(i.Metadata.EXAM2)i.Metadata.EXAM3=q(i.Metadata.EXAM3)i.Metadata.GAUGEINCR=string.lower(i.Metadata.GAUGEINCR)if i.Metadata.TOTAL then i.Metadata.TOTAL=k(x[1],i.Metadata.TOTAL,'Invalid total')end;i.Metadata.HIDDENBRANCH=m(x[1],i.Metadata.HIDDENBRANCH,'Invalid hiddenbranch')r.bpm=i.Metadata.BPM;r.songstarted=true end elseif x[1]=='END'then if r.songstarted then if#r.currentmeasure~=0 then ParseError(x[1],'Current measure is not empty')end;table.insert(h,i)i={Metadata=Table.Clone(i.OriginalMetadata),Data={}}r=s()r.songstarted=false;r.measurepushto=i.Data else ParseError(x[1],'Song has already ended')end elseif x[1]=='MEASURE'then local y,z=string.match(x[2],'(%d+)/(%d+)')y=k(x[1],y,'Invalid measure')z=k(x[1],z,'Invalid measure')r.sign=(y/z)or r.sign elseif x[1]=='BPMCHANGE'then r.bpm=k(x[1],x[2],'Invalid bpmchange')or r.bpm elseif x[1]=='DELAY'then table.insert(r.currentmeasure,{x[1],SToMs((k(x[1],x[2],'Invalid delay')or 0))})elseif x[1]=='SCROLL'then r.scroll=k(x[1],x[2],'Invalid scroll')or r.scroll;if r.scroll==0 then ParseError(x[1],'Scroll cannot be 0')end elseif x[1]=='GOGOSTART'then r.gogo=true elseif x[1]=='GOGOEND'then r.gogo=false elseif x[1]=='BARLINEOFF'then r.barline=false elseif x[1]=='BARLINEON'then r.barline=true elseif x[1]=='BRANCHSTART'then if r.branch.on then r.endbranch()end;r.msbeforebranch=r.ms;r.branch.on=true;i.Metadata.DIVERGENOTES=true;local y=n(x[1],x[2])local z=l(x[1],Taiko.Data.Branch.Requirements[string.lower(y[1])],'Invalid type',y[1])r.branch.requirements={z}local A=2;while true do if not y[A]then break end;local B=Taiko.Data.Branch.PathName[A-1]if B then r.branch.requirements[B]=y[A]else break end;A=A+1 end elseif Taiko.Data.Branch.PathId[x[1]]then if r.branch.on then r.ms=r.msbeforebranch;r.currentbranch=x[1]r.branch.paths[x[1]]={}r.measurepushto=r.branch.paths[x[1]]else ParseError(x[1],'Branch has not started')end elseif x[1]=='BRANCHEND'then if r.branch.on then r.endbranch()else ParseError(x[1],'Branch has already ended')end elseif x[1]=='SECTION'then elseif x[1]=='LYRIC'then elseif x[1]=='LEVELHOLD'then elseif x[1]=='BMSCROLL'then elseif x[1]=='HBSCROLL'then elseif x[1]=='SENOTECHANGE'then elseif x[1]=='NEXTSONG'then elseif x[1]=='DIRECTION'then elseif x[1]=='SUDDEN'then elseif x[1]=='JPOSSCROLL'then else end;w=true end end;if(r.songstarted)and w==false then r.mpm=r.bpm*r.sign/4;r.mspermeasure=60000 *r.sign*4 /r.bpm;if r.barline and#r.currentmeasure==0 then local x=r.createnote()x.ms=r.ms;x.data='event'x.event='barline'table.insert(r.measurepushto,1,x)end;for i=1,#u do local x=string.sub(u,i,i)if r.settings.noteparse.noteexceptions[x]then else local y=k('parser.noteparse',tonumber(x)or r.settings.noteparse.notealias[x]or x,'Invalid note')if y then local z=r.createnote(y)z.data='note'table.insert(r.currentmeasure,z)end end end;if EndsWith(TrimRight(u),',')then r.mpm=r.bpm*r.sign/4;r.mspermeasure=60000 *r.sign*4 /r.bpm;if#r.currentmeasure==0 then r.ms=r.ms+r.mspermeasure else local x=0;local y=nil;for i=1,#r.currentmeasure do local A=r.currentmeasure[i]if A.data=='note'then y=y or A.mspermeasure;x=x+1 end end;y=y or r.mspermeasure;local z=y/x;for i=1,#r.currentmeasure do local A=r.currentmeasure[i]if A[1]=='DELAY'then r.ms=r.ms+A[2]else if A.type~=0 then A.ms=r.ms;local B=i.Data[#i.Data]if B then B.nextnote=A end;table.insert(r.measurepushto,A)if A.onnotepush then A.onnotepush()end;z=A.mspermeasure/x end end;r.ms=r.ms+z end end;r.measuredone=true;r.currentmeasure={}else r.measuredone=false end end end end;print('Parsing Took: '..SToMs(os.clock()-g)..'ms')return h end;function Taiko.Analyze(f)for i=1,#f.Data do end end;function Taiko.GetDifficulty(f,g)local h=Taiko.Data.CourseId[string.lower(g)]or g;for i,j in pairs(f)do if j.Metadata.COURSE==h then return j end end;Error('No difficulty found, '..g)return nil end;function Taiko.ForAll(g,h)local i=1;for i=1,#g do local j=g[i]if j.branch then local k=-1;for l,m in pairs(j.branch.paths)do local o=i;for i2=1,#m do h(m[i2],i2,o)o=o+1 end;k=(k<o)and o or k end;i=k else h(j,i,i)end;i=i+1 end;return g end;function Taiko.GetAllNotes(f)local g={}for h,i in pairs(f)do if i.branch then for j,l in pairs(i.branch.paths)do for i=1,#l do table.insert(g,l[i])end end else table.insert(g,i)end end;return g end;function Taiko.ConnectNotes(f)local g=nil;for i=#f,1,-1 do local h=f[i]h.nextnote=g;g=h end;return f end;function Taiko.ExtractBranch(f,g)return f.branch.paths[g]end;function Taiko.ConnectAll(f)local g=nil;for i=#f,1,-1 do local h=f[i]if h.branch then for j,l in pairs(h.branch.paths)do local m=Taiko.ConnectNotes(l)m[#m].nextnote=g end else h.nextnote=g end;g=h end end;function Taiko.CalculateSpeed(f,g)local h=(g*f.scroll*f.bpm/7500)return h end;function Taiko.CalculateSpeedAll(f,g)for i=1,#f do f[i].speed=Taiko.CalculateSpeed(f[i],g)end;return f end;function Taiko.RenderScale(f)local g={}local h={}local i={}for i=1,#f.Data do local m=f.Data[i]if m.data=='note'then local n=math.floor(m.ms)if math.floor(n)-n==0 then table.insert(g,{n,m.type})table.insert(h,n)else table.insert(i,i)end end end;function gcd2(m,n)if n==0 then return m else return gcd2(n,m%n)end end;function gcdn(m)local n=m[1]for i=2,#m do n=gcd2(n,m[i])end;return n end;local j=gcdn(h)for i=1,#i do local m=g[i[i]]m[1]=math.floor(m[1]/j)*j end;local k=''local l=0;for i=1,#g do g[i][1]=g[i][1]/j;k=k..string.rep(' ',g[i][1]-l)..g[i][2]l=g[i][1]end;return k end;function Taiko.PlaySong(f,g)local h={on=false,fps=60,frames={}}local i=true;local j=false;local k={['4']=2,['v']=1,['n']=1,['8']=2}local l=10;local m=1000;local n=4;local o=0;local p=10;local q=0;local r=40;local s=3;local u=1;local v={[1]={color='red'},[2]={color='blue'},[3]={color='red'},[4]={color='blue'},[5]={color='yellow'},[6]={color='yellow'}}local w=200;local x=w/4;local z=4;local A=20;r=math.floor(r*n)local B=q+r;s=math.floor(s*n)local C=require('taikocurses')local D={window=C.initscr()}C.keypad(D,true)C.echo(false)C.raw(true)C.nl(false)C.cbreak(true)C.nodelay(D,true)local E=require('Pixels')local F={[0]={Data={[1]={'0','1','1','1','1','1','1','1'},[2]={[2]='1',[5]='1',[8]='1'},[3]={[2]='1',[5]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={[3]='1',[4]='1',[6]='1',[7]='1'},[8]={'0','0','1','1','1','1','1','1'},[9]={[2]='1',[5]='1'},[10]={[2]='1',[5]='1'},[11]={[2]='1',[5]='1'},[12]={[2]='1',[5]='1'},[13]={'0','0','1','1','1','1','1','1'},[15]={'0','1','1','1','1','1','1','1'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'}},Color={All='blue'},Offset={-1,0}},[1]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[8]='1'},[5]={[2]='1',[8]='1'},[6]={'0','0','1','1','1','1','1','0'},[8]={'0','1','1','1','1','1','1','1'},[9]={[5]='1'},[10]={[4]='1',[6]='1'},[11]={[3]='1',[7]='1'},[12]={[2]='1',[8]='1'}},Color={All='white'},Offset={-1,0}},[2]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={'0','1','0','0','1','1','1','1'},[8]={'0','0','1','1','1','1','1','0'},[9]={[2]='1',[8]='1'},[10]={[2]='1',[8]='1'},[11]={[2]='1',[8]='1'},[12]={[2]='1',[8]='1'},[13]={'0','0','1','1','1','1','1','0'},[15]={'0','0','1','1','1','1','1','0'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'},[22]={'0','1','1','1','1','1','1','1'},[23]={[2]='1',[8]='1'},[24]={[2]='1',[8]='1'},[25]={[2]='1',[8]='1'},[26]={[2]='1',[8]='1'},[27]={'0','0','1','1','1','1','1','0'}},Color={All='yellow'},Offset={-1,0}}}F[3]=F[2]local G={[0]=nil,[1]={},[2]={}}local H={}for vb,wb in pairs(E.Color.Data)do H[vb]='\27['..wb..'m'end;E.Color=H;local I,J=q,r;local K,L=-p,p;K,L=-20,20;E.Convert.ToDots=function(vb)vb=GetPixelData(vb)local wb,xb=vb.Data,vb.Color;local yb={}local zb=string.rep('0',8)local Ab=E.Data.Dot[zb]local Bb=nil;local Cb=nil;local Db=E.Color['reset']if vb.Color.All then local Eb=E.Color[vb.Color.All]table.insert(yb,Eb)Cb=Eb end;if not K then return''end;for y=K,L,4 do for x=I,J,2 do local Eb=wb[x]local Fb=wb[x+1]local Gb=( (Eb)and( (Eb[y]or'0').. (Eb[y+1]or'0').. (Eb[y+2]or'0').. (Eb[y+3]or'0'))or'0000').. ( (Fb)and( (Fb[y]or'0').. (Fb[y+1]or'0').. (Fb[y+2]or'0').. (Fb[y+3]or'0'))or'0000')if Gb~=zb then Gb=E.Data.Dot[Gb]if not Cb then local Hb=xb[x]local Ib=xb[x+1]local Jb=( (Hb)and(Hb[y]or Hb[y+1]or Hb[y+2]or Hb[y+3]))or( (Ib)and(Ib[y]or Ib[y+1]or Ib[y+2]or Ib[y+3]))if Jb then Jb=E.Color[Jb]else Jb=Db end;if Bb==Jb then else table.insert(yb,Jb)Bb=Jb end end;table.insert(yb,Gb)else table.insert(yb,Ab)end end;table.insert(yb,'\n')end;table.insert(yb,Db)return table.concat(yb)end;E.CircleGen=function(vb,wb,xb,yb,zb)str=GetPixelData(vb)zb=zb or{}local Ab=zb.color;local Bb=yb*yb;local Cb=yb;for y=0,yb do Cb=Cb+1;repeat Cb=Cb-1 until Cb*Cb+y*y<=Bb;for x2=0,Cb do str.Data[wb+x2]=str.Data[wb+x2]or{}str.Data[wb-x2]=str.Data[wb-x2]or{}str.Data[wb+x2][xb+y]='1'str.Data[wb-x2][xb+y]='1'str.Data[wb+x2][xb-y]='1'str.Data[wb-x2][xb-y]='1'str.Color[wb+x2]=str.Color[wb+x2]or{}str.Color[wb-x2]=str.Color[wb-x2]or{}str.Color[wb+x2][xb+y]=Ab;str.Color[wb-x2][xb+y]=Ab;str.Color[wb+x2][xb-y]=Ab;str.Color[wb-x2][xb-y]=Ab end end;return str end;local M={}E.Circle=function(vb,wb,xb,yb,zb)local Ab=GetPixelData(vb)local Bb=nil;if M[yb]then else M[yb]=E.CircleGen(E.New(),0,0,yb)end;local Cb=zb and zb.color;Bb=M[yb]for Db,Eb in pairs(Bb.Data)do for Fb,Gb in pairs(Eb)do local Hb,Ib=Db+wb,Fb+xb;Ab.Data[Hb]=Ab.Data[Hb]or{}Ab.Data[Hb][Ib]=Gb;Ab.Color[Hb]=Ab.Color[Hb]or{}Ab.Color[Hb][Ib]=Cb end end;return Ab end;E.New=function()return{Data={},Color={}}end;local function N(vb,wb)local xb=math.floor(wb.p)local yb,zb=o-p,o+p;for y=yb,zb do local Ab=vb.Data[xb]and vb.Data[xb][y]if Ab=='0'or Ab==nil then vb.Data[xb]=vb.Data[xb]or{}vb.Data[xb][y]='1'end end end;local function O(vb,wb,xb)xb=xb or wb.p;E.Circle(vb,math.floor(xb),o,n*wb.radius,v[wb.type])end;local function P(vb,wb,xb,yb,zb,Ab)local Bb=Ab or{}color=Bb.color;local Cb=(q-l)if wb<Cb then wb=Cb end;local Db=(r+l)if xb>Db then xb=Db end;for y=yb,zb do for x=wb,xb do vb.Data[x]=vb.Data[x]or{}vb.Data[x][y]='1'if color then vb.Color[x]=vb.Color[x]or{}vb.Color[x][y]=color end end end end;local function Q(vb,wb)local xb=wb.type;if xb==1 or xb==2 or xb==3 or xb==4 then O(vb,wb)elseif xb==5 or xb==6 then O(vb,wb)local yb=wb.endnote;local zb=(yb.ms-wb.ms)*wb.speed;O(vb,wb)local Ab=n*wb.radius;local Bb,Cb=math.floor(wb.p),math.floor(wb.p+zb)local Db=math.floor(o-Ab)local Eb=math.floor(o+Ab)P(vb,Bb,Cb,Db,Eb,v[wb.type])elseif xb==8 then O(vb,wb.startnote,wb.p)end end;local function R(vb,wb,xb)local yb=z/ (x/2)local zb=-yb*math.abs(( (xb-wb.startms)/ (w/x))- (z/yb))+z;local Ab=F[wb.status]local Bb=Ab.Offset;local Cb=Ab.Color.All;local Db,Eb=0,-math.floor(n*1.6)-8 -math.floor(zb)for Fb,Gb in pairs(Ab.Data)do for Hb,Ib in pairs(Gb)do if Ib=='1'then local Jb,Kb=Fb+Bb[1]+Db,Hb+Bb[2]+Eb;vb.Data[Jb]=vb.Data[Jb]or{}vb.Data[Jb][Kb]=Ib;vb.Color[Jb]=vb.Color[Jb]or{}vb.Color[Jb][Kb]=Cb end end end end;local function S(vb,wb)local xb=G[wb.status]local yb=xb.Offset;local zb=xb.Color.All;local Ab,Bb=0,0;for Cb,Db in pairs(xb.Data)do for Eb,Fb in pairs(Db)do if Fb=='1'then local Gb,Hb=Cb+yb[1]+Ab,Eb+yb[2]+Bb;vb.Data[Gb]=vb.Data[Gb]or{}vb.Data[Gb][Hb]=Fb;vb.Color[Gb]=vb.Color[Gb]or{}vb.Color[Gb][Hb]=zb end end end end;local T={ClearScreen=function()io.write("\27[2J")end,SetCursor=function(vb,wb)io.write(string.format("\27[%d;%dH",wb,vb))end}f=Taiko.GetDifficulty(f,g)local U=Taiko.GetAllNotes(f.Data)local V=f.Metadata.OFFSET;local W=1000 /60;local X=f.Metadata.TIMING(W)local function Y(vb)return(vb.data=='note')or(vb.data=='event'and vb.event=='barline')end;local function Z(vb,wb)return wb- (( (r+l)/math.abs(vb.speed)))end;local function ab(vb,wb)return(vb.ms-wb)*vb.speed+s end;local function bb(vb,wb)return vb.loadp- (vb.speed* (wb-vb.loadms))end;local cb={}for vb,wb in pairs(U)do wb.ms=wb.ms-V;wb.s=MsToS(wb.ms)wb.speed=Taiko.CalculateSpeed(wb,n)wb.loadms=Z(wb,wb.ms)wb.loads=MsToS(wb.loadms)wb.loadp=ab(wb,wb.loadms)table.insert(cb,wb.ms)end;for vb,wb in pairs(f.Data)do if wb.branch then for xb,yb in pairs(wb.branch.paths)do table.sort(yb,function(zb,Ab)return zb.loadms<Ab.loadms end)end end end;table.sort(f.Data,function(vb,wb)if vb.branch and wb.branch then for xb,yb in pairs(vb.branch.paths)do for zb,Ab in pairs(wb.branch.paths)do return yb[1].loadms<Ab[1].loadms end end elseif vb.branch then for xb,yb in pairs(vb.branch.paths)do return yb[1].loadms<wb.loadms end elseif wb.branch then for xb,yb in pairs(wb.branch.paths)do return vb.loadms<yb[1].loadms end else return vb.loadms<wb.loadms end end)Taiko.ConnectAll(f.Data)Taiko.ForAll(f.Data,function(vb,wb,xb)vb.n=xb end)local db=math.max(unpack(cb))+m;local eb={s=1,e=0,n=0}local fb=f.Data[1]local gb=fb.loads;eb.e=eb.n;local hb=10;local ib=string.rep(' ',hb)local jb={}local function kb(vb,wb)table.insert(jb,vb)table.insert(jb,': ')table.insert(jb,tostring(wb))table.insert(jb,ib)table.insert(jb,'\n')end;local function lb()print(table.concat(jb))jb={}end;local mb=''local function nb(vb)mb=mb..'\n'..vb end;local function ob()print(mb)end;T.ClearScreen()local pb='M'local qb={startms=nil,status=nil}local rb=-1;local sb=0;local tb=0;local ub=os.clock()if not h.on then while true do local vb=E.New()local wb=os.clock()local xb=wb-ub;local yb=xb*1000;if fb then if fb.loadms<yb then eb.n=eb.n+1;eb.e=fb.n;eb[fb.n]=fb;fb=fb.nextnote;if fb and fb.branch then fb=fb.branch.paths[pb][1]end end else if yb>db then break end end;E.Circle(vb,math.floor(s),o,n,{color='purple'})local zb={}local Ab={}for i=eb.s,eb.e do local Eb=eb[i]if Eb then if Eb.data=='note'then if(Eb.type==1 or Eb.type==3)and(not zb[1]or math.abs(yb-Eb.ms)<zb[1])then zb[1]=math.abs(yb-Eb.ms)Ab[1]=Eb elseif(Eb.type==2 or Eb.type==4)and(not zb[2]or math.abs(yb-Eb.ms)<zb[2])then zb[2]=math.abs(yb-Eb.ms)Ab[2]=Eb end end;Eb.p=bb(Eb,yb)if math.abs(Eb.p-s)> (r+l+1)then if Eb.endnote and Eb.endnote.done~=true then else Eb.done=true;eb[i]=nil;if fb and eb.n==0 then eb.s=fb.n elseif Eb.n==eb.s then if Eb.n==eb.e then eb.n=0 else local Fb=eb.s;repeat Fb=Fb+1;eb.n=eb.n-1 until eb[Fb]eb.s=Fb end end end else if Eb.data=='event'then if Eb.event=='barline'then N(vb,Eb)end elseif Eb.data=='note'then Q(vb,Eb)else error('Invalid note.data')end end end end;if qb.status then if yb>qb.startms+w then qb={}else R(vb,qb,yb)end end;T.SetCursor(1,1)print(E.Convert.ToDots(vb))sb=sb+1;local Bb=os.clock()-wb;tb=tb+Bb;local Cb=C.getch(D)Cb=C.getkeyname(Cb)local Db=k[Cb]if i then local Eb=zb[1]local Fb=zb[2]local Gb=(zb[1]and zb[2])and( (zb[1]<zb[2])and 1 or 2)or(zb[1]and 1 or 2)local Hb=zb[Gb]if Hb and Hb<10 then if j then Db=Gb else local Ib=Ab[Gb].type;local Jb=( (Ib==3 or Ib==4)and 3)or 2;qb={startms=yb,status=Jb}end end end;if Db and zb[Db]then local Eb=zb[Db]local Fb;if Eb<X.good then local Gb=Ab[Db].type;Fb=( (Gb==3 or Gb==4)and 3)or 2 elseif Eb<X.ok then Fb=1 elseif Eb<X.bad then Fb=0 else Fb=nil end;if Fb then qb={startms=yb,status=Fb}end end;if Cb~='-1'then rb=Cb end;kb('Input (ascii)',rb)kb('Input (key)',C.getkeyname(rb))kb('S',xb)kb('Ms',yb)kb('Loaded',eb.n)kb('Frames Rendered',sb)kb('Last Frame Render (s)',Bb)kb('Last Frame Render (ms)',Bb*1000)kb('Frame Render Total (s)',tb)kb('Frame Render Total (ms)',tb*1000)kb('Frame Render Total (%)',tb/xb*100)kb('FPS (Frame)',sb/xb)kb('Memory Usage (mb)',collectgarbage('count')/1000)kb('Finished (%)',yb/ (db)*100)kb('Nearest1 (ms)',zb[1])kb('Nearest2 (ms)',zb[2])kb('Song Name',f.Metadata.TITLE)kb('Difficulty (id)',f.Metadata.COURSE)kb('Stars',f.Metadata.LEVEL)lb()ob()end else error('Prerendering has been removed')end end;local d='./CompactTJA/taikobuipm.tjac'd='./CompactTJA/ESE/06 Classical.tjac'd='./CompactTJA/ESE/ESE.tjac'local e=require('./CompactTJA/compactv4')Taiko.PlaySong(Taiko.ParseTJA(e.InputFile(d)),'Ura')
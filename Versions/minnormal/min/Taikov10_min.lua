Split=function(f,g)local h={}for i,j in f:gmatch("([^"..g.."]*)("..g.."?)")do table.insert(h,i)if j==''then return h end end end;Trim=function(f)local g=f:gsub("^%s*(.-)%s*$","%1")return g end;TrimLeft=function(f)local g=f:gsub("^%s*(.-)$","%1")return g end;TrimRight=function(f)local g=f:gsub("^(.-)%s*$","%1")return g end;StartsWith=function(f,g)return f:sub(1,#g)==g end;EndsWith=function(f,g)return f:sub(-#g,-1)==g end;Table={}function Table.Clone(f,g)g=g or{}local h=type(f)local i;if h=='table'then if g[f]then i=g[f]else i={}g[f]=i;for j,k in next,f,nil do i[Table.Clone(j,g)]=Table.Clone(k,g)end;setmetatable(i,Table.Clone(getmetatable(f),g))end else i=f end;return i end;ClipN=function(f,g,h)if f<g then return g elseif f>h then return h else return f end end;function Error(f)error(f)end;LineN=nil;function ParseError(f,g,h)Error('Line: '..LineN..'\n'..f..': '..g.. (h and(', '..h)or''))end;function MsToS(f)return f/1000 end;function SToMs(f)return f*1000 end;Taiko={}Taiko.Data={Languages={'','EN','JA','CN','TW','KO'},GenreName={Pop={'pop','j-pop'},Anime={'anime','アニメ'},Kids={'kids','どうよう'},Variety={'variety','バラエティ'},VOCALOID={'vocaloid','ボーカロイド'},Classic={'classic','クラシック'},['Game Music']={'game music','ゲームミュージック'},['Namco Original']={'namco original','ナムコオリジナル'}},CourseId={easy=0,normal=1,hard=2,oni=3,edit=4,tower=5,dan=6,ura=4},CourseName={[0]='Easy','Normal','Hard','Oni','Edit','Tower','Dan','Ura'},RatingMultiplier={[0]=0,[1]=0.5,[2]=1,[3]=2},ScoreMode={[0]=function(f,g,h,i,j)return f+ ( ( (g<200)and(h or 1000)or( (h or 1000)+ (i or 1000)))*Taiko.Data.RatingMultiplier[j])end,[1]=function(f,g,h,i,j)return f+ (h+math.max(0,i*math.floor((math.min(g,100)-1)/10)))*Taiko.Data.RatingMultiplier[j]end,[2]=function(f,g,h,i,j)return f+ (h+i* ( (g>=100)and 8 or(g>=50)and 4 or(g>=30)and 2 or(g>=10)and 1 or 0))*Taiko.Data.RatingMultiplier[j]end},Autoscore={[0]=function(f)end,[1]=function(f)end,[2]=function(f)end},SideId={normal=1,ex=2,both=3},SideName={'normal','ex','both'},StyleId={single=1,double=2,couple=2},StyleName={'single','double'},Exam={Condition={g=true,jp=true,jg=true,jb=true,s=true,r=true,h=true,c=true},Scope={m=true,l=true}},Branch={PathId={N=0,E=1,M=2},PathName={[0]='N',[1]='E',[2]='M'},Requirements={r=function()end,p=function()end}},Timing={GetFunction=function(f)return function(g)if f==1 then return{good=5 /2 *g,ok=13 /2 *g,bad=15 /2 *g}else return{good=3 /2 *g,ok=9 /2 *g,bad=13 /2 *g}end end end},StatusId={bad=0,ok=1,good=2,biggood=3},StatusName={[0]='BAD',[1]='OK',[2]='GOOD',[3]='GOOD'},ModeId={['']=0,P1=1,P2=2},ModeName={[0]='',P1,P2}}for f,g in pairs(Taiko.Data.ScoreMode)do Taiko.Data.ScoreMode[f]=function(...)return math.floor(g(...)/10)*10 end end;function Taiko.ParseTJA(f)local g=os.clock()local h={}local i={Metadata={BPM=120,WAVE='main.mp3',OFFSET=0,DEMOSTART=0,SCOREMODE=1,SONGVOL=100,SEVOL=100,SIDE=3,LIFE=0,GAME='Taiko',HEADSCROLL=1,MOVIEOFFSET=0,COURSE='ONI',LEVEL=0,BALLOON=nil,SCOREINIT,SCOREDIFF,BALLOONNOR=nil,BALLOONEXP=nil,BALLOONMAS=nil,STYLE=1,EXAM1=nil,EXAM2=nil,EXAM3=nil,GAUGEINCR='NORMAL',TOTAL=nil,HIDDENBRANCH=0,DIVERGENOTES=false,SCOREINIT=0,SCOREDIFF=0},Data={}}local function j(u)local v=Taiko.Data.Languages;for i=1,#v do local w=i.Metadata[u..v[i]]if w then return w end end;return nil end;local function k(u,v,w)local x=tonumber(v)if x then return x else ParseError(u,w,v)end end;local function l(u,v,w,x)if v then return v else ParseError(u,w,x)end end;local function m(u,v,w)local x={['true']=true,['false']=false,yes=true,no=false,['1']=true,['0']=false,[1]=true,[0]=false}local y=x[v]~=nil;if y then return y else ParseError(u,w,v)end end;local function n(u,v)local w=','local x='\\'local y={}local z=''local A=false;for i=1,#v do local B=string.sub(v,i,i)if A then z=z..B;A=false else if B==w then table.insert(y,z)z=''elseif B==x then A=true else z=z..B end end end;table.insert(y,z)return y end;local function o(u,v,w)local x=n(u,v)for i=1,#x do x[i]=k(u,x[i],w,v)end;return x end;local function p(u,v,w)if v and v~=''then return o(u,v,w)else return{}end end;local function q(u,v,w)if v and v~=''then local x=n(u,v,w)l(u,Taiko.Data.Exam.Condition[x[1]],w)x[2]=k(u,x[2],w)x[3]=k(u,x[3],w)l(u,Taiko.Data.Exam.Scope[x[4]],w)return x else return{}end end;local r={}local function s()local u={settings={noteparse={notealias={A=3,B=4},noteexceptions={[',']=true,[' ']=true,['\t']=true}},command={matchexceptions={}}},bpm=0,ms=0,songstarted=false,timingpoint=nil,sign=4 /4,mpm=0,mspermeasure=0,scroll=1,measuredone=true,currentmeasure={},measurepushto=i.Data,barline=true,gogo=false,lastlong=nil,balloonn=1,currentbranch=nil,branch={on=false,requirements={},paths={}},msbeforebranch=nil}function u.createnote(v)if v then local w={ms=nil,data=nil,type=v,txt=nil,gogo=u.gogo,scroll=(u.scroll*i.Metadata.HEADSCROLL),mspermeasure=u.mspermeasure,bpm=u.bpm,nextnote=nil,radius=1,requiredhits=nil,length=nil,endnote=nil,onnotepush=nil}w.type=v;if v==3 or v==4 or v==6 then w.radius=w.radius*1.6 end;if v==5 or v==6 or v==7 or v==9 then if u.lastlong then if v==9 then else ParseError('parser.noteparse','Last long note has not ended')end else u.lastlong=w;if v==7 or v==9 then w.requiredhits=l('parser.noteparse',i.Metadata.BALLOON[u.balloonn],'Invalid number of balloons',u.balloonn)u.balloonn=u.balloonn+1 end end end;if v==8 then local x=u.lastlong;u.lastlong=nil;w.startnote=x;if x then w.onnotepush=function()x.length=w.ms-x.ms;x.endnote=w end else end end;return w else return{ms=nil,data=nil,type=nil,txt=nil,gogo=u.gogo,scroll=(u.scroll*i.Metadata.HEADSCROLL),mspermeasure=u.mspermeasure,bpm=u.bpm,nextnote=nil}end end;function u.endbranch()local v=u.createnote()v.data='event'v.event='branch'v.branch={requirements=u.branch.requirements,paths=u.branch.paths}u.branch.on=false;u.branch.requirements={}u.branch.paths={}table.insert(i.Data,v)u.measurepushto=i.Data end;return u end;r=s()local t=Split(f,'\n')for i=1,#t do LineN=i;local u=Trim(t[i])if StartsWith(u,'//')or u==''then else local v=string.find(u,'//')if v then u=string.sub(u,1,v-1)end;local w=false;if r.songstarted==false and w==false then local x={string.match(u,'(%u+):(.*)')}if x[1]then local y=Trim(x[2])if y~=''then i.Metadata[Trim(x[1])]=y end;w=true end end;if(r.songstarted or StartsWith(u,'#START'))and w==false then local x={string.match(u,'#(%u-)%s(.*)')}if not x[1]then x={string.match(u,'#(%u+)')}end;if x[1]then if x[1]=='START'then if r.songstarted then ParseError(x[1],'Song has already started')else i.OriginalMetadata=Table.Clone(i.Metadata)if x[2]then i.Metadata.MODE=l(x[1],Taiko.Data.ModeId[x[2]],'Invalid mode',x[2])else i.Metadata.MODE=0 end;i.Metadata.TITLE=l(x[1],j('TITLE'),'Title is missing')i.Metadata.SUBTITLE=l(x[1],j('SUBTITLE'),'Subtitle is missing')i.Metadata.BPM=k(x[1],i.Metadata.BPM,'Invalid bpm')i.Metadata.OFFSET=SToMs(k(x[1],i.Metadata.OFFSET,'Invalid offset'))i.Metadata.DEMOSTART=SToMs(k(x[1],i.Metadata.DEMOSTART,'Invalid demostart'))if i.Metadata.DEMOSTART==0 then i.Metadata.DEMOSTART=nil end;for B,C in pairs(Taiko.Data.GenreName)do for i=1,#C do if C[i]==i.Metadata.GENRE then i.Metadata.GENRE=B end end end;i.Metadata.SCOREMODE=k(x[1],i.Metadata.SCOREMODE,'Invalid scoremode')l(x[1],Taiko.Data.ScoreMode[i.Metadata.SCOREMODE],'Invalid scoremode',i.Metadata.SCOREMODE)if i.Metadata.MAKER then i.Metadata.CREATORURLT={}i.Metadata.CREATOR=Trim(string.gsub(i.Metadata.MAKER,'(<.->)',function(B)table.insert(i.Metadata.CREATORURLT,string.sub(B,2,-2))return''end))i.Metadata.CREATORURL=table.concat(i.Metadata.CREATORURLT,', ')i.Metadata.CREATIVE=false else i.Metadata.CREATIVE=false end;i.Metadata.SONGVOL=k(x[1],i.Metadata.SONGVOL,'Invalid songvol')/100;i.Metadata.SEVOL=k(x[1],i.Metadata.SEVOL,'Invalid sevol')/100;local y=tonumber(i.Metadata.SIDE)if y then l(x[1],Taiko.Data.SideName[y],'Invalid side id',i.Metadata.SIDE)i.Metadata.SIDE=y else i.Metadata.SIDE=l(x[1],Taiko.Data.SideId[string.lower(i.Metadata.SIDE)],'Invalid side name',i.Metadata.SIDE)end;i.Metadata.LIFE=k(x[1],i.Metadata.LIFE,'Invalid life')if i.Metadata.LIFE==0 then i.Metadata.LIFE=nil end;i.Metadata.GAME=string.lower(i.Metadata.GAME)if i.Metadata.GAME=='taiko'then elseif i.Metadata.GAME=='jube'then else end;i.Metadata.HEADSCROLL=k(x[1],i.Metadata.HEADSCROLL,'Invalid headscroll')i.Metadata.MOVIEOFFSET=k(x[1],i.Metadata.MOVIEOFFSET,'Invalid movieoffset')local z=tonumber(i.Metadata.COURSE)if z then l(x[1],Taiko.Data.CourseName[z],'Invalid course id',i.Metadata.COURSE)i.Metadata.COURSE=z else i.Metadata.COURSE=l(x[1],Taiko.Data.CourseId[string.lower(i.Metadata.COURSE)],'Invalid course name',i.Metadata.COURSE)end;i.Metadata.TIMING=Taiko.Data.Timing.GetFunction(i.Metadata.COURSE)i.Metadata.LEVEL=ClipN(math.floor(k(x[1],i.Metadata.LEVEL,'Invalid level')),0,10)i.Metadata.BALLOON=p(x[1],i.Metadata.BALLOON,'Invalid balloon')i.Metadata.SCOREINIT=k(x[1],i.Metadata.SCOREINIT,'Invalid scoreinit')i.Metadata.SCOREDIFF=k(x[1],i.Metadata.SCOREDIFF,'Invalid scoreinit')i.Metadata.BALLOONNOR=p(x[1],i.Metadata.BALLOONNOR,'Invalid balloonnor')i.Metadata.BALLOONEXP=p(x[1],i.Metadata.BALLOONEXP,'Invalid balloonexp')i.Metadata.BALLOONMAS=p(x[1],i.Metadata.BALLOONMAS,'Invalid balloonmas')local A=tonumber(i.Metadata.STYLE)if A then l(x[1],Taiko.Data.StyleName[A],'Invalid style id',Taiko.Data.STYLE)i.Metadata.STYLE=A else i.Metadata.STYLE=l(x[1],Taiko.Data.StyleId[string.lower(i.Metadata.STYLE)],'Invalid style name',i.Metadata.STYLE)end;i.Metadata.EXAM1=q(i.Metadata.EXAM1)i.Metadata.EXAM2=q(i.Metadata.EXAM2)i.Metadata.EXAM3=q(i.Metadata.EXAM3)i.Metadata.GAUGEINCR=string.lower(i.Metadata.GAUGEINCR)if i.Metadata.TOTAL then i.Metadata.TOTAL=k(x[1],i.Metadata.TOTAL,'Invalid total')end;i.Metadata.HIDDENBRANCH=m(x[1],i.Metadata.HIDDENBRANCH,'Invalid hiddenbranch')r.bpm=i.Metadata.BPM;r.songstarted=true end elseif x[1]=='END'then if r.songstarted then if#r.currentmeasure~=0 then ParseError(x[1],'Current measure is not empty')end;table.insert(h,i)i={Metadata=Table.Clone(i.OriginalMetadata),Data={}}r=s()r.songstarted=false;r.measurepushto=i.Data else ParseError(x[1],'Song has already ended')end elseif x[1]=='MEASURE'then local y,z=string.match(x[2],'(%d+)/(%d+)')y=k(x[1],y,'Invalid measure')z=k(x[1],z,'Invalid measure')r.sign=(y/z)or r.sign elseif x[1]=='BPMCHANGE'then r.bpm=k(x[1],x[2],'Invalid bpmchange')or r.bpm elseif x[1]=='DELAY'then table.insert(r.currentmeasure,{x[1],SToMs((k(x[1],x[2],'Invalid delay')or 0))})elseif x[1]=='SCROLL'then r.scroll=k(x[1],x[2],'Invalid scroll')or r.scroll;if r.scroll==0 then ParseError(x[1],'Scroll cannot be 0')end elseif x[1]=='GOGOSTART'then r.gogo=true elseif x[1]=='GOGOEND'then r.gogo=false elseif x[1]=='BARLINEOFF'then r.barline=false elseif x[1]=='BARLINEON'then r.barline=true elseif x[1]=='BRANCHSTART'then if r.branch.on then r.endbranch()end;r.msbeforebranch=r.ms;r.branch.on=true;i.Metadata.DIVERGENOTES=true;local y=n(x[1],x[2])local z=l(x[1],Taiko.Data.Branch.Requirements[string.lower(y[1])],'Invalid type',y[1])r.branch.requirements={z}local A=2;while true do if not y[A]then break end;local B=Taiko.Data.Branch.PathName[A-1]if B then r.branch.requirements[B]=y[A]else break end;A=A+1 end elseif Taiko.Data.Branch.PathId[x[1]]then if r.branch.on then r.ms=r.msbeforebranch;r.currentbranch=x[1]r.branch.paths[x[1]]={}r.measurepushto=r.branch.paths[x[1]]else ParseError(x[1],'Branch has not started')end elseif x[1]=='BRANCHEND'then if r.branch.on then r.endbranch()else ParseError(x[1],'Branch has already ended')end elseif x[1]=='SECTION'then elseif x[1]=='LYRIC'then elseif x[1]=='LEVELHOLD'then elseif x[1]=='BMSCROLL'then elseif x[1]=='HBSCROLL'then elseif x[1]=='SENOTECHANGE'then elseif x[1]=='NEXTSONG'then elseif x[1]=='DIRECTION'then elseif x[1]=='SUDDEN'then elseif x[1]=='JPOSSCROLL'then else end;w=true end end;if(r.songstarted)and w==false then r.mpm=r.bpm*r.sign/4;r.mspermeasure=60000 *r.sign*4 /r.bpm;if r.barline and#r.currentmeasure==0 then local x=r.createnote()x.ms=r.ms;x.data='event'x.event='barline'table.insert(r.measurepushto,1,x)end;for i=1,#u do local x=string.sub(u,i,i)if r.settings.noteparse.noteexceptions[x]then else local y=k('parser.noteparse',tonumber(x)or r.settings.noteparse.notealias[x]or x,'Invalid note')if y then local z=r.createnote(y)z.data='note'table.insert(r.currentmeasure,z)end end end;if EndsWith(TrimRight(u),',')then r.mpm=r.bpm*r.sign/4;r.mspermeasure=60000 *r.sign*4 /r.bpm;if#r.currentmeasure==0 then r.ms=r.ms+r.mspermeasure else local x=0;local y=nil;for i=1,#r.currentmeasure do local A=r.currentmeasure[i]if A.data=='note'then y=y or A.mspermeasure;x=x+1 end end;local z=y/x;for i=1,#r.currentmeasure do local A=r.currentmeasure[i]if A[1]=='DELAY'then r.ms=r.ms+A[2]else if A.type~=0 then A.ms=r.ms;local B=i.Data[#i.Data]if B then B.nextnote=A end;table.insert(r.measurepushto,A)if A.onnotepush then A.onnotepush()end;z=A.mspermeasure/x end end;r.ms=r.ms+z end end;r.measuredone=true;r.currentmeasure={}else r.measuredone=false end end end end;print('Parsing Took: '..SToMs(os.clock()-g)..'ms')return h end;function Taiko.Analyze(f)for i=1,#f.Data do end end;function Taiko.GetDifficulty(f,g)local h=Taiko.Data.CourseId[string.lower(g)]or g;for i,j in pairs(f)do if j.Metadata.COURSE==h then return j end end;Error('No difficulty found, '..g)return nil end;function Taiko.ForAll(g,h)local i=1;for i=1,#g do local j=g[i]if j.branch then local k=-1;for l,m in pairs(j.branch.paths)do local o=i;for i2=1,#m do h(m[i2],i2,o)o=o+1 end;k=(k<o)and o or k end;i=k else h(j,i,i)end;i=i+1 end;return g end;function Taiko.GetAllNotes(f)local g={}for h,i in pairs(f)do if i.branch then for j,l in pairs(i.branch.paths)do for i=1,#l do table.insert(g,l[i])end end else table.insert(g,i)end end;return g end;function Taiko.ConnectNotes(f)local g=nil;for i=#f,1,-1 do local h=f[i]h.nextnote=g;g=h end;return f end;function Taiko.ExtractBranch(f,g)return f.branch.paths[g]end;function Taiko.ConnectAll(f)local g=nil;for i=#f,1,-1 do local h=f[i]if h.branch then for j,l in pairs(h.branch.paths)do local m=Taiko.ConnectNotes(l)m[#m].nextnote=g end else h.nextnote=g end;g=h end end;function Taiko.CalculateSpeed(f,g)local h=(g*f.scroll*f.bpm/7500)return h end;function Taiko.CalculateSpeedAll(f,g)for i=1,#f do f[i].speed=Taiko.CalculateSpeed(f[i],g)end;return f end;function Taiko.RenderScale(f)local g={}local h={}local i={}for i=1,#f.Data do local m=f.Data[i]if m.data=='note'then local n=math.floor(m.ms)if math.floor(n)-n==0 then table.insert(g,{n,m.type})table.insert(h,n)else table.insert(i,i)end end end;function gcd2(m,n)if n==0 then return m else return gcd2(n,m%n)end end;function gcdn(m)local n=m[1]for i=2,#m do n=gcd2(n,m[i])end;return n end;local j=gcdn(h)for i=1,#i do local m=g[i[i]]m[1]=math.floor(m[1]/j)*j end;local k=''local l=0;for i=1,#g do g[i][1]=g[i][1]/j;k=k..string.rep(' ',g[i][1]-l)..g[i][2]l=g[i][1]end;return k end;function Taiko.PlaySong(f,g)local h={on=false,fps=60,frames={}}local i={['4']=2,['v']=1,['n']=1,['8']=2}local j=10;local k=1000;local l=4;local m=0;local n=10;local o=0;local p=40;local q=3;local r=1;local s={[1]={color='red'},[2]={color='blue'},[3]={color='red'},[4]={color='blue'},[5]={color='yellow'},[6]={color='yellow'}}local t=200;local u=50;local v=20;t=t+u;p=math.floor(p*l)local w=o+p;q=math.floor(q*l)local x=require('taikocurses')local z={window=x.initscr()}x.keypad(z,true)x.echo(false)x.raw(true)x.nl(false)x.cbreak(true)x.nodelay(z,true)local A=require('Pixels')local B={[0]={Data={[1]={'0','1','1','1','1','1','1','1'},[2]={[2]='1',[5]='1',[8]='1'},[3]={[2]='1',[5]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={[3]='1',[4]='1',[6]='1',[7]='1'},[8]={'0','0','1','1','1','1','1','1'},[9]={[2]='1',[5]='1'},[10]={[2]='1',[5]='1'},[11]={[2]='1',[5]='1'},[12]={[2]='1',[5]='1'},[13]={'0','0','1','1','1','1','1','1'},[15]={'0','1','1','1','1','1','1','1'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'}},Color={All='blue'},Offset={-1,0}},[1]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[8]='1'},[5]={[2]='1',[8]='1'},[6]={'0','0','1','1','1','1','1','0'},[8]={'0','1','1','1','1','1','1','1'},[9]={[5]='1'},[10]={[4]='1',[6]='1'},[11]={[3]='1',[7]='1'},[12]={[2]='1',[8]='1'}},Color={All='white'},Offset={-1,0}},[2]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={'0','1','0','0','1','1','1','1'},[8]={'0','0','1','1','1','1','1','0'},[9]={[2]='1',[8]='1'},[10]={[2]='1',[8]='1'},[11]={[2]='1',[8]='1'},[12]={[2]='1',[8]='1'},[13]={'0','0','1','1','1','1','1','0'},[15]={'0','0','1','1','1','1','1','0'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'},[22]={'0','1','1','1','1','1','1','1'},[23]={[2]='1',[8]='1'},[24]={[2]='1',[8]='1'},[25]={[2]='1',[8]='1'},[26]={[2]='1',[8]='1'},[27]={'0','0','1','1','1','1','1','0'}},Color={All='yellow'},Offset={-1,0}}}B[3]=B[2]local C={[0]=nil,[1]={},[2]={}}local D,E=o,p;local F,G=-n,n;F,G=-20,20;A.Convert.ToDots=function(pb)pb=GetPixelData(pb)local qb,rb=pb.Data,pb.Color;local sb={}local tb=string.rep('0',8)local ub=A.Data.Dot[tb]local vb=nil;local wb=nil;local xb=tostring(A.Color('reset'))if pb.Color.All then local yb=tostring(A.Color(pb.Color.All))table.insert(sb,yb)wb=yb end;if not F then return''end;for y=F,G,4 do for x=D,E,2 do local yb=qb[x]local zb=qb[x+1]local Ab=( (yb)and( (yb[y]or'0').. (yb[y+1]or'0').. (yb[y+2]or'0').. (yb[y+3]or'0'))or'0000').. ( (zb)and( (zb[y]or'0').. (zb[y+1]or'0').. (zb[y+2]or'0').. (zb[y+3]or'0'))or'0000')if Ab~=tb then Ab=A.Data.Dot[Ab]if not wb then local Bb=rb[x]local Cb=rb[x+1]local Db=( (Bb)and(Bb[y]or Bb[y+1]or Bb[y+2]or Bb[y+3]))or( (Cb)and(Cb[y]or Cb[y+1]or Cb[y+2]or Cb[y+3]))if Db then Db=tostring(A.Color(Db))else Db=xb end;if vb==Db then else table.insert(sb,Db)vb=Db end end;table.insert(sb,Ab)else table.insert(sb,ub)end end;table.insert(sb,'\n')end;table.insert(sb,xb)return table.concat(sb)end;A.Circle=function(pb,qb,rb,sb,tb)str=GetPixelData(pb)tb=tb or{}local ub=tb.color;local vb=sb*sb;local wb=sb;for y=0,sb do wb=wb+1;repeat wb=wb-1 until wb*wb+y*y<=vb;for x2=0,wb do str.Data[qb+x2]=str.Data[qb+x2]or{}str.Data[qb-x2]=str.Data[qb-x2]or{}str.Data[qb+x2][rb+y]='1'str.Data[qb-x2][rb+y]='1'str.Data[qb+x2][rb-y]='1'str.Data[qb-x2][rb-y]='1'str.Color[qb+x2]=str.Color[qb+x2]or{}str.Color[qb-x2]=str.Color[qb-x2]or{}str.Color[qb+x2][rb+y]=ub;str.Color[qb-x2][rb+y]=ub;str.Color[qb+x2][rb-y]=ub;str.Color[qb-x2][rb-y]=ub end end;return str end;A.New=function()return{Data={},Color={}}end;local function H(pb,qb)local rb=math.floor(qb.p)local sb,tb=m-n,m+n;for y=sb,tb do local ub=pb.Data[rb]and pb.Data[rb][y]if ub=='0'or ub==nil then pb.Data[rb]=pb.Data[rb]or{}pb.Data[rb][y]='1'end end end;local function I(pb,qb,rb)rb=rb or qb.p;A.Circle(pb,math.floor(rb),m,l*qb.radius,s[qb.type])end;local function J(pb,qb,rb,sb,tb,ub)local vb=ub or{}color=vb.color;local wb=(o-j)if qb<wb then qb=wb end;local xb=(p+j)if rb>xb then rb=xb end;for y=sb,tb do for x=qb,rb do pb.Data[x]=pb.Data[x]or{}pb.Data[x][y]='1'if color then pb.Color[x]=pb.Color[x]or{}pb.Color[x][y]=color end end end end;local function K(pb,qb)local rb=qb.type;if rb==1 or rb==2 or rb==3 or rb==4 then I(pb,qb)elseif rb==5 or rb==6 then I(pb,qb)local sb=qb.endnote;local tb=(sb.ms-qb.ms)*qb.speed;I(pb,qb)local ub=l*qb.radius;local vb,wb=math.floor(qb.p),math.floor(qb.p+tb)local xb=m-ub;local yb=m+ub;J(pb,vb,wb,xb,yb,s[qb.type])elseif rb==8 then I(pb,qb.startnote,qb.p)end end;local function L(pb,qb)local rb=B[qb.status]local sb=rb.Offset;local tb=rb.Color.All;local ub,vb=0,-math.floor(l*1.6)-8;for wb,xb in pairs(rb.Data)do for yb,zb in pairs(xb)do if zb=='1'then local Ab,Bb=wb+sb[1]+ub,yb+sb[2]+vb;pb.Data[Ab]=pb.Data[Ab]or{}pb.Data[Ab][Bb]=zb;pb.Color[Ab]=pb.Color[Ab]or{}pb.Color[Ab][Bb]=tb end end end end;local function M(pb,qb)local rb=C[qb.status]local sb=rb.Offset;local tb=rb.Color.All;local ub,vb=0,0;for wb,xb in pairs(rb.Data)do for yb,zb in pairs(xb)do if zb=='1'then local Ab,Bb=wb+sb[1]+ub,yb+sb[2]+vb;pb.Data[Ab]=pb.Data[Ab]or{}pb.Data[Ab][Bb]=zb;pb.Color[Ab]=pb.Color[Ab]or{}pb.Color[Ab][Bb]=tb end end end end;local N={ClearScreen=function()io.write("\27[2J")end,SetCursor=function(pb,qb)io.write(string.format("\27[%d;%dH",qb,pb))end}f=Taiko.GetDifficulty(f,g)local O=Taiko.GetAllNotes(f.Data)local P=f.Metadata.OFFSET;local Q=1000 /60;local R=f.Metadata.TIMING(Q)local function S(pb)return(pb.data=='note')or(pb.data=='event'and pb.event=='barline')end;local function T(pb,qb)return qb- (( (p+j)/math.abs(pb.speed)))end;local function U(pb,qb)return(pb.ms-qb)*pb.speed+q end;local function V(pb,qb)return pb.loadp- (pb.speed* (qb-pb.loadms))end;local W={}for pb,qb in pairs(O)do qb.ms=qb.ms-P;qb.s=MsToS(qb.ms)qb.speed=Taiko.CalculateSpeed(qb,l)qb.loadms=T(qb,qb.ms)qb.loads=MsToS(qb.loadms)qb.loadp=U(qb,qb.loadms)table.insert(W,qb.ms)end;for pb,qb in pairs(f.Data)do if qb.branch then for rb,sb in pairs(qb.branch.paths)do table.sort(sb,function(tb,ub)return tb.loadms<ub.loadms end)end end end;table.sort(f.Data,function(pb,qb)if pb.branch and qb.branch then for rb,sb in pairs(pb.branch.paths)do for tb,ub in pairs(qb.branch.paths)do return sb[1].loadms<ub[1].loadms end end elseif pb.branch then for rb,sb in pairs(pb.branch.paths)do return sb[1].loadms<qb.loadms end elseif qb.branch then for rb,sb in pairs(qb.branch.paths)do return pb.loadms<sb[1].loadms end else return pb.loadms<qb.loadms end end)Taiko.ConnectAll(f.Data)Taiko.ForAll(f.Data,function(pb,qb,rb)pb.n=rb end)local X=math.max(unpack(W))+k;local Y={s=1,e=0,n=0}local Z=f.Data[1]local ab=Z.loads;Y.e=Y.n;local bb=10;local cb=string.rep(' ',bb)local db={}local function eb(pb,qb)table.insert(db,pb)table.insert(db,': ')table.insert(db,qb)table.insert(db,cb)table.insert(db,'\n')end;local function fb()print(table.concat(db))db={}end;local gb=''local function hb(pb)gb=gb..'\n'..pb end;local function ib()print(gb)end;N.ClearScreen()local jb='M'local kb={startms=nil,status=nil}local lb=-1;local mb=0;local nb=0;local ob=os.clock()if not h.on then while true do local pb=A.New()local qb=os.clock()local rb=qb-ob;local sb=rb*1000;if Z then if Z.loadms<sb then Y.n=Y.n+1;Y.e=Z.n;Y[Z.n]=Z;Z=Z.nextnote;if Z and Z.branch then Z=Z.branch.paths[jb][1]end end else if sb>X then break end end;A.Circle(pb,math.floor(q),m,l,{color='purple'})local tb={}local ub={}for i=Y.s,Y.e do local yb=Y[i]if yb then if yb.data=='note'then if(yb.type==1 or yb.type==3)and(not tb[1]or math.abs(sb-yb.ms)<tb[1])then tb[1]=math.abs(sb-yb.ms)ub[1]=yb elseif(yb.type==2 or yb.type==4)and(not tb[2]or math.abs(sb-yb.ms)<tb[2])then tb[2]=math.abs(sb-yb.ms)ub[2]=yb end end;yb.p=V(yb,sb)if math.abs(yb.p-q)> (p+j+1)then if yb.endnote and yb.endnote.done~=true then else yb.done=true;Y[i]=nil;if Z and Y.n==0 then Y.s=Z.n elseif yb.n==Y.s then if yb.n==Y.e then Y.n=0 else local zb=Y.s;repeat zb=zb+1;Y.n=Y.n-1 until Y[zb]Y.s=zb end end end else if yb.data=='event'then if yb.event=='barline'then H(pb,yb)end elseif yb.data=='note'then K(pb,yb)else error('Invalid note.data')end end end end;if kb.status then if sb>kb.startms+t then kb={}else if sb>kb.startms+u then L(pb,kb)end end end;N.SetCursor(1,1)print(A.Convert.ToDots(pb))mb=mb+1;local vb=os.clock()-qb;nb=nb+vb;local wb=x.getch(z)wb=x.getkeyname(wb)local xb=i[wb]if xb and tb[xb]then local yb=tb[xb]local zb;if yb<R.good then local Ab=ub[xb].type;zb=( (Ab==3 or Ab==4)and 3)or 2 elseif yb<R.ok then zb=1 elseif yb<R.bad then zb=0 else zb=nil end;if zb then kb={startms=sb,status=zb}end end;if wb~='-1'then lb=wb end;eb('Input (ascii)',lb)eb('Input (key)',x.getkeyname(lb))eb('S',rb)eb('Ms',sb)eb('Loaded',Y.n)eb('Frames Rendered',mb)eb('Last Frame Render (s)',vb)eb('Last Frame Render (ms)',vb*1000)eb('Frame Render Total (s)',nb)eb('Frame Render Total (ms)',nb*1000)eb('Frame Render Total (%)',nb/rb*100)eb('FPS (Frame)',mb/rb)eb('Memory Usage (mb)',collectgarbage('count')/1000)eb('Finished (%)',sb/ (X)*100)eb('Nearest1 (ms)',tb[1])eb('Nearest2 (ms)',tb[2])eb('Song Name',f.Metadata.TITLE)eb('Difficulty (id)',f.Metadata.COURSE)eb('Stars',f.Metadata.LEVEL)fb()ib()end else while true do local rb=A.New()local sb=os.clock()local tb=(1 /h.fps)*mb;local ub=tb*1000;if Z then if Z.loadms<ub then Y.n=Y.n+1;Y.e=Z.n;Y[Z.n]=Z;Z=Z.nextnote;if Z and Z.branch then hb('branch')Z=Z.branch.paths[jb][1]end end else if ub>X then break end end;for i=Y.s,Y.e do local wb=Y[i]if wb then wb.p=V(wb,ub)if(wb.p< (o-j))then if wb.endnote and wb.endnote.done~=true then else wb.done=true;Y[i]=nil;if Z and Y.n==0 then Y.s=Z.n elseif wb.n==Y.s then if wb.n==Y.e then Y.n=0 else local xb=Y.s;repeat xb=xb+1;Y.n=Y.n-1 until Y[xb]Y.s=xb end end end end;if wb.p< (p+buffer)then if wb.data=='event'then if wb.event=='barline'then H(rb,wb)end elseif wb.data=='note'then K(rb,wb)else error('Invalid note.data')end end end end;N.SetCursor(1,1)h.frames[mb]=rb;mb=mb+1;local vb=os.clock()-sb;nb=nb+vb;eb('S',tb)eb('Ms',ub)eb('Loaded',Y.n)eb('Frames Rendered',mb)eb('Last Frame Render (s)',vb)eb('Last Frame Render (ms)',vb*1000)eb('Frame Render Total (s)',nb)eb('Frame Render Total (ms)',nb*1000)eb('Frame Render Total (%)',nb/tb*100)eb('FPS (Frame)',mb/tb)eb('Memory Usage (mb)',collectgarbage('count')/1000)eb('Finished (%)',ub/ (X)*100)ib()end;print('Prerendering Finished!\nPress enter to start')io.read()local pb=os.clock()local qb=(1 /h.fps)while true do local rb=os.clock()-pb;local sb=h.frames[math.floor(( (rb-rb%qb)/qb)+0.5)]if sb==nil then break end;N.SetCursor(1,1)print(sb)end end end;local d='./CompactTJA/taikobuipm.tjac'd='./CompactTJA/ESE/06 Classical.tjac'd='./CompactTJA/all.tjac'local e=require('./CompactTJA/compactv4')Taiko.PlaySong(Taiko.ParseTJA(e.InputFile(d)),'Oni')
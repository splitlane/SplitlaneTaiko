local f=require('taikocurses')local g=require('./CompactTJA/compactv4')Split=function(k,l)local m={}for n,o in k:gmatch("([^"..l.."]*)("..l.."?)")do table.insert(m,n)if o==''then return m end end end;Trim=function(k)local l=k:gsub("^%s*(.-)%s*$","%1")return l end;TrimLeft=function(k)local l=k:gsub("^%s*(.-)$","%1")return l end;TrimRight=function(k)local l=k:gsub("^(.-)%s*$","%1")return l end;StartsWith=function(k,l)return k:sub(1,#l)==l end;EndsWith=function(k,l)return k:sub(-#l,-1)==l end;Table={}function Table.Clone(k,l)l=l or{}local m=type(k)local n;if m=='table'then if l[k]then n=l[k]else n={}l[k]=n;for o,p in next,k,nil do n[Table.Clone(o,l)]=Table.Clone(p,l)end;setmetatable(n,Table.Clone(getmetatable(k),l))end else n=k end;return n end;ClipN=function(k,l,m)if k<l then return l elseif k>m then return m else return k end end;function Error(k)error(k)end;LineN=nil;function ParseError(k,l,m)Error('Line: '..LineN..'\n'..k..': '..l.. (m and(', '..m)or''))end;function MsToS(k)return k/1000 end;function SToMs(k)return k*1000 end;Taiko={}Taiko.Data={Languages={'','EN','JA','CN','TW','KO'},GenreName={Pop={'pop','j-pop'},Anime={'anime','アニメ'},Kids={'kids','どうよう'},Variety={'variety','バラエティ'},VOCALOID={'vocaloid','ボーカロイド'},Classic={'classic','クラシック'},['Game Music']={'game music','ゲームミュージック'},['Namco Original']={'namco original','ナムコオリジナル'}},CourseId={easy=0,normal=1,hard=2,oni=3,edit=4,tower=5,dan=6,ura=4},CourseName={[0]='Easy','Normal','Hard','Oni','Edit','Tower','Dan','Ura'},RatingMultiplier={[0]=0,[1]=0.5,[2]=1,[3]=2},GogoMultiplier=1.2,ScoreMode={Note={[0]=function(k,l,m,n,o,p)return k+ ( ( (l<200)and(m or 1000)or( (m or 1000)+ (n or 1000)))*Taiko.Data.RatingMultiplier[o]* (p and Taiko.Data.GogoMultiplier or 1))end,[1]=function(k,l,m,n,o,p)return k+ ( (m+math.max(0,n*math.floor((math.min(l,100)-1)/10)))*Taiko.Data.RatingMultiplier[o]* (p and Taiko.Data.GogoMultiplier or 1))end,[2]=function(k,l,m,n,o,p)return math.floor(k+ ( (m+n* ( (l>=100)and 8 or(l>=50)and 4 or(l>=30)and 2 or(l>=10)and 1 or 0))*Taiko.Data.RatingMultiplier[o]* (p and Taiko.Data.GogoMultiplier or 1))/10)*10 end},Drumroll={[0]=function(k,l,m)return k+ ( (l==5 and 300 or l==6 and 600)* (m and Taiko.Data.GogoMultiplier or 1))end,[1]=function(k,l,m)return k+ ( (l==5 and 300 or l==6 and 600)* (m and Taiko.Data.GogoMultiplier or 1))end,[2]=function(k,l,m)return k+ ( (l==5 and 100 or l==6 and 200)* (m and Taiko.Data.GogoMultiplier or 1))end},Balloon={[0]=function(k,l,m)return k+ ( (l==7 and 300)* (m and Taiko.Data.GogoMultiplier or 1))end,[1]=function(k,l,m)return k+ ( (l==7 and 300)* (m and Taiko.Data.GogoMultiplier or 1))end,[2]=function(k,l,m)return k+ ( (l==7 and 300)* (m and Taiko.Data.GogoMultiplier or 1))end},BalloonPop={[0]=function(k,l,m)return k+ ( (l==7 and 5000)* (m and Taiko.Data.GogoMultiplier or 1))end,[1]=function(k,l,m)return k+ ( (l==7 and 5000)* (m and Taiko.Data.GogoMultiplier or 1))end,[2]=function(k,l,m)return k+ ( (l==7 and 5000)* (m and Taiko.Data.GogoMultiplier or 1))end}},Autoscore={[0]=function(k)end,[1]=function(k)end,[2]=function(k)end},SideId={normal=1,ex=2,both=3},SideName={'normal','ex','both'},StyleId={single=1,double=2,couple=2},StyleName={'single','double'},Exam={Condition={g=true,jp=true,jg=true,jb=true,s=true,r=true,h=true,c=true},Scope={m=true,l=true}},Branch={PathId={N=0,E=1,M=2},PathName={[0]='N',[1]='E',[2]='M'},Requirements={r=function()end,p=function()end}},Timing={GetFunction=function(k)return function(l)if k==1 then return{good=5 /2 *l,ok=13 /2 *l,bad=15 /2 *l}else return{good=3 /2 *l,ok=9 /2 *l,bad=13 /2 *l}end end end},StatusId={bad=0,ok=1,good=2,biggood=3},StatusName={[0]='BAD',[1]='OK',[2]='GOOD',[3]='GOOD'},ModeId={['']=0,P1=1,P2=2},ModeName={[0]='',P1,P2},Combo={[1]=true,[2]=true,[3]=true,[4]=true},BigLeniency=2,Notes={ReverseNotes={[0]=0,[1]=2,[2]=1,[3]=4,[4]=3,[5]=5,[6]=6,[7]=7,[8]=8,[9]=9}},Strings={Notes={}}}function Taiko.ParseTJA(k)local l=os.clock()local m=true;local n=true;local o={}local p={Metadata={SUBTITLE='',BPM=120,WAVE='main.mp3',OFFSET=0,DEMOSTART=0,SCOREMODE=1,SONGVOL=100,SEVOL=100,SIDE=3,LIFE=0,GAME='Taiko',HEADSCROLL=1,MOVIEOFFSET=0,COURSE='ONI',LEVEL=0,BALLOON=nil,SCOREINIT,SCOREDIFF,BALLOONNOR=nil,BALLOONEXP=nil,BALLOONMAS=nil,STYLE=1,EXAM1=nil,EXAM2=nil,EXAM3=nil,GAUGEINCR='NORMAL',TOTAL=nil,HIDDENBRANCH=0,DIVERGENOTES=false,SCOREINIT=0,SCOREDIFF=0,STOPSONG=false},Data={}}local function q(J)local K=Taiko.Data.Languages;for i=1,#K do local L=p.Metadata[J..K[i]]if L then return L end end;return nil end;local function r(J,K,L)local M=tonumber(K)if M then return M else ParseError(J,L,K)end end;local function s(J,K,L,M)if K then return K else ParseError(J,L,M)end end;local function t(J,K,L)local M={['true']=true,['false']=false,yes=true,no=false,['1']=true,['0']=false,[1]=true,[0]=false}local N=M[K]~=nil;if N then return N else ParseError(J,L,K)end end;local function u(J,K)local L=','local M='\\'local N={}local O=''local P=false;for i=1,#K do local Q=string.sub(K,i,i)if P then O=O..Q;P=false else if Q==L then table.insert(N,O)O=''elseif Q==M then P=true else O=O..Q end end end;table.insert(N,O)return N end;local function v(J,K,L)local M=u(J,K)for i=1,#M do M[i]=r(J,M[i],L,K)end;return M end;local function w(J,K,L)if K and K~=''then return v(J,K,L)else return{}end end;local function x(J,K,L)if K and K~=''then local M=u(J,K,L)s(J,Taiko.Data.Exam.Condition[M[1]],L)M[2]=r(J,M[2],L)M[3]=r(J,M[3],L)s(J,Taiko.Data.Exam.Scope[M[4]],L)return M else return{}end end;local y=error;local function z(J)local K=nil;local L=false;local M=''for i=1,#J do local N=string.sub(J,i,i)if N=='+'or N=='-'then if K then y('There are multiple signs')else K=N end elseif N=='.'then if L then y('There are multiple decimal points')else M=M..N;L=true end elseif tonumber(N)then M=M..N end end;if M==''then y('No number was found')end;return tonumber((K or'+')..M)end;local function A(J)local K=tonumber(J)if K then return K end;local L=string.gsub(J,'[^%d%.%-%+]','')if L==''then return 0 end;return tonumber(L)or z(J)or z(L)end;local function B(J)return string.find(J,'i')end;local function C(J)local K={0,0}local L=false;local M=''for i=1,#J do local N=string.sub(J,i,i)if N=='+'or N=='-'then K[1]=K[1]+A(M)M=N elseif N=='i'then K[2]=K[2]+A(M)M=''else M=M..N end end;if M~=''then K[1]=K[1]+A(M)end;return K end;local function D(J)return string.find(J,',')end;local function E(J,K)return{J*math.cos(K),J*math.sin(K)}end;local function F(J)return Split(J,',')end;local G={}local function H()local J={settings={noteparse={notes={[0]=true,[1]=true,[2]=true,[3]=true,[4]=true,[5]=true,[6]=true,[7]=true,[8]=true,[9]=true,['A']=true,['B']=true}},command={matchexceptions={}},directionweight={R=0,U=90,L=180,D=270,['0']=0,['1']=90,['2']=270,['3']=45,['4']=315,['5']=180,['6']=135,['7']=225}},bpm=0,ms=0,songstarted=false,timingpoint=nil,sign=4 /4,mpm=0,mspermeasure=0,scroll=1,scrollx=-1,scrolly=0,measuredone=true,currentmeasure={},measurepushto=p.Data,barline=true,insertbarline=true,gogo=false,lastlong=nil,balloonn=1,currentbranch=nil,branch={on=false,requirements={},paths={}},msbeforebranch=nil,section=false,disablescroll=false,stopsong=false,delay=0,suddenappear=nil,suddenmove=nil,notechain={}}function J.createnote(K)if K then local L={ms=nil,data=nil,type=K,txt=nil,gogo=J.gogo,scroll=(J.scroll*p.Metadata.HEADSCROLL),scrollx=(J.scrollx*p.Metadata.HEADSCROLL),scrolly=(J.scrolly*p.Metadata.HEADSCROLL),mspermeasure=J.mspermeasure,bpm=J.bpm,nextnote=nil,radius=1,requiredhits=nil,length=nil,endnote=nil,section=nil,text=nil,delay=J.delay,appearancems=J.suddenappear,movems=J.suddenmove,dummy=J.dummy,onnotepush=nil,line=LineN}if K==3 or K==4 or K==6 then L.radius=L.radius*1.6 end;if K==5 or K==6 or K==7 or K==9 then if J.lastlong then if K==9 then else ParseError('parser.noteparse','Last long note has not ended')end else J.lastlong=L;if K==7 or K==9 then L.requiredhits=s('parser.noteparse',p.Metadata.BALLOON[J.balloonn],'Invalid number of balloons',J.balloonn)J.balloonn=J.balloonn+1 end end end;if K==8 then local M=J.lastlong;J.lastlong=nil;L.startnote=M;if M then L.onnotepush=function()M.length=L.ms-M.ms;M.endnote=L end else end end;if J.section then L.section=true;J.section=false end;return L else return{ms=nil,data=nil,type=nil,txt=nil,gogo=J.gogo,scroll=(J.scroll*p.Metadata.HEADSCROLL),scrollx=(J.scrollx*p.Metadata.HEADSCROLL),scrolly=(J.scrolly*p.Metadata.HEADSCROLL),mspermeasure=J.mspermeasure,bpm=J.bpm,nextnote=nil,delay=J.delay,appearancems=J.suddenappear,movems=J.suddenmove,line=LineN}end end;function J.createbarline()local K=J.createnote()K.ms=J.ms;K.data='event'K.event='barline'return K end;function J.endbranch()local K=J.createnote()K.data='event'K.event='branch'K.branch={requirements=J.branch.requirements,paths=J.branch.paths}J.branch.on=false;J.branch.requirements={}J.branch.paths={}table.insert(p.Data,K)J.measurepushto=p.Data end;return J end;G=H()local I=Split(k,'\n')for i=1,#I do LineN=i;local J=Trim(I[i])if StartsWith(J,'//')or J==''then else local K=string.find(J,'//')if K then J=string.sub(J,1,K-1)end;local L=false;if G.songstarted==false and L==false then local M={string.match(J,'(%u+):(.*)')}if M[1]then local N=Trim(M[2])if N~=''then p.Metadata[Trim(M[1])]=N end;L=true end end;if(G.songstarted or StartsWith(J,'#START')or StartsWith(J,'#BMSCROLL')or StartsWith(J,'#HBSCROLL'))and L==false then local M={string.match(J,'#(%u-)%s(.*)')}if not M[1]then M={string.match(J,'#(%u+)')}end;if M[1]then if M[1]=='START'then if G.songstarted then ParseError(M[1],'Song has already started')else p.OriginalMetadata=Table.Clone(p.Metadata)if M[2]then p.Metadata.MODE=s(M[1],Taiko.Data.ModeId[M[2]],'Invalid mode',M[2])else p.Metadata.MODE=0 end;p.Metadata.TITLE=s(M[1],q('TITLE'),'Title is missing')p.Metadata.SUBTITLE=s(M[1],q('SUBTITLE'),'Subtitle is missing')p.Metadata.BPM=r(M[1],p.Metadata.BPM,'Invalid bpm')p.Metadata.OFFSET=SToMs(r(M[1],p.Metadata.OFFSET,'Invalid offset'))p.Metadata.DEMOSTART=SToMs(r(M[1],p.Metadata.DEMOSTART,'Invalid demostart'))if p.Metadata.DEMOSTART==0 then p.Metadata.DEMOSTART=nil end;for Q,R in pairs(Taiko.Data.GenreName)do for i=1,#R do if R[i]==p.Metadata.GENRE then p.Metadata.GENRE=Q end end end;p.Metadata.SCOREMODE=r(M[1],p.Metadata.SCOREMODE,'Invalid scoremode')s(M[1],Taiko.Data.ScoreMode.Note[p.Metadata.SCOREMODE],'Invalid scoremode',p.Metadata.SCOREMODE)if p.Metadata.MAKER then p.Metadata.CREATORURLT={}p.Metadata.CREATOR=Trim(string.gsub(p.Metadata.MAKER,'(<.->)',function(Q)table.insert(p.Metadata.CREATORURLT,string.sub(Q,2,-2))return''end))p.Metadata.CREATORURL=table.concat(p.Metadata.CREATORURLT,', ')p.Metadata.CREATIVE=false else p.Metadata.CREATIVE=false end;p.Metadata.SONGVOL=r(M[1],p.Metadata.SONGVOL,'Invalid songvol')/100;p.Metadata.SEVOL=r(M[1],p.Metadata.SEVOL,'Invalid sevol')/100;local N=tonumber(p.Metadata.SIDE)if N then s(M[1],Taiko.Data.SideName[N],'Invalid side id',p.Metadata.SIDE)p.Metadata.SIDE=N else p.Metadata.SIDE=s(M[1],Taiko.Data.SideId[string.lower(p.Metadata.SIDE)],'Invalid side name',p.Metadata.SIDE)end;p.Metadata.LIFE=r(M[1],p.Metadata.LIFE,'Invalid life')if p.Metadata.LIFE==0 then p.Metadata.LIFE=nil end;p.Metadata.GAME=string.lower(p.Metadata.GAME)if p.Metadata.GAME=='taiko'then elseif p.Metadata.GAME=='jube'then else end;p.Metadata.HEADSCROLL=r(M[1],p.Metadata.HEADSCROLL,'Invalid headscroll')p.Metadata.MOVIEOFFSET=r(M[1],p.Metadata.MOVIEOFFSET,'Invalid movieoffset')local O=tonumber(p.Metadata.COURSE)if O then s(M[1],Taiko.Data.CourseName[O],'Invalid course id',p.Metadata.COURSE)p.Metadata.COURSE=O else p.Metadata.COURSE=s(M[1],Taiko.Data.CourseId[string.lower(p.Metadata.COURSE)],'Invalid course name',p.Metadata.COURSE)end;p.Metadata.TIMING=Taiko.Data.Timing.GetFunction(p.Metadata.COURSE)p.Metadata.LEVEL=ClipN(math.floor(r(M[1],p.Metadata.LEVEL,'Invalid level')),0,10)p.Metadata.BALLOON=w(M[1],p.Metadata.BALLOON,'Invalid balloon')p.Metadata.SCOREINIT=r(M[1],p.Metadata.SCOREINIT,'Invalid scoreinit')p.Metadata.SCOREDIFF=r(M[1],p.Metadata.SCOREDIFF,'Invalid scoreinit')p.Metadata.BALLOONNOR=w(M[1],p.Metadata.BALLOONNOR,'Invalid balloonnor')p.Metadata.BALLOONEXP=w(M[1],p.Metadata.BALLOONEXP,'Invalid balloonexp')p.Metadata.BALLOONMAS=w(M[1],p.Metadata.BALLOONMAS,'Invalid balloonmas')local P=tonumber(p.Metadata.STYLE)if P then s(M[1],Taiko.Data.StyleName[P],'Invalid style id',Taiko.Data.STYLE)p.Metadata.STYLE=P else p.Metadata.STYLE=s(M[1],Taiko.Data.StyleId[string.lower(p.Metadata.STYLE)],'Invalid style name',p.Metadata.STYLE)end;p.Metadata.EXAM1=x(p.Metadata.EXAM1)p.Metadata.EXAM2=x(p.Metadata.EXAM2)p.Metadata.EXAM3=x(p.Metadata.EXAM3)p.Metadata.GAUGEINCR=string.lower(p.Metadata.GAUGEINCR)if p.Metadata.TOTAL then p.Metadata.TOTAL=r(M[1],p.Metadata.TOTAL,'Invalid total')end;p.Metadata.HIDDENBRANCH=t(M[1],p.Metadata.HIDDENBRANCH,'Invalid hiddenbranch')G.bpm=p.Metadata.BPM;G.songstarted=true end elseif M[1]=='END'then if G.songstarted then if#G.currentmeasure~=0 then ParseError(M[1],'Current measure is not empty')end;table.insert(o,p)p={Metadata=Table.Clone(p.OriginalMetadata),Data={}}G=H()G.songstarted=false;G.measurepushto=p.Data else ParseError(M[1],'Song has already ended')end elseif M[1]=='MEASURE'then local N,O=string.match(M[2],'(%d+)/(%d+)')N=r(M[1],N,'Invalid measure')O=r(M[1],O,'Invalid measure')G.sign=(N/O)or G.sign elseif M[1]=='BPMCHANGE'then G.bpm=r(M[1],M[2],'Invalid bpmchange')or G.bpm elseif M[1]=='DELAY'then local N=SToMs((r(M[1],M[2],'Invalid delay')or 0))G.delay=G.delay+N;table.insert(G.currentmeasure,{'DELAY',N})elseif M[1]=='SCROLL'then if G.disablescroll then else if n and B(M[2])then local N=C(M[2])G.scrollx=-N[1]G.scrolly=-N[2]elseif n and D(M[2])then local N=v(M[1],M[2],'Invalid polar scroll')if#N==3 then local O=E(N[1],math.rad(N[3]/N[2]*360))G.scrollx=-O[1]G.scrolly=-O[2]else ParseError(M[1],'Invalid polar scroll')end else G.scrollx=- (r(M[1],M[2],'Invalid scroll')or-G.scrollx)G.scrolly=0 end;G.scroll=-G.scrollx;if G.scroll==0 and G.scrollx==0 and G.scrolly==0 then ParseError(M[1],'Scroll cannot be 0')end end elseif M[1]=='GOGOSTART'then G.gogo=true elseif M[1]=='GOGOEND'then G.gogo=false elseif M[1]=='BARLINEOFF'then G.barline=false elseif M[1]=='BARLINEON'then G.barline=true elseif M[1]=='BRANCHSTART'then if G.branch.on then G.endbranch()end;G.msbeforebranch=G.ms;G.branch.on=true;p.Metadata.DIVERGENOTES=true;local N=u(M[1],M[2])local O=s(M[1],Taiko.Data.Branch.Requirements[string.lower(N[1])],'Invalid type',N[1])G.branch.requirements={O}local P=2;while true do if not N[P]then break end;local Q=Taiko.Data.Branch.PathName[P-1]if Q then G.branch.requirements[Q]=N[P]else break end;P=P+1 end elseif Taiko.Data.Branch.PathId[M[1]]then if G.branch.on then G.ms=G.msbeforebranch;G.currentbranch=M[1]G.branch.paths[M[1]]={}G.measurepushto=G.branch.paths[M[1]]else ParseError(M[1],'Branch has not started')end elseif M[1]=='BRANCHEND'then if G.branch.on then G.endbranch()else ParseError(M[1],'Branch has already ended')end elseif M[1]=='SECTION'then G.section=true elseif M[1]=='LYRIC'then elseif M[1]=='LEVELHOLD'then elseif M[1]=='BMSCROLL'then G.disablescroll=true;p.Metadata.STOPSONG=true elseif M[1]=='HBSCROLL'then p.Metadata.STOPSONG=true elseif M[1]=='SENOTECHANGE'then elseif M[1]=='NEXTSONG'then elseif M[1]=='DIRECTION'then local N=M[2]local O=G.settings.directionweight;local P=0;local Q=0;for i=1,#N do local U=string.sub(N,i,i)if O[U]then P=P+O[U]Q=Q+1 end end;if Q==0 then ParseError(M[1],'Invalid direction')end;local R=P/Q;local S=math.sqrt(G.scrollx^2 +G.scrolly^2)local T=E(S,math.rad(R))G.scrollx=-T[1]G.scrolly=-T[2]elseif M[1]=='SUDDEN'then local N=F(M[2])G.suddenappear=SToMs(tonumber(N[1]))G.suddenmove=SToMs(tonumber(N[2]))elseif M[1]=='JPOSSCROLL'then elseif n then if M[1]=='GAMEMODE'then elseif M[1]=='SPLITLANE'then elseif M[1]=='MERGELANE'then elseif M[1]=='BARLINE'then table.insert(G.measurepushto,G.createbarline())elseif M[1]=='DUMMYSTART'then G.dummy=true elseif M[1]=='DUMMYEND'then G.dummy=false elseif M[1]==''then elseif M[1]==''then elseif M[1]==''then elseif M[1]==''then elseif M[1]==''then elseif M[1]==''then elseif M[1]==''then elseif M[1]==''then elseif M[1]==''then elseif M[1]==''then elseif M[1]==''then elseif M[1]==''then elseif M[1]==''then elseif M[1]==''then elseif M[1]==''then elseif M[1]==''then elseif M[1]==''then elseif M[1]==''then end else end;L=true end end;if(G.songstarted)and L==false then G.mpm=G.bpm*G.sign/4;G.mspermeasure=60000 *G.sign*4 /G.bpm;if G.barline and G.insertbarline then table.insert(G.measurepushto,G.createbarline())G.insertbarline=false end;for i=1,#J do local M=string.sub(J,i,i)local N=tonumber(M)or M;if G.settings.noteparse.notes[N]then local O=G.createnote(N)O.data='note'table.insert(G.currentmeasure,O)end end;if EndsWith(TrimRight(J),',')then G.mpm=G.bpm*G.sign/4;G.mspermeasure=60000 *G.sign*4 /G.bpm;if#G.currentmeasure==0 then G.ms=G.ms+G.mspermeasure elseif#G.currentmeasure==1 and G.currentmeasure[1].data=='event'and G.currentmeasure[1].event=='barline'then p.Data[#p.Data+1]=G.currentmeasure[1]G.ms=G.ms+G.mspermeasure else local M=0;local N=nil;for i=1,#G.currentmeasure do local P=G.currentmeasure[i]if P.data=='note'then N=N or P.mspermeasure;M=M+1 end end;N=N or G.mspermeasure;local O=N/M;for i=1,#G.currentmeasure do local P=G.currentmeasure[i]if P[1]=='DELAY'then G.ms=G.ms+P[2]else if not m or P.type~=0 then P.ms=G.ms;P.appearancems=P.appearancems and(P.ms- (P.appearancems))P.movems=P.movems and(P.ms- (P.movems))local Q=G.measurepushto[#G.measurepushto]or p.Data[#p.Data]if Q then Q.nextnote=P end;table.insert(G.measurepushto,P)if P.onnotepush then P.onnotepush()end;O=P.mspermeasure/M end;if P.data=='note'then G.ms=G.ms+O end end end end;G.measuredone=true;G.currentmeasure={}G.insertbarline=true else G.measuredone=false end end end end;print('Parsing Took: '..SToMs(os.clock()-l)..'ms')return o end;function Taiko.SerializeTJA(k)local function l(w)return math.floor(w+0.5)end;local m=5;local n=10 ^m;local function o(w)return math.floor(w*n+0.5)/n end;local function p(w)if math.floor(w)~=w then return string.format('%f',w)else return tostring(w)end end;local function q(w,x)if w<x then return q(x,w)end;if math.abs(x)<0.001 then return w else return q(x,w-math.floor(w/x)*x)end end;local function r(w)local x=q(w,1)return l(w/x),l(1 /x)end;local function s(w)local x,y=string.match(w,'(%d+)/(%d+)')return x,y end;local function t(w)for i=1,#w do w[i]=tostring(w[i])end;return table.concat(w,',')end;local function u(w)local x={}local y={OFFSET=true,DEMOSTART=true}for H,I in pairs(w.Metadata)do local J;if type(I)=='number'then if y[H]then J=tostring(MsToS(tonumber(I)))else J=tostring(I)end elseif type(I)=='table'then J=t(I)elseif type(I)=='string'then J=tostring(I)else J=nil end;if J then x[#x+1]=H;x[#x+1]=':'x[#x+1]=J;x[#x+1]='\n'end end;x[#x+1]='\n\n'local z=false;local A=false;local B=w.Metadata.HEADSCROLL;for i=1,#w.Data do local H=w.Data[i]H.ms=H.ms-H.delay;if H.data=='event'and H.event=='barline'then z=true end;if H.delay and H.delay~=0 then A=true end;if H.scroll and H.scroll~=B then B=false end end;if A then if B then x[#x+1]='#BMSCROLL\n'else x[#x+1]='#HBSCROLL\n'end end;x[#x+1]='#START\n'if z then x[#x+1]='#BARLINEON\n'else x[#x+1]='#BARLINEOFF\n'end;local C={startms=nil}local D=nil;local E=0;local F={scroll=0,bpm=w.Metadata.BPM,measure=nil,gogo=false,delay=0}local G={scroll={'#SCROLL ',nil,function(H)local I=H.scroll/w.Metadata.HEADSCROLL;if I~=F.scroll then F.scroll=I;return tostring(I)end end},bpm={'#BPMCHANGE ',tostring(w.Metadata.BPM),function(H)local I=H.bpm;if I~=F.bpm then F.bpm=I;return tostring(I)end end},measure={'#MEASURE ',false,function(H)local I,J=r(H.bpm*H.mspermeasure/240000)local K=I..'/'..J;if K~=F.measure then F.measure=K;return K end end},gogo={'#GOGO',false,function(H)local I=H.gogo;if I~=F.gogo then F.gogo=I;if I then return'START'else return'END'end end end},delay={'#DELAY ',nil,function(H)if H.delay~=F.delay then local I=H.delay-F.delay;F.delay=H.delay;return p(MsToS(I))end end}}for i=1,#w.Data do local H=w.Data[i]local I=H.ms;if H.data=='note'then C[#C+1]=H elseif H.data=='event'and H.event=='barline'then C.startms=H.ms;C[#C+1]=H end;local J=w.Data[i+1]if(J and J.data=='event'and J.event=='barline')or(i==#w.Data)then if#C==0 then error('No barline')else local K={}for i=2,#C do local O=C[i-1]local P=C[i]K[#K+1]=math.abs(P.ms-O.ms)end;K[#K+1]=math.abs((C.startms+C[1].mspermeasure)-C[#C].ms)local L=K[1]for i=2,#K do L=q(L,K[i])end;if L==nil then error('gcd invalid, probably delay')L=C[1]and(C[1].ms-E)end;local M=C.startms;local N=M+C[1].mspermeasure;for i2=1,#C do local O=C[i2]for P,Q in pairs(G)do if O[P]==Q[2]then else local R=Q[3](O)if R then Q[2]=R;if x[#x]~='\n'then x[#x+1]='\n'end;x[#x+1]=Q[1]x[#x+1]=R;x[#x+1]='\n'end end end;if i2 ~=1 then x[#x+1]=tostring(O.type)end;if i2 ==1 and#C~=1 then x[#x+1]=string.rep('0',( (C[i2 +1]and C[i2 +1].ms or N)-O.ms)/L)else x[#x+1]=string.rep('0',( (C[i2 +1]and C[i2 +1].ms or N)-O.ms)/L-1)end end;x[#x+1]=','x[#x+1]='\n'C={}end end end;if x[#x]~='\n'then x[#x+1]='\n'end;x[#x+1]='\n#END'return table.concat(x)end;local v={'// Automatically Serialized by Taiko.SerializeTJA'}for w,x in pairs(k)do v[#v+1]=u(x)return table.concat(v,'\n\n')end;v=table.concat(v,'\n\n')return v end;function Taiko.Score(k,l,m,n,o)if n==0 then m=0 else m=m+1 end;local p=k.Metadata;return Taiko.Data.ScoreMode.Note[p.SCOREMODE](l,m,p.SCOREINIT,p.SCOREDIFF,n,o),m end;function Taiko.Analyze(k)local l='M'local m={[1]=2,[2]=2,[3]=3,[4]=3}local n={notes={n=0,validn=0},measures=0,lengthms=0,drumrollms=0,drumrollbigms=0,balloonms=0,balloonhit=0,specialms=0,specialhit=0,maxcombo=0,maxscore=0}local o=nil;Taiko.ForAll(k.Data,function(p,q,r)if p.data=='note'then n.notes.n=n.notes.n+1;n.notes[p.type]=n.notes[p.type]and n.notes[p.type]+1 or 1;if m[p.type]then n.maxscore,n.maxcombo=Taiko.Score(k,n.maxscore,n.maxcombo,m[p.type],p.gogo)end;local s=p.endnote;if s then local t=s.ms-p.ms;if p.type==5 then n.drumrollms=n.drumrollms+t elseif p.type==6 then n.drumrollbigms=n.drumrollbigms+t elseif p.type==7 then n.balloonms=n.balloonms+t;n.balloonhit=n.balloonhit+p.requiredhits elseif p.type==9 then n.specialms=n.specialms+t;n.specialhit=n.specialhit+p.requiredhits else end end;o=p elseif p.data=='event'and p.event=='barline'then n.measures=n.measures+1 else end end,l)n.lengthms=o.ms-k.Metadata.OFFSET;n.notes.validn=n.maxcombo;return n end;function Taiko.GetDifficulty(k,l)local m=Taiko.Data.CourseId[string.lower(l)]or l;for n,o in pairs(k)do if o.Metadata.COURSE==m then return o end end;Error('No difficulty found, '..l)return nil end;function Taiko.ForAll(k,l,m)local o=1;for i=1,#k do local p=k[i]if p.branch then if m then local q=p.branch.paths[m]for i2=1,#q do l(q[i2],i2,o)o=o+1 end;o=o-1 else local q=-1;for r,s in pairs(p.branch.paths)do local t=o;for i2=1,#s do l(s[i2],i2,t)t=t+1 end;q=(q<t)and t or q end;o=q end else l(p,i,o)end;o=o+1 end;return k end;function Taiko.GetAllNotes(k)local l={}for m,n in pairs(k)do if n.branch then for o,p in pairs(n.branch.paths)do for i=1,#p do table.insert(l,p[i])end end else table.insert(l,n)end end;return l end;function Taiko.ConnectNotes(k)local l=nil;for i=#k,1,-1 do local m=k[i]m.nextnote=l;l=m end;return k end;function Taiko.ExtractBranch(k,l)return k.branch.paths[l]end;function Taiko.ConnectAll(k)local l=nil;for i=#k,1,-1 do local m=k[i]if m.branch then for n,o in pairs(m.branch.paths)do local p=Taiko.ConnectNotes(o)p[#p].nextnote=l end else m.nextnote=l end;l=m end end;function Taiko.CalculateSpeed(k,l)local m=(l*k.scrollx*k.bpm/7500)local n=(l*k.scrolly*k.bpm/7500)return{m,n}end;function Taiko.CalculateSpeedAll(k,l)for i=1,#k do k[i].speed=Taiko.CalculateSpeed(k[i],l)end;return k end;function Taiko.RenderScale(k)local l={}local m={}local n={}for i=1,#k.Data do local r=k.Data[i]if r.data=='note'then local s=math.floor(r.ms)if math.floor(s)-s==0 then table.insert(l,{s,r.type})table.insert(m,s)else table.insert(n,i)end end end;function gcd2(r,s)if s==0 then return r else return gcd2(s,r%s)end end;function gcdn(r)local s=r[1]for i=2,#r do s=gcd2(s,r[i])end;return s end;local o=gcdn(m)for i=1,#n do local r=l[n[i]]r[1]=math.floor(r[1]/o)*o end;local p=''local q=0;for i=1,#l do l[i][1]=l[i][1]/o;p=p..string.rep(' ',l[i][1]-q)..l[i][2]q=l[i][1]end;return p end;function Taiko.PlaySong(k,l,m,n)local o={on=false,fps=60,frames={}}local p=nil;local q={auto={[1]=false,[2]=true},notespeedmul={[1]=1,[2]=2,[3]=3,[4]=4,[5]=0.25,[6]=0.5,[7]=0.75},songspeedmul={[1]=1,[2]=2,[3]=3,[4]=4,[5]=0.25,[6]=0.5,[7]=0.75}}local r=q.auto[m[2]]or false;local s={[1]=true,[2]=true,[3]=true,[4]=true}local t=q.notespeedmul[m[3]]or 1;local u=q.songspeedmul[m[4]]or 1;local v=k.Metadata.STOPSONG;local w=n or{}w={Hit=w.Hit or{['4']=2,['v']=1,['n']=1,['8']=2},Escape=w.Escape or{['\27']=true,ALT_ESC=true},L=w.L or{KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_A2=true},R=w.R or{KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true},Select=w.Select or{KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}}local x=1;local z=2;local A='>'local B='\n\n\n'local C=10;local D=50;local E=1000;local F=4;local G=0;local H=10;local I=0;local J=40;local K=3;local L=1;local M={[1]={color='red'},[2]={color='blue'},[3]={color='red'},[4]={color='blue'},[5]={color='yellow'},[6]={color='yellow'},[7]={color='cyan'}}local N=200;local O=N/4;local P=4;local Q=20;J=math.floor(J*F)local R=I+J;K={K*F,0}local S={I,-H*2,R,H*2}local T={S[1]-C,S[2]-C,S[3]+C,S[4]+C}local U={S[1]-D,S[2]-D,S[3]+D,S[4]+D}local V=l or{window=f.initscr()}f.keypad(V,true)f.echo(false)f.raw(true)f.nl(false)f.cbreak(true)f.nodelay(V,true)local W={[0]={Data={[1]={'0','1','1','1','1','1','1','1'},[2]={[2]='1',[5]='1',[8]='1'},[3]={[2]='1',[5]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={[3]='1',[4]='1',[6]='1',[7]='1'},[8]={'0','0','1','1','1','1','1','1'},[9]={[2]='1',[5]='1'},[10]={[2]='1',[5]='1'},[11]={[2]='1',[5]='1'},[12]={[2]='1',[5]='1'},[13]={'0','0','1','1','1','1','1','1'},[15]={'0','1','1','1','1','1','1','1'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'}},Color={All='blue'},Offset={-1,0}},[1]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[8]='1'},[5]={[2]='1',[8]='1'},[6]={'0','0','1','1','1','1','1','0'},[8]={'0','1','1','1','1','1','1','1'},[9]={[5]='1'},[10]={[4]='1',[6]='1'},[11]={[3]='1',[7]='1'},[12]={[2]='1',[8]='1'}},Color={All='white'},Offset={-1,0}},[2]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={'0','1','0','0','1','1','1','1'},[8]={'0','0','1','1','1','1','1','0'},[9]={[2]='1',[8]='1'},[10]={[2]='1',[8]='1'},[11]={[2]='1',[8]='1'},[12]={[2]='1',[8]='1'},[13]={'0','0','1','1','1','1','1','0'},[15]={'0','0','1','1','1','1','1','0'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'},[22]={'0','1','1','1','1','1','1','1'},[23]={[2]='1',[8]='1'},[24]={[2]='1',[8]='1'},[25]={[2]='1',[8]='1'},[26]={[2]='1',[8]='1'},[27]={'0','0','1','1','1','1','1','0'}},Color={All='yellow'},Offset={-1,0}},Size={27,8}}W[3]=W[2]local X={[0]=nil,[1]={},[2]={}}local Y;os.execute('chcp 65001')Y={}local Z=([[
⠀ ⢀ ⠠ ⢠ ⠐ ⢐ ⠰ ⢰ ⠈ ⢈ ⠨ ⢨ ⠘ ⢘ ⠸ ⢸
⡀ ⣀ ⡠ ⣠ ⡐ ⣐ ⡰ ⣰ ⡈ ⣈ ⡨ ⣨ ⡘ ⣘ ⡸ ⣸
⠄ ⢄ ⠤ ⢤ ⠔ ⢔ ⠴ ⢴ ⠌ ⢌ ⠬ ⢬ ⠜ ⢜ ⠼ ⢼
⡄ ⣄ ⡤ ⣤ ⡔ ⣔ ⡴ ⣴ ⡌ ⣌ ⡬ ⣬ ⡜ ⣜ ⡼ ⣼
⠂ ⢂ ⠢ ⢢ ⠒ ⢒ ⠲ ⢲ ⠊ ⢊ ⠪ ⢪ ⠚ ⢚ ⠺ ⢺
⡂ ⣂ ⡢ ⣢ ⡒ ⣒ ⡲ ⣲ ⡊ ⣊ ⡪ ⣪ ⡚ ⣚ ⡺ ⣺
⠆ ⢆ ⠦ ⢦ ⠖ ⢖ ⠶ ⢶ ⠎ ⢎ ⠮ ⢮ ⠞ ⢞ ⠾ ⢾
⡆ ⣆ ⡦ ⣦ ⡖ ⣖ ⡶ ⣶ ⡎ ⣎ ⡮ ⣮ ⡞ ⣞ ⡾ ⣾
⠁ ⢁ ⠡ ⢡ ⠑ ⢑ ⠱ ⢱ ⠉ ⢉ ⠩ ⢩ ⠙ ⢙ ⠹ ⢹
⡁ ⣁ ⡡ ⣡ ⡑ ⣑ ⡱ ⣱ ⡉ ⣉ ⡩ ⣩ ⡙ ⣙ ⡹ ⣹
⠅ ⢅ ⠥ ⢥ ⠕ ⢕ ⠵ ⢵ ⠍ ⢍ ⠭ ⢭ ⠝ ⢝ ⠽ ⢽
⡅ ⣅ ⡥ ⣥ ⡕ ⣕ ⡵ ⣵ ⡍ ⣍ ⡭ ⣭ ⡝ ⣝ ⡽ ⣽
⠃ ⢃ ⠣ ⢣ ⠓ ⢓ ⠳ ⢳ ⠋ ⢋ ⠫ ⢫ ⠛ ⢛ ⠻ ⢻
⡃ ⣃ ⡣ ⣣ ⡓ ⣓ ⡳ ⣳ ⡋ ⣋ ⡫ ⣫ ⡛ ⣛ ⡻ ⣻
⠇ ⢇ ⠧ ⢧ ⠗ ⢗ ⠷ ⢷ ⠏ ⢏ ⠯ ⢯ ⠟ ⢟ ⠿ ⢿
⡇ ⣇ ⡧ ⣧ ⡗ ⣗ ⡷ ⣷ ⡏ ⣏ ⡯ ⣯ ⡟ ⣟ ⡿ ⣿]]):gsub('\n',' ')function GenerateDotData()function ToBinary(qc)local rc={}while qc>0 do local tc=math.fmod(qc,2)rc[#rc+1]=string.sub(tc,1,1)qc=(qc-tc)/2 end;local sc=string.reverse(table.concat(rc))return string.rep('0',8 -#sc)..sc end;local function kc(qc)return qc end;local lc=Split(Z,' ')local mc={}local nc=false;local oc=''local pc=' 'for i=1,#lc do mc[i-1]=kc(lc[i])end;return mc end;Y.Data={}Y.Data.Dot=GenerateDotData()Y.ColorData={reset=0,clear=0,space=0,bright=1,bold=1,dim=2,faint=1,italic=3,underline=4,blink=5,reverse=7,invisible=8,hidden=8,strikethrough=9,black=30,red=31,green=32,yellow=33,blue=34,purple=35,magenta=35,cyan=36,white=37,onblack=40,onred=41,ongreen=42,onyellow=43,onblue=44,onpurple=45,onmagenta=45,oncyan=46,onwhite=47}Y.Color={}for kc,lc in pairs(Y.ColorData)do Y.Color[kc]='\27['..lc..'m'end;local ab,bb=S[1],S[3]local cb,db=-S[4],-S[2]Y.Convert={}Y.Convert.ToDots=function(kc)local lc,mc=kc.Data,kc.Color;local nc={}local oc=0;local pc=Y.Data.Dot[oc]local qc=nil;local rc=nil;local sc=Y.Color['reset']if kc.Color.All then local tc=Y.Color[kc.Color.All]nc[#nc+1]=tc;rc=tc end;if not cb then return''end;for y=db,cb,-4 do for x=ab,bb,2 do local tc=lc[x]local uc=lc[x+1]local vc=(tc and( (tc[y]or 0)*128 + (tc[y-1]or 0)*64 + (tc[y-2]or 0)*32 + (tc[y-3]or 0)*16)or 0)+ (uc and( (uc[y]or 0)*8 + (uc[y-1]or 0)*4 + (uc[y-2]or 0)*2 + (uc[y-3]or 0))or 0)if vc~=oc then vc=Y.Data.Dot[vc]if not rc then local wc=mc[x]local xc=mc[x+1]local yc=( (wc)and(wc[y]or wc[y-1]or wc[y-2]or wc[y-3]))or( (xc)and(xc[y]or xc[y-1]or xc[y-2]or xc[y-3]))if yc then yc=Y.Color[yc]else yc=sc end;if qc==yc then else nc[#nc+1]=yc;qc=yc end end;nc[#nc+1]=vc else nc[#nc+1]=pc end end;nc[#nc+1]='\n'end;nc[#nc+1]=sc;return table.concat(nc)end;Y.ToDotsParallel=function(kc,lc)local mc,nc=kc.Data,kc.Color;local oc,pc=lc.Data,lc.Color;local qc={}local rc=0;local sc=Y.Data.Dot[rc]local tc=nil;local uc=nil;local vc=Y.Color['reset']if kc.Color.All then local wc=Y.Color[kc.Color.All]qc[#qc+1]=wc;uc=wc end;if not cb then return''end;for y=db,cb,-4 do for x=ab,bb,2 do local wc=mc[x]local xc=mc[x+1]local yc=oc[x]local zc=oc[x+1]local Ac=( (wc and yc)and( (wc[y]or yc[y]or 0)*128 + (wc[y-1]or yc[y-1]or 0)*64 + (wc[y-2]or yc[y-2]or 0)*32 + (wc[y-3]or yc[y-3]or 0)*16)or(wc)and( (wc[y]or 0)*128 + (wc[y-1]or 0)*64 + (wc[y-2]or 0)*32 + (wc[y-3]or 0)*16)or(yc)and( (yc[y]or 0)*128 + (yc[y-1]or 0)*64 + (yc[y-2]or 0)*32 + (yc[y-3]or 0)*16)or 0)+ ( (xc and zc)and( (xc[y]or zc[y]or 0)*8 + (xc[y-1]or zc[y-1]or 0)*4 + (xc[y-2]or zc[y-2]or 0)*2 + (xc[y-3]or zc[y-3]or 0))or(xc)and( (xc[y]or 0)*8 + (xc[y-1]or 0)*4 + (xc[y-2]or 0)*2 + (xc[y-3]or 0))or(zc)and( (zc[y]or 0)*8 + (zc[y-1]or 0)*4 + (zc[y-2]or 0)*2 + (zc[y-3]or 0))or 0)if Ac~=rc then Ac=Y.Data.Dot[Ac]if not uc then local Bc=pc[x]local Cc=pc[x+1]local Dc=nc[x]local Ec=nc[x+1]local Fc=Dc and(Dc[y]or Dc[y-1]or Dc[y-2]or Dc[y-3])or Ec and(Ec[y]or Ec[y-1]or Ec[y-2]or Ec[y-3])or Bc and(Bc[y]or Bc[y-1]or Bc[y-2]or Bc[y-3])or Cc and(Cc[y]or Cc[y-1]or Cc[y-2]or Cc[y-3])if Fc then Fc=Y.Color[Fc]else Fc=vc end;if tc==Fc then else qc[#qc+1]=Fc;tc=Fc end end;qc[#qc+1]=Ac else qc[#qc+1]=sc end end;qc[#qc+1]='\n'end;qc[#qc+1]=vc;return table.concat(qc)end;Y.CircleGen=function(kc,lc,mc,nc,oc)oc=oc or{}local pc=oc.color;local qc=nc*nc;local rc=nc;for y=0,nc do rc=rc+1;repeat rc=rc-1 until rc*rc+y*y<=qc;for x2=0,rc do kc.Data[lc+x2]=kc.Data[lc+x2]or{}kc.Data[lc-x2]=kc.Data[lc-x2]or{}kc.Data[lc+x2][mc+y]='1'kc.Data[lc-x2][mc+y]='1'kc.Data[lc+x2][mc-y]='1'kc.Data[lc-x2][mc-y]='1'kc.Color[lc+x2]=kc.Color[lc+x2]or{}kc.Color[lc-x2]=kc.Color[lc-x2]or{}kc.Color[lc+x2][mc+y]=pc;kc.Color[lc-x2][mc+y]=pc;kc.Color[lc+x2][mc-y]=pc;kc.Color[lc-x2][mc-y]=pc end end;return kc end;local eb={}Y.Circle=function(kc,lc,mc,nc,oc)local pc=nil;if eb[nc]then else eb[nc]=Y.CircleGen(Y.New(),0,0,nc)end;local qc=oc and oc.color;pc=eb[nc]for rc,sc in pairs(pc.Data)do for tc,uc in pairs(sc)do local vc,wc=rc+lc,tc+mc;kc.Data[vc]=kc.Data[vc]or{}kc.Data[vc][wc]=uc;kc.Color[vc]=kc.Color[vc]or{}kc.Color[vc][wc]=qc end end;return kc end;Y.New=function()return{Data={},Color={}}end;local function fb(kc)return(kc.data=='note')or(kc.data=='event'and kc.event=='barline')end;local function gb(kc,lc,mc,nc,oc,pc)return mc<=kc and kc<=oc and nc<=lc and lc<=pc end;local function hb(kc,lc,mc,nc,oc,pc,qc,rc)oc,pc,qc,rc=oc-kc,pc-lc,qc-kc,rc-lc;local sc=nc/mc;if nc<0 then local tc,uc=pc/sc,pc;if oc<=tc and tc<=qc then return tc,uc end else local tc,uc=rc/sc,rc;if oc<=tc and tc<=qc then return tc,uc end end;if mc<0 then local tc,uc=oc,oc*sc;if pc<=uc and uc<=rc then return tc,uc end else local tc,uc=qc,qc*sc;if pc<=uc and uc<=rc then return tc,uc end end;return nil end;local function ib(kc,lc)local mc,nc=hb(0,0,-kc.scrollx,-kc.scrolly,T[1],T[2],T[3],T[4])return lc- (mc~=0 and mc/-kc.speed[1]or nc/-kc.speed[2])end;local function jb(kc,lc)return K[1]+ (-kc.speed[1]* (kc.ms-lc-kc.delay)),- (K[2]+ (kc.speed[2]* (kc.ms-lc-kc.delay)))end;local function kb(kc,lc)local mc=math.floor(lc.p[1])local nc=math.floor(lc.p[2])local oc,pc=nc-H,nc+H;for y=oc,pc do kc.Data[mc]=kc.Data[mc]or{}kc.Data[mc][y]='1'end end;local function lb(kc,lc,mc)mc=mc or lc.p;Y.Circle(kc,math.floor(mc[1]),math.floor(mc[2]),F*lc.radius,M[lc.type])end;local function mb(kc,lc,mc,nc,oc,pc)lc=math.floor(lc)mc=math.floor(mc)nc=math.floor(nc)oc=math.floor(oc)local qc=pc or{}color=qc.color;for y=mc,oc do for x=lc,nc do kc.Data[x]=kc.Data[x]or{}kc.Data[x][y]='1'if color then kc.Color[x]=kc.Color[x]or{}kc.Color[x][y]=color end end end end;local function nb(kc,lc,mc)local nc=lc.type;if nc==1 or nc==2 or nc==3 or nc==4 then lb(kc,lc)elseif nc==5 or nc==6 then elseif nc==7 then lc.radius=0.8;lb(kc,lc)elseif nc==8 then lb(kc,lc)local oc=lc.startnote;lb(kc,oc)local pc=F*lc.radius;local qc,rc=math.floor(oc.p[1]),math.floor(lc.p[1])lb(kc,oc,lc.p)local sc=math.floor(G-pc)local tc=math.floor(G+pc)if mc then else if qc>rc then qc,rc=rc,qc end;if qc<T[1]then qc=T[1]end;if rc>T[3]then rc=T[3]end end;mb(kc,qc,sc,rc,tc,M[oc.type])end end;local function ob(kc,lc,mc)local nc=P/ (O/2)local oc=-nc*math.abs(( (mc-lc.startms)/ (N/O))- (P/nc))+P;local pc=W[lc.status]local qc=pc.Offset;local rc=pc.Color.All;local sc,tc=0,-math.floor(F*1.6)-8 -math.floor(oc)local uc,vc=qc[1]+sc,qc[2]+tc;for x=1,W.Size[1]do for y=1,W.Size[2]do local wc,xc=x+uc,y+vc;kc.Data[wc]=kc.Data[wc]or{}kc.Data[wc][-xc]=pc.Data[x]and pc.Data[x][y]kc.Color[wc]=kc.Color[wc]or{}kc.Color[wc][-xc]=rc end end end;local function pb(kc,lc)local mc=X[lc.status]local nc=mc.Offset;local oc=mc.Color.All;local pc,qc=0,0;for rc,sc in pairs(mc.Data)do for tc,uc in pairs(sc)do if uc=='1'then local vc,wc=rc+nc[1]+pc,tc+nc[2]+qc;kc.Data[vc]=kc.Data[vc]or{}kc.Data[vc][wc]=uc;kc.Color[vc]=kc.Color[vc]or{}kc.Color[vc][wc]=oc end end end end;local qb={ClearScreen=function()io.write("\27[2J")end,SetCursor=function(kc,lc)io.write(string.format("\27[%d;%dH",lc,kc))end}local rb=Taiko.GetAllNotes(k.Data)local sb=k.Metadata.OFFSET;local tb=1000 /60;local ub=k.Metadata.TIMING(tb/u)local vb={}for kc,lc in pairs(rb)do lc.ms=lc.oms or lc.ms;lc.oms=lc.ms;lc.ms=(lc.ms-sb)/u;lc.s=MsToS(lc.ms)lc.delay=lc.odelay or lc.delay;lc.odelay=lc.delay;lc.p={}lc.delay=lc.delay/u;lc.speed=Taiko.CalculateSpeed(lc,F)lc.speed[1]=lc.speed[1]*t;lc.speed[2]=lc.speed[2]*t;lc.loadms=ib(lc,lc.ms)lc.loads=MsToS(lc.loadms)lc.hit=nil;vb[#vb+1]=lc.ms end;if v then for nc,oc in pairs(k.Data)do if oc.branch then for pc,qc in pairs(oc.branch.paths)do table.sort(qc,function(rc,sc)return rc.ms<sc.ms end)end end end;table.sort(k.Data,function(nc,oc)if nc.branch and oc.branch then for pc,qc in pairs(nc.branch.paths)do for rc,sc in pairs(oc.branch.paths)do return qc[1].ms<sc[1].ms end end elseif nc.branch then for pc,qc in pairs(nc.branch.paths)do return qc[1].ms<oc.ms end elseif oc.branch then for pc,qc in pairs(oc.branch.paths)do return nc.ms<qc[1].ms end else return nc.ms<oc.ms end end)local kc=nil;local lc=0;local mc={}Taiko.ForAll(k.Data,function(nc,oc,pc)if nc.delay~=lc then if kc then kc.stopms=nc.delay-kc.delay;kc.stopstart=kc.ms;kc.stopend=kc.stopstart+kc.stopms end;lc=nc.delay end;if kc and kc.delay~=0 then kc.ms=kc.ms-kc.delay;kc.s=MsToS(kc.ms)kc.loadms=ib(kc,kc.ms)kc.loads=MsToS(kc.loadms)kc.ms=kc.ms+kc.delay;kc.s=MsToS(kc.ms)end;kc=nc end)end;for kc,lc in pairs(k.Data)do if lc.branch then for mc,nc in pairs(lc.branch.paths)do table.sort(nc,function(oc,pc)return oc.loadms<pc.loadms end)end end end;table.sort(k.Data,function(kc,lc)if kc.branch and lc.branch then for mc,nc in pairs(kc.branch.paths)do for oc,pc in pairs(lc.branch.paths)do return nc[1].loadms<pc[1].loadms end end elseif kc.branch then for mc,nc in pairs(kc.branch.paths)do return nc[1].loadms<lc.loadms end elseif lc.branch then for mc,nc in pairs(lc.branch.paths)do return kc.loadms<nc[1].loadms end else return kc.loadms<lc.loadms end end)Taiko.ConnectAll(k.Data)Taiko.ForAll(k.Data,function(kc,lc,mc)kc.n=mc end)local wb=E/u;local xb=vb[1]for i=1,#vb do if vb[i]>xb then xb=vb[i]end end;xb=xb+wb;loaded={}local yb=k.Data[1]local zb=yb.loads;local Ab=10;local Bb=string.rep(' ',Ab)local Cb={}local function Db(kc,lc)Cb[#Cb+1]=kc;Cb[#Cb+1]=': 'Cb[#Cb+1]=tostring(lc)Cb[#Cb+1]=Bb;Cb[#Cb+1]='\n'end;local function Eb()print(table.concat(Cb))Cb={}end;local Fb={}local function Gb(kc)Fb[#Fb+1]=kc end;local function Hb()print(table.concat(Fb,'\n'))Fb={}end;qb.ClearScreen()local Ib='M'local Jb=0;local Kb,Lb,Mb=k.Metadata.SCOREINIT,k.Metadata.SCOREDIFF,Taiko.Data.ScoreMode.Note[k.Metadata.SCOREMODE]local Nb=0;local Ob=false;local Pb=nil;local Qb=nil;local Rb=nil;local Sb=Taiko.Data.ScoreMode.Balloon[k.Metadata.SCOREMODE]local Tb=Taiko.Data.ScoreMode.BalloonPop[k.Metadata.SCOREMODE]local Ub=nil;local Vb=nil;local Wb=nil;local Xb=Taiko.Data.ScoreMode.Drumroll[k.Metadata.SCOREMODE]local Yb={startms=nil,status=nil}local Zb=nil;local ac=nil;local bc=nil;local cc=0;local dc={-1,nil}local ec=0;local fc=0;local gc=true;local hc=os.clock()local ic,jc;if p then ic=1 /p;jc=hc+ic end;if not o.on then while true do local kc=Y.New()local lc=os.clock()local mc=lc-hc;local nc=mc*1000;if bc and nc>bc then Zb,ac,bc=nil,nil,nil end;if Rb and nc>Rb then Pb,Qb,Rb=nil,nil,nil end;if Wb and nc>Wb then Ub,Vb,Wb=nil,nil,nil end;if yb then while true do if yb and yb.loadms<nc+cc then loaded[#loaded+1]=yb;if yb.endnote then loaded[#loaded+1]=yb.endnote end;yb=yb.nextnote;if yb then if yb.startnote then yb=yb.nextnote end;if yb and yb.branch then yb=yb.branch.paths[Ib][1]end end else break end end else if nc>xb then break end end;Y.Circle(kc,math.floor(K[1]),math.floor(K[2]),F,{color='purple'})local oc={}local pc={}local qc=0;for i=1,#loaded do local vc=i+qc;local wc=loaded[vc]if wc then if not(wc.hit)and wc.data=='note'then if(wc.type==1 or wc.type==3)and(not oc[1]or math.abs(nc-wc.ms)<oc[1])then oc[1]=math.abs(nc-wc.ms)pc[1]=wc elseif(wc.type==2 or wc.type==4)and(not oc[2]or math.abs(nc-wc.ms)<oc[2])then oc[2]=math.abs(nc-wc.ms)pc[2]=wc end end;local xc,yc=jb(wc,Zb or(nc+cc))wc.p[1]=xc;wc.p[2]=yc;if nc>wc.ms then Ob=wc.gogo;if wc.type==7 then if Pb then if Pb.n==wc.n then wc.p[1]=K else end end;Pb=wc;Qb=wc.ms;Rb=wc.ms+wc.length elseif wc.type==5 or wc.type==6 then Ub=wc;Vb=wc.ms;Wb=wc.ms+wc.length end end;if v and wc.stopstart and nc>wc.stopstart then Zb=cc+wc.stopstart;stopms=wc.stopms;cc=cc-wc.stopms;ac=wc.stopstart;bc=wc.stopend;wc.stopstart=nil end;if r then if not wc.hit and s[wc.type]and nc>=wc.ms then local zc;zc=( (notetype==3 or notetype==4)and 3)or 2;Nb=Nb+1;if zc then Jb=Mb(Jb,Nb,Kb,Lb,zc,wc.gogo)wc.hit=true;Yb={startms=nc,status=zc}end end end;if(wc.hit and not(v and wc.stopstart and not(nc>wc.stopstart)))or gb(wc.p[1],wc.p[2],U[1],U[2],U[3],U[4])==false and(not(wc.type==8 and nc<wc.ms))then wc.done=true;table.remove(loaded,vc)qc=qc-1 else if not wc.hit then if gc then if wc.data=='event'then if wc.event=='barline'then kb(kc,wc)end elseif wc.data=='note'then nb(kc,wc)else error('Invalid note.data')end end end end end end;if Yb.status then if nc>Yb.startms+N then Yb={}else ob(kc,Yb,nc,0)end end;qb.SetCursor(1,1)if p then local vc=Y.Convert.ToDots(kc)repeat until os.clock()>=jc;jc=jc+ic;print(vc)else print(Y.Convert.ToDots(kc))end;ec=ec+1;local rc=os.clock()-lc;fc=fc+rc;local sc=f.getch(V)local tc=f.getkeyname(sc)local uc=w.Hit[tc]if r then local vc=oc[1]local wc=oc[2]local xc=(vc and wc)and( (vc<wc)and 1 or 2)or(vc and 1 or 2)local yc=oc[xc]local zc=pc[xc]if not yc or(yc and yc> (ub.bad* ( ( (zc.type==3 or zc.type==4)and Taiko.Data.BigLeniency)or 1)))then if Qb and(nc>Qb and nc<Rb)then uc=1 elseif Vb and(nc>Vb and nc<Wb)then uc=1 end end end;if uc then if oc[uc]and(not pc[uc].hit)then local vc=pc[uc]local wc=vc.type;local xc=oc[uc]local yc;local zc=( (wc==3 or wc==4)and Taiko.Data.BigLeniency)or 1;if xc< (ub.good)then yc=( (wc==3 or wc==4)and 3)or 2;Nb=Nb+1 elseif xc< (ub.ok*zc)then yc=1;Nb=Nb+1 elseif xc< (ub.bad*zc)then yc=0;Nb=0 else yc=nil end;if yc then Jb=Mb(Jb,Nb,Kb,Lb,yc,vc.gogo)pc[uc].hit=true;Yb={startms=nc,status=yc}end end;if(uc==1)and Qb and(nc>Qb and nc<Rb)then Jb=Sb(Jb,Pb.type,notegogo)end;if(uc==1 or uc==2)and Vb and(nc>Vb and nc<Wb)then Jb=Xb(Jb,Ub.type,notegogo)end end;if w.Escape[tc]then local vc=os.clock()qb.ClearScreen()f.nodelay(V,false)local wc={'Back','Retry','Back to Select'}while true do qb.SetCursor(1,1)local xc={}for i=1,#wc do xc[i]=( (i==x)and(A..string.rep(' ',z-#A))or string.rep(' ',z))..wc[i]end;print(table.concat(xc,B))local yc=f.getch(V)local zc=f.getkeyname(yc)if w.L[zc]then x=x==1 and 1 or x-1 elseif w.R[zc]then x=x==3 and 3 or x+1 elseif w.Select[zc]then if x==1 then elseif x==2 then return'Retry'elseif x==3 then return nil end;break elseif w.Escape[zc]then break end end;f.nodelay(V,true)hc=hc+ (os.clock()-vc)end;if sc~=-1 then dc={sc,tc}end;Db('Input (ascii)',dc[1])Db('Input (key)',dc[2])Db('S',mc)Db('Ms',nc)Db('Loaded',#loaded)Db('Frames Rendered',ec)Db('Last Frame Render (ms)',rc*1000)Db('Frame Render Total (ms)',fc*1000)Db('Frame Render Total (%)',fc/mc*100)Db('FPS (Frame)',ec/mc)Db('Stop Start',ac or'')Db('Stop End',bc or'')Db('Total Delay',cc)Db('Score',Jb)Db('Combo',Nb)Db('Gogo',Ob)Db('Drumroll Start',Vb)Db('Drumroll End',Wb)Eb()Hb()end else error('Prerendering has been removed')end;return true end;function Taiko.SongSelect(k,l,m)local n={}local o,p=10,10;local q,r,s,t=-o,o,-p,p;local u=true;local v=1;local w=1;local x=4;local y=5;local z=5;local A=2;local B='V'local C='>'local D=10;local E=nil;local F='>'local G='>'local H=2;local I=true;local J='_Original_'local K=m or{}local L=false;local M={[2]={'Normal','Auto'},[3]={'Normal','2x Speed','3x Speed','4x Speed','0.25x Speed','0.5x Speed','0.75x Speed'},[4]={'Normal','2x Speed','3x Speed','4x Speed','0.25x Speed','0.5x Speed','0.75x Speed'},[5]={'Normal','Reverse','Invisible','Messy'}}local N={4,1,1,1,1,1}local O={nil}for kb,lb in pairs(M)do O[kb]={1,#lb,lb}end;local P={[1]=nil,[2]={function(kb)return kb,'type',kb.type and(Taiko.Data.Notes.ReverseNotes[kb.type]or kb.type)or kb.type end,function(kb)return kb,'type'end},[3]={function(kb)return kb,'scrollx',10000 end,function(kb)return kb,'scrollx'end},[4]={function(kb)return kb,'type',kb.type and(kb.type==1 and math.random(1,2)or kb.type==2 and math.random(1,2)or kb.type==3 and math.random(3,4)or kb.type==4 and math.random(3,4)or kb.type)end,function(kb)return kb,'type'end}}local Q={window=f.initscr()}f.keypad(Q,true)f.echo(false)f.raw(true)f.nl(false)f.cbreak(true)f.nodelay(Q,true)f.getch(Q)f.nodelay(Q,false)local R,S=f.cols(),f.lines()E=E or R-2;local T={Escape={['\27']=true,ALT_ESC=true},Scroll={L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_A2=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true}},Select={Init={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Escape={['\27']=true,ALT_ESC=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true},U={KEY_UP=true,KEY_A2=true},D={KEY_DOWN=true,KEY_C2=true},Play={Hit={['4']=2,['v']=1,['n']=1,['8']=2},Escape={['\27']=true,ALT_ESC=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_DOWN=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}}},Search={Init={ALT_F=true,f=true,F=true},Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},FirstResult={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Select={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true},Up={KEY_A2=true,KEY_UP=true},Down={KEY_C2=true,KEY_DOWN=true},Escape={['\27']=true,ALT_ESC=true}},Add={Init={ALT_N=true,n=true,N=true},Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}},StandardInput={Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},Escape={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_DOWN=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true}},Reload={Init={r=true}},ReloadAll={Init={R=true}},Rename={Init={KEY_F2=true}}}local U={ClearScreen=function()io.write("\27[2J")end,SetCursor=function(kb,lb)io.write(string.format("\27[%d;%dH",lb,kb))end,ClearLine=function()io.write("\27[2K")end,CursorLeft=function(kb)io.write(string.format("\27[%dD",kb))end,CursorRight=function(kb)io.write(string.format("\27[%dC",kb))end,SaveCursor=function()io.write("\27[s")end,RestoreCursor=function()io.write("\27[u")end}local function V(kb)return kb..string.rep(' ',E-#kb)end;local function W()local kb=f.getch(Q)local lb=f.getkeyname(kb)return kb,lb end;local function X()local kb=''local lb=0;local mb=lb;while true do local nb,ob=W()if T.StandardInput.Backspace[ob]then kb=string.sub(kb,1,lb-1)..string.sub(kb,lb+1,-1)lb=lb-1 elseif T.StandardInput.Escape[ob]then io.write('\n')return kb elseif T.StandardInput.L[ob]then lb=lb-1 elseif T.StandardInput.R[ob]then lb=lb+1 else kb=string.sub(kb,1,lb)..ob..string.sub(kb,lb+1,-1)lb=lb+1 end;lb=ClipN(lb,0,#kb)local pb=lb-mb;if pb<0 then U.CursorLeft(-pb)elseif pb>0 then U.CursorRight(pb)end;U.SaveCursor()U.ClearLine()io.write('\r')io.write(kb)U.RestoreCursor()mb=lb end end;local function Y(kb)return kb>=32 and kb<=126 end;local function Z(kb,lb,mb,nb)return(kb and(lb..string.sub(mb,#lb+1,-1))or mb)..nb end;local function ab(kb,lb,mb)return kb>mb and lb or kb<lb and mb or kb end;local bb={[0]='No',[1]='Yes'}local function cb(kb)return kb and bb[1]or bb[0]end;local function db(kb)return kb*100 ..'%'end;local function eb(kb)return MsToS(kb)..'s'end;local function fb(kb)return eb(SToMs(kb))end;local function gb(kb)return tonumber(kb)and tonumber(kb)or 0 end;local function hb(kb,lb,mb)kb[J..lb]=kb[lb]kb[lb]=mb end;local function ib(kb,lb)kb[lb]=kb[J..lb]end;local jb={}U.ClearScreen()while true do n={}if u then n[q]={}for i=v-y,v+y do local ob=nil;if i<1 then ob=#k+i elseif i>#k then ob=i-#k else ob=i end;local pb=k[ob]if pb then n[0]=n[0]or{}n[0][(i-v)*z]=pb end end;local mb={}local nb=string.rep(' ',A)for y=s,t do mb[#mb+1]=Z(y==0,C,nb,'')mb[#mb+1]=V(n[0]and n[0][y]or'')mb[#mb+1]='\n'end;U.SetCursor(1,1)print(table.concat(mb))else n[0]={}n[0][s]=B;for i=v-y,v+y do local nb=nil;if i<1 then nb=#k+i elseif i>#k then nb=i-#k else nb=i end;local ob=k[nb]if ob then local pb=(i-v)*z;n[pb]=n[pb]or{}local qb=s+A;for i2=1,#ob do n[pb][qb]=string.sub(ob,i2,i2)qb=qb+1 end end end;local mb={}for y=s,t do for x=q,r do if n[x]and n[x][y]then local nb=n[x][y]if Y(string.byte(nb))then mb[#mb+1]=nb else mb[#mb+1]=' 'end else mb[#mb+1]=' 'end end;mb[#mb+1]='\n'end;U.SetCursor(1,1)print(table.concat(mb))end;local kb,lb=W()if T.Scroll.L[lb]then v=v-1 elseif T.Scroll.R[lb]then v=v+1 elseif T.Select.Init[lb]then local mb;if I then if jb[v]then mb=jb[v]else mb=Taiko.ParseTJA(l[v])jb[v]=mb end else mb=Taiko.ParseTJA(l[v])end;local nb={}for rb,sb in pairs(mb)do nb[#nb+1]={rb,sb.Metadata.COURSE}end;table.sort(nb,function(rb,sb)return rb[2]<sb[2]end)min=1;max=#nb;O[1]={min,max,nb}DifficultyMap=nb;N[1]=ClipN(N[1],min,max)local ob=string.rep(' ',H)U.ClearScreen()U.SetCursor(1,1)local pb=nil;local qb=w;while true do w=ClipN(w,1,5)if w~=qb then x=N[w]qb=w end;local rb=O[w]min,max=rb[1],rb[2]x=ab(x,min,max)N[w]=x;U.SetCursor(1,1)local sb=DifficultyMap[N[1]][2]pb=Taiko.GetDifficulty(mb,sb)local tb=pb.Metadata;local ub=Taiko.Analyze(pb)local vb={{'',tb.TITLE},{'\t',tb.SUBTITLE},{'',''},{'','Select Options:'},{Z(w==1,G,ob,'Difficulty: '),Taiko.Data.CourseName[tb.COURSE]},{Z(w==2,G,ob,'Mode: '),M[2][N[2]]},{Z(w==3,G,ob,'Note Speed: '),M[3][N[3]]},{Z(w==4,G,ob,'Song Speed: '),M[4][N[4]]},{Z(w==5,G,ob,'Modifiers: '),M[5][N[5]]},{'',''},{'Difficulty: ',Taiko.Data.CourseName[tb.COURSE]},{'Stars: ',tb.LEVEL},{'Diverge Notes: ',cb(tb.DIVERGENOTES)},{'',''},{'','Statistics:'},{'Length: ',eb(ub.lengthms)},{'Don (DON) / Ka (KA): ',gb(ub.notes[1])..' + ('..gb(ub.notes[3])..') / '..gb(ub.notes[2])..' + ('..gb(ub.notes[4])..') = '..db((gb(ub.notes[1])+gb(ub.notes[3]))/ub.notes.validn)..' / '..db((gb(ub.notes[2])+gb(ub.notes[4]))/ub.notes.validn)},{'Max Score (without drumroll): ',ub.maxscore},{'Max Combo: ',ub.maxcombo},{'Drumroll Time (total): ',eb(ub.drumrollms+ub.drumrollbigms)},{'Balloon Time: ',eb(ub.balloonms)},{'Balloon Hits: ',ub.balloonhit},{'Special Time: ',eb(ub.specialms)},{'Special Hits: ',ub.specialhit},{'',''},{'','Press Enter to Play!'}}for i=1,#vb do local yb=vb[i]print(V(yb[1]..tostring(yb[2])))end;local wb,xb=W()if T.Select.L[xb]then x=x-1 elseif T.Select.R[xb]then x=x+1 elseif T.Select.U[xb]then w=w-1 elseif T.Select.D[xb]then w=w+1 elseif T.Select.Select[xb]then local yb=P[N[5]]if yb and yb[1]then local zb=yb[1]Taiko.ForAll(pb.Data,function(Ab,Bb,Cb)hb(zb(Ab))end)end;while true do local zb,Ab=Taiko.PlaySong(pb,Q,N,T.Select.Play)if zb and Ab then break elseif zb=='Retry'then else break end end;f.nodelay(Q,false)U.ClearScreen()if yb and yb[2]then local zb=yb[2]Taiko.ForAll(pb.Data,function(Ab,Bb,Cb)ib(zb(Ab))end)end elseif T.Select.Escape[xb]then break end end elseif T.Search.Init[lb]then local mb=''local nb={}local ob=1;local pb=nil;local qb=1;U.ClearScreen()U.SetCursor(1,1)print('Searching...')while true do U.SetCursor(#mb+1,2)local rb,sb=W()U.SetCursor(1,2)if T.Search.Backspace[sb]then mb=string.sub(mb,1,-2)elseif T.Search.FirstResult[sb]then pb=nb[1]break elseif T.Search.Select[sb]then pb=nb[qb]break elseif T.Search.Down[sb]then qb=qb+1 elseif T.Search.Up[sb]then qb=qb-1 elseif T.Search.Escape[sb]then break else mb=mb..sb end;print(V(mb))local tb=g.SearchHeaderAll(k,mb)for i=1,D do if tb[i]and tb[i][2]==-math.huge then ob=i-1;break elseif i==D then ob=i end end;qb=ClipN(qb,1,ob)local ub=false;for i=1,D do local vb=tb[i]if ub then print(V(''))else if vb then if vb[2]==-math.huge then ub=true;print(V(''))else print(V((i==qb and F or i)..'. '..tb[i][3]))nb[i]=vb end end end end end;v=(pb and pb[1]or v)or v elseif T.Add.Init[lb]then print('Import a Custom Song')while true do print('Enter a .tja or .tjac file path (with the file extention)')local mb=X()local nb=io.open(mb,'rb')if nb then local ob=nb:read('*all')if EndsWith(mb,'.tja')then print('Enter a song name')local pb=X()local qb=#k+1;k[qb]=pb;l[qb]=ob;K[qb]={mb}break elseif EndsWith(mb,'.tjac')then local pb,qb=g.Decompress(ob)for i=1,#pb do local rb=#k+1;k[rb]=qb[i]l[rb]=pb[i]K[rb]={mb,pb}end;break else print('Invalid file type')end;nb:close()else print('Unable to read file')end end elseif T.Reload.Init[lb]then print('Reloading selected file...')if K[v]then local mb=K[v]local nb=io.open(mb[1],'rb')if nb then local ob=nb:read('*all')local pb=v;if mb[2]then local qb,rb=g.Decompress(ob)if L then k[pb]=rb[i]end;l[pb]=qb[i]else l[pb]=ob end;if I then jb[pb]=nil end;nb:close()else print('Unable to read file')end else print('File source not found')end elseif T.ReloadAll.Init[lb]then print('Reloading all files...')local mb={}for nb,ob in pairs(K)do mb[ob[1]]=mb[ob[1]]and mb[ob[1]]or{}mb[ob[1]][#mb[ob[1]]+1]={nb,ob[2]}end;for nb,ob in pairs(mb)do local pb=io.open(nb,'rb')if pb then local qb=pb:read('*all')if ob[1][2]then local rb,sb=g.Decompress(qb)for i=1,#ob do local tb=ob[i]if L then k[tb[1]]=sb[tb[2]]end;l[tb[1]]=rb[tb[2]]if I then jb[tb[1]]=nil end end else for i=1,#ob do local rb=ob[i]l[rb[1]]=qb;if I then jb[rb[1]]=nil end end end;pb:close()else print('Unable to read file')end end elseif T.Rename.Init[lb]then print('Enter a song name')local mb=X()k[v]=mb elseif T.Escape[lb]then return end;v=ab(v,1,#k)end end;function Taiko.Game()end;local h='./CompactTJA/taikobuipm.tjac'h='./CompactTJA/ESE/06 Classical.tjac'h='./CompactTJA/ESE/ESE.tjac'local function j(k)local l,m,n={},{},{}for i=1,#k do local o=k[i]l[#l+1]=o:gsub('(.-)/','')local p=io.open(o,'r')local q=p:read('*all')p:close()m[#m+1]=q;n[#n+1]=o end;return l,m,n end;Taiko.SongSelect(j({'./tja/neta/ekiben/spiraltest.tja','./tja/neta/ekiben/delay.tja','./tja/neta/ekiben/neta.tja','./tja/neta/kita/kita.tja','./taikobuipm/Kita Saitama 2000.tja'}))error()
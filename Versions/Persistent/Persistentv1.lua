--[[
persistentv1.lua

Goal:
save scores (numbers) and strings elegantly and compactly

maybe lzw?



Look at:
https://github.com/Dynodzzo/Lua_INI_Parser/blob/master/LIP.lua


file format:
tpd (taiko persistent data)
(pcd)
]]











Persistent = {}







function Persistent.Read(file)
    local f = io.open(file, 'rb')
    local s = f:read('*all')
    f:close()
    return s
end

function Persistent.Write(file, str)
    local f = io.open(file, 'wb+')
    f:write(str)
    f:close()
end




--https://stackoverflow.com/questions/15706270/sort-a-table-in-lua
local spairs = function(a,b)local c={}for d in pairs(a)do c[#c+1]=d end;if b then table.sort(c,function(e,f)return b(a,e,f)end)else table.sort(c)end;local g=0;return function()g=g+1;if c[g]then return c[g],a[c[g]]end end end

function Persistent.Save(t, out, indent)
    --[[
        assumes t is not recursive
        assumes all keys are key strings
        assumes strings do not have invalid chars
    ]]
    local originalout = out
    out = out or {'Automatically generated by Persistent.\nThis file will be read and overwritten.\nDO NOT EDIT\n'}
    indent = indent and indent + 1 or 1

    out[#out + 1] = '{\n'
    for k, v in spairs(t, function(t, a, b)
        return tostring(a) < tostring(b)
    end) do
        out[#out + 1] = string.rep('\t', indent)
        if type(k) == 'string' then
            out[#out + 1] = '\''
            out[#out + 1] = k
            out[#out + 1] = '\''
        elseif type(k) == 'number' or type(k) == 'boolean' or type(k) == 'nil' then
            out[#out + 1] = tostring(k)
        else
            error('Invalid key type, ' .. type(k))
        end
        out[#out + 1] = ' = '
        if type(v) == 'table' then
            Persistent.Save(v, out, indent)
        elseif type(v) == 'string' then
            out[#out + 1] = '\''
            out[#out + 1] = v
            out[#out + 1] = '\''
        elseif type(v) == 'number' or type(v) == 'boolean' or type(v) == 'nil' then
            out[#out + 1] = tostring(v)
        else
            error('Invalid value type, ' .. type(v))
        end
        out[#out + 1] = ',\n'
    end
    out[#out + 1] = string.rep('\t', indent - 1)
    out[#out + 1] = '}'
    if not originalout then
        return table.concat(out)
    end
end


function Persistent.Load(str)
    --[[
        Instead of lazy loadstringing, we parse
    ]]
    local out = {}

    local escapetable = 0
    local escapestring = 0
    local lastescapestring = true
    local consecutivebackslash = 0
    local acceptingkey = true
    local acceptingvalue = false
    local lastkey = {}
    local lastvalue = {}
    local path = {}
    local currentt = out

    --print('s\tkey\tvalue')
    --Find first table, ignore everything before
    local i = string.find(str, '{') - 1
    repeat
        i = i + 1

        if string.sub(str, i, i + 2) == ' = ' then
            acceptingkey = false
            acceptingvalue = true
            lastvalue = {}
            i = i + 3
        end

        local s = string.sub(str, i, i)
        --print(s, acceptingkey, acceptingvalue)


        if s == '{' then
            escapetable = escapetable + 1
            if escapetable >= 2 then
                acceptingkey = true
                acceptingvalue = false

                local k = table.concat(lastkey)
                --Parse Key
                k = string.sub(k, 1, 1) == '\'' and string.sub(k, 2, -2) or tonumber(k) and tonumber(k) or k == 'true' and true or k == 'false' and false

                path[#path + 1] = k
                lastkey = {}

                local t = out
                for i = 1, #path - 1 do
                    t = t[path[i]]
                end
                t[path[#path]] = {}
                currentt = t[path[#path]]
            end
        elseif s == '}' then
            escapetable = escapetable - 1
            if #path >= 1 then
                path[#path] = nil

                local t = out
                for i = 1, #path do
                    t = t[path[i]]
                end
                currentt = t
            end
        elseif s == '\'' and consecutivebackslash % 2 == 0 then
            escapestring = lastescapestring and escapestring + 1 or escapestring - 1
            lastescapestring = not lastescapestring
        elseif s == '\\' then
            consecutivebackslash = consecutivebackslash + 1
        --elseif acceptingkey and string.find(s, '%a') then
        end
        if acceptingkey and s ~= '{' and s ~= '}' and s ~= ',' and s ~= '\t' and s ~= '\n' and s ~= ' ' then
            lastkey[#lastkey + 1] = s
        end
        --print(table.concat(lastkey))
            
        if acceptingvalue then
            if escapestring == 0 and s == ',' then

                local k = table.concat(lastkey)
                --Parse Key
                k = string.sub(k, 1, 1) == '\'' and string.sub(k, 2, -2) or tonumber(k) and tonumber(k) or k == 'true' and true or k == 'false' and false

                local v = table.concat(lastvalue)
                --Parse Value
                v = string.sub(v, 1, 1) == '\'' and string.sub(v, 2, -2) or tonumber(v) and tonumber(v) or v == 'true' and true or v == 'false' and false


                currentt[k] = v
                acceptingkey = true
                acceptingvalue = false
                lastkey = {}
            else
                lastvalue[#lastvalue + 1] = s
            end
        end

        if s ~= '\\' then
            consecutivebackslash = 0
        end
    until i >= #str

    return out
end





return Persistent
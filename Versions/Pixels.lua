--Pixelsv20_min.lua NO_TEST_CODE
CacheEnabled=false;WarnEnabled=false;ErrorEnabled=true;WarnStrict=false;DefaultPixel={}ReverseY=false;os.execute('chcp 65001')Escape={}Escape.Data={['a']='\a',['b']='\b',['f']='\f',['n']='\n',['r']='\r',['t']='\t',['v']='\v',['\\']='\\',['\"']='\"',['\'']='\'',['[']='[',[']']=']'}Escape.DataReversed={}for fd,gd in pairs(Escape.Data)do Escape.DataReversed[gd]=fd end;function Escape.EscapeToString(fd)local gd=''local hd=false;local id=0;for i=1,#fd do if id>0 then id=id-1 else local jd=string.sub(fd,i,i)if hd then local kd=Escape.Data[jd]if kd then gd=gd..kd else local ld=i;local md=''repeat md=md..string.sub(fd,ld,ld)ld=ld+1;if tonumber(string.sub(fd,ld,ld))==nil then break end;if ld==#fd then error('Invalid Escape Sequence.')end until ld==#fd;gd=gd..string.char(tonumber(md))id=#md-1 end;hd=false else if jd=='\\'then hd=true else gd=gd..jd end end end end;return gd end;function Escape.StringToEscape(fd,gd)if gd then return fd end;return string.gsub(tostring(fd),'\27','\\27')end;LuaMode=true;SerialSeperator='~'EndSeperator='/'Minify=true;PrintOutput=true;printplusplus=function(fd)local gd={assert,collectgarbage,coroutine,coroutine.create,coroutine.resume,coroutine.running,coroutine.status,coroutine.wrap,coroutine.yield,debug,debug.debug,debug.getfenv,debug.gethook,debug.getinfo,debug.getlocal,debug.getmetatable,debug.getregistry,debug.getupvalue,debug.setfenv,debug.sethook,debug.setlocal,debug.setmetatable,debug.setupvalue,debug.traceback,dofile,dump,error,gcinfo,getfenv,getmetatable,io,io.close,io.flush,io.input,io.lines,io.open,io.output,io.popen,io.read,io.stderr,io.stdin,io.stdout,io.tmpfile,io.type,io.write,ipairs,load,loadfile,loadstring,math,math.abs,math.acos,math.asin,math.atan,math.atan2,math.ceil,math.cos,math.cosh,math.deg,math.exp,math.floor,math.fmod,math.frexp,math.huge,math.ldexp,math.log,math.log10,math.max,math.min,math.mod,math.modf,math.pi,math.pow,math.rad,math.random,math.randomseed,math.sin,math.sinh,math.sqrt,math.tan,math.tanh,module,newproxy,next,os,os.clock,os.date,os.difftime,os.execute,os.exit,os.getenv,os.remove,os.rename,os.setlocale,os.time,os.tmpname,package,package.config,package.cpath,package.loaded,string.byte,string.char,string.dump,string.find,string.format,string.gfind,string.gmatch,string.gsub,string.len,string.lower,string.match,string.rep,string.reverse,string.sub,string.upper,table.concat,table.foreach,table.foreachi,table.getn,table.insert,table.maxn,table.remove,table.setn,table.sort,package.loaders,package.loadlib,package.path,package.preload,package.seeall,pairs,pcall,print,rawequal,rawget,rawset,require,select,setfenv,setmetatable,started,string,table,tonumber,tostring,type,unpack,xpcall}local hd={'assert','collectgarbage','coroutine','coroutine.create','coroutine.resume','coroutine.running','coroutine.status','coroutine.wrap','coroutine.yield','debug','debug.debug','debug.getfenv','debug.gethook','debug.getinfo','debug.getlocal','debug.getmetatable','debug.getregistry','debug.getupvalue','debug.setfenv','debug.sethook','debug.setlocal','debug.setmetatable','debug.setupvalue','debug.traceback','dofile','dump','error','gcinfo','getfenv','getmetatable','io','io.close','io.flush','io.input','io.lines','io.open','io.output','io.popen','io.read','io.stderr','io.stdin','io.stdout','io.tmpfile','io.type','io.write','ipairs','load','loadfile','loadstring','math','math.abs','math.acos','math.asin','math.atan','math.atan2','math.ceil','math.cos','math.cosh','math.deg','math.exp','math.floor','math.fmod','math.frexp','math.huge','math.ldexp','math.log','math.log10','math.max','math.min','math.mod','math.modf','math.pi','math.pow','math.rad','math.random','math.randomseed','math.sin','math.sinh','math.sqrt','math.tan','math.tanh','module','newproxy','next','os','os.clock','os.date','os.difftime','os.execute','os.exit','os.getenv','os.remove','os.rename','os.setlocale','os.time','os.tmpname','package','package.config','package.cpath','package.loaded','string.byte','string.char','string.dump','string.find','string.format','string.gfind','string.gmatch','string.gsub','string.len','string.lower','string.match','string.rep','string.reverse','string.sub','string.upper','table.concat','table.foreach','table.foreachi','table.getn','table.insert','table.maxn','table.remove','table.setn','table.sort','package.loaders','package.loadlib','package.path','package.preload','package.seeall','pairs','pcall','print','rawequal','rawget','rawset','require','select','setfenv','setmetatable','started','string','table','tonumber','tostring','type','unpack','xpcall'}local function id(od)local pd=od;if type(od)=='string'then local qd,rd=loadstring(od)if qd==nil then return pd end end;if pcall(function()string.dump(od)end)then if Minify then return'loadstring\''.. (string.gsub(string.dump(od),'.',function(qd)return'\\'..qd:byte()end)or string.dump(od)..'\'')..'\''else return'loadstring(\''.. (string.gsub(string.dump(od),'.',function(qd)return'\\'..qd:byte()end)or string.dump(od)..'\'')..'\')'end else for i=1,#gd do if gd[i]==od then return hd[i]end end end end;local function jd(od)local pd=getmetatable(od)local qd=nil;if pd~=nil then local rd=nil;qd=''for sd,td in pairs(pd)do rd=true;if Minify then qd=qd..sd..'='..id(td)..','else qd=qd..sd..' = '..id(td)..',\n'end end;if rd==true then local sd;if Minify then sd=1 else sd=2 end;qd=string.sub(qd,1,#qd-sd)return qd else return nil end end end;local function kd(od)local pd=0;for qd in pairs(od)do pd=pd+1 end;return pd end;local function ld(od,pd)local qd=jd(od)pd=pd or 0;local rd=kd(od)>1;local sd=string.rep('    ',pd+1)local td="{".. (rd and'\n'or'')if Minify then sd=''td='{'end;for ud,vd in pairs(od)do td=td.. (rd and sd or'')if type(ud)=='number'then elseif type(ud)=='string'and ud:match("^[A-Za-z_][A-Za-z0-9_]*$")then td=td..ud.. (Minify and"="or" = ")elseif type(ud)=='string'then td=td.. (Minify and"[\'"..ud.."\']="or"[\'"..ud.."\'] = ")else td=td.. (Minify and"["..tostring(ud).."]="or"["..tostring(ud).."] = ")end;local wd,xd=SerializeMain(vd)td=td..wd;if next(od,ud)then td=td..","end;if not Minify then if rd then td=td..'\n'else td=td..' 'end end end;td=td.. (rd and string.rep('    ',pd)or'').."}"if qd~=nil then if Minify then td='setmetatable('..td..',{'..qd..'})'else td='setmetatable('..td..', {\n'..qd..'\n})'end end;return td end;function SerializeMain(od)local pd;local qd;local rd=SerialSeperator;local sd=EndSeperator;if type(od)=='number'or type(od)=='boolean'or type(od)=='nil'then pd=tostring(od)qd=tostring(od)elseif type(od)=='string'then pd='\''..tostring(od)..'\''qd=rd..type(od)..rd..tostring(od)..rd..sd..type(od)..rd elseif type(od)=='table'then pd=ld(od)qd=rd..type(od)..rd..ld(od)..rd..sd..type(od)..rd elseif type(od)=='function'then pd=id(od)qd=rd..type(od)..rd..id(od)..rd..sd..type(od)..rd elseif type(od)=='userdata'or type(od)=='thread'then pd=type(od)qd=rd..type(od)..rd..rd..sd..type(od)..rd end;return pd,qd end;local md,nd=SerializeMain(fd)if PrintOutput then print(LuaMode and md or nd)else return LuaMode and md or nd end end;ppp=printplusplus;Split=function(fd,gd)c={}for hd,id in fd:gmatch("([^"..gd.."]*)("..gd.."?)")do table.insert(c,hd)if id==''then return c end end end;local Ib=([[
⠀ ⢀ ⠠ ⢠ ⠐ ⢐ ⠰ ⢰ ⠈ ⢈ ⠨ ⢨ ⠘ ⢘ ⠸ ⢸
⡀ ⣀ ⡠ ⣠ ⡐ ⣐ ⡰ ⣰ ⡈ ⣈ ⡨ ⣨ ⡘ ⣘ ⡸ ⣸
⠄ ⢄ ⠤ ⢤ ⠔ ⢔ ⠴ ⢴ ⠌ ⢌ ⠬ ⢬ ⠜ ⢜ ⠼ ⢼
⡄ ⣄ ⡤ ⣤ ⡔ ⣔ ⡴ ⣴ ⡌ ⣌ ⡬ ⣬ ⡜ ⣜ ⡼ ⣼
⠂ ⢂ ⠢ ⢢ ⠒ ⢒ ⠲ ⢲ ⠊ ⢊ ⠪ ⢪ ⠚ ⢚ ⠺ ⢺
⡂ ⣂ ⡢ ⣢ ⡒ ⣒ ⡲ ⣲ ⡊ ⣊ ⡪ ⣪ ⡚ ⣚ ⡺ ⣺
⠆ ⢆ ⠦ ⢦ ⠖ ⢖ ⠶ ⢶ ⠎ ⢎ ⠮ ⢮ ⠞ ⢞ ⠾ ⢾
⡆ ⣆ ⡦ ⣦ ⡖ ⣖ ⡶ ⣶ ⡎ ⣎ ⡮ ⣮ ⡞ ⣞ ⡾ ⣾
⠁ ⢁ ⠡ ⢡ ⠑ ⢑ ⠱ ⢱ ⠉ ⢉ ⠩ ⢩ ⠙ ⢙ ⠹ ⢹
⡁ ⣁ ⡡ ⣡ ⡑ ⣑ ⡱ ⣱ ⡉ ⣉ ⡩ ⣩ ⡙ ⣙ ⡹ ⣹
⠅ ⢅ ⠥ ⢥ ⠕ ⢕ ⠵ ⢵ ⠍ ⢍ ⠭ ⢭ ⠝ ⢝ ⠽ ⢽
⡅ ⣅ ⡥ ⣥ ⡕ ⣕ ⡵ ⣵ ⡍ ⣍ ⡭ ⣭ ⡝ ⣝ ⡽ ⣽
⠃ ⢃ ⠣ ⢣ ⠓ ⢓ ⠳ ⢳ ⠋ ⢋ ⠫ ⢫ ⠛ ⢛ ⠻ ⢻
⡃ ⣃ ⡣ ⣣ ⡓ ⣓ ⡳ ⣳ ⡋ ⣋ ⡫ ⣫ ⡛ ⣛ ⡻ ⣻
⠇ ⢇ ⠧ ⢧ ⠗ ⢗ ⠷ ⢷ ⠏ ⢏ ⠯ ⢯ ⠟ ⢟ ⠿ ⢿
⡇ ⣇ ⡧ ⣧ ⡗ ⣗ ⡷ ⣷ ⡏ ⣏ ⡯ ⣯ ⡟ ⣟ ⡿ ⣿]]):gsub('\n',' ')function GenerateDotData()function ToBinary(ld)local md={}while ld>0 do local od=math.fmod(ld,2)md[#md+1]=string.sub(od,1,1)ld=(ld-od)/2 end;local nd=string.reverse(table.concat(md))return string.rep('0',8 -#nd)..nd end;local function fd(ld)return ld end;local gd=Split(Ib,' ')local hd={}local id=false;local jd=''local kd=' 'for i=1,#gd do hd[ToBinary(i-1)]=fd(gd[i])if id then print(ToBinary(i-1)..gd[i])local ld=io.read()if ld==''then ld=gd[i]elseif ld=='stop'then break end;jd=jd..ld..kd end end;if id then print(jd)io.open('Data.lua','a+'):write(jd)end;return hd end;local Jb=GenerateDotData()Pixel={}Pixel.Data={Box={['1000']='▘',['0100']='▝',['0010']='▖',['0001']='▗',['1100']='▀',['1001']='▚',['0110']='▞',['0110']='▐',['1010']='▌',['0011']='▄',['1110']='▛',['0111']='▟',['1101']='▜',['1011']='▙',['1111']='█'}}Pixel.Data.Dot=Jb;Pixel.Data.Empty='0'Pixel.Data.Filled='1'Pixel.Data.NewLine='\n'Split=function(fd,gd)c={}for hd,id in fd:gmatch("([^"..gd.."]*)("..gd.."?)")do table.insert(c,hd)if id==''then return c end end end;function Round(fd,gd)local hd=10 ^ (gd or 0)return math.floor(fd*hd+0.5)/hd end;function GetPixelData(fd)if type(fd)=='table'and fd.Data then return fd else local gd=Pixel.New(fd)return gd end end;function Error(fd,gd)if not ErrorEnabled then return end;local function hd(kd,ld)return(kd:gsub('(%b{})',function(md)return ld[md:sub(2,-2)]or md end))end;local function id(kd)error(kd)end;local jd=hd(fd,gd)id(jd)end;function Warn(fd,gd)if not WarnEnabled then return end;local function hd(jd,kd)return(jd:gsub('(%b{})',function(ld)return kd[ld:sub(2,-2)]or ld end))end;local id=hd(fd,gd)print('Warning: '..id)if WarnStrict then print('Press enter to continue.')io.read()end end;Table={}function Table.Combine(fd,gd)for i=1,#gd do table.insert(fd,gd[i])end;return fd end;function Table.Clone(fd,gd)gd=gd or{}local hd=type(fd)local id;if hd=='table'then if gd[fd]then id=gd[fd]else id={}gd[fd]=id;for jd,kd in next,fd,nil do id[Table.Clone(jd,gd)]=Table.Clone(kd,gd)end;setmetatable(id,Table.Clone(getmetatable(fd),gd))end else id=fd end;return id end;Pixel.Color={}Pixel.Color.Data={reset=0,clear=0,space=0,bright=1,bold=1,dim=2,faint=1,italic=3,underline=4,blink=5,reverse=7,invisible=8,hidden=8,strikethrough=9,black=30,red=31,green=32,yellow=33,blue=34,purple=35,magenta=35,cyan=36,white=37,onblack=40,onred=41,ongreen=42,onyellow=43,onblue=44,onpurple=45,onmagenta=45,oncyan=46,onwhite=47}local function Kb(fd)local gd=Split(fd,',')local hd={}for i=1,#gd do local id=string.gsub(gd[i],'^%s*(.-)%s*$','%1')table.insert(hd,Pixel.Color.Data[string.lower(id)]or id)end;fd=table.concat(hd,';')return'\27['..fd..'m'end;local function Lb(fd,gd)local hd=fd;local id=true;local jd;fd=string.gsub(fd,'(%b{})',function(kd)kd=string.sub(kd,2,-2)if id then id=false;local ld=Kb(kd)jd=ld;return ld else id=true;local ld=Lb(kd,jd)if ld then return ld.. (gd or'')else return kd.. (gd or'')end end end)if id==false or finalstr==''or fd==hd then return nil end;return fd end;function Pixel.Color.Set(fd)local gd=Lb(fd)if gd then return gd..Kb('0')else local hd=Kb(fd)local id=false;local jd=''local kd;kd=setmetatable({},{__concat=function(ld,md)hd=tostring(ld)..tostring(md)..Kb('0')return kd end,__call=function(ld,md)jd=Kb('0')if id then hd=hd..Kb(md)id=false else hd=hd..md;id=true end;return ld end,__tostring=function()return hd..jd end})return kd end end;setmetatable(Pixel.Color,{__call=function(fd,...)return Pixel.Color.Set(...)end})function Pixel.SetColor(fd,gd,hd,id)local jd=GetPixelData(fd)jd.Color[gd]=jd.Color[gd]or{}jd.Color[gd][hd]=id;return jd end;function Pixel.SetColorAll(fd,gd)local hd=GetPixelData(fd)hd.Color.All=gd;return hd end;function Pixel.GetColor(fd,gd,hd)local id=GetPixelData(fd)if id.Color[gd]and id.Color[gd][hd]then return id.Color[gd][hd]end;if WarnStrict then Warn('Unable to find color, x: {x}, y: {y}.',{x=gd,y=hd})end;return nil end;function Pixel.GetColorAll(fd)local gd=GetPixelData(fd)if gd.Color.All then return gd.Color.All else if WarnStrict then Warn('str.Color.All is a nil value.')end;return nil end end;Pixel.__index=Pixel;Pixel.__tostring=function(fd)return Pixel.Convert(fd)end;local function Mb()return Table.Clone(DefaultPixel)end;function Pixel.New(fd)if type(fd)=='string'then fd=Pixel.Convert.To2d(fd)end;local gd={}gd.Data=fd or Mb()gd.Op={}gd.Color={}setmetatable(gd,Pixel)return gd end;function Pixel.Blank()return Pixel.New()end;function Pixel.Clear(fd)return Pixel.New()end;function Pixel.Copy(fd)return Table.Clone(fd)end;Pixel.Convert={}function Pixel.Convert.To2d(fd,gd,hd)local id,jd=gd or 1,hd or 1;local kd,ld=id,jd;local md={}for i=1,#fd do local nd=string.sub(fd,i,i)if nd=='\n'then ld=ld+1;kd=id else md[kd]=md[kd]or{}md[kd][ld]=nd;kd=kd+1 end end;return md end;function Pixel.Convert.From2d(fd)local gd=GetPixelData(fd)local hd=gd.Data;local function id(qd)local rd=nil;for sd,td in pairs(qd)do if not rd or sd<rd then rd=sd end end;return rd end;local function jd(qd)local rd=nil;for sd,td in pairs(qd)do if not rd or sd>rd then rd=sd end end;return rd end;local function kd(qd,rd)local sd={}for td,ud in pairs(qd)do local vd=rd(ud)if vd then sd[vd]=true end end;return rd(sd)end;local ld={}local md,nd,od,pd=id(hd),jd(hd),kd(hd,id),kd(hd,jd)for y=od,pd do for x=md,nd do table.insert(ld,Pixel.GetPixel(gd,x,y))end;local qd=#ld;repeat if ld[qd]==Pixel.Data.Filled then break else ld[qd]=nil;qd=qd-1 end until false;table.insert(ld,'\n')end;ld[#ld]=nil;return table.concat(ld),md,od end;if CacheEnabled then Pixel.Cache={}end;local function Nb(fd,gd,hd)local id=type(fd)local jd=type(gd)if id~=jd then return false end;if id~='table'and jd~='table'then return fd==gd end;local kd=getmetatable(fd)if not hd and kd and kd.__eq then return fd==gd end;for ld,md in pairs(fd)do local nd=gd[ld]if nd==nil or not Nb(md,nd)then return false end end;for ld,md in pairs(gd)do local nd=fd[ld]if nd==nil or not Nb(nd,md)then return false end end;return true end;local function Ob(fd)for i=1,#Pixel.Cache do if Nb(Pixel.Cache[i][1],fd)then return Pixel.Cache[i][2]end end;return nil end;local function Pb(fd,gd)table.insert(Pixel.Cache,{fd,gd})end;function Pixel.Convert.ToDots(fd)fd=GetPixelData(fd)local gd,hd=fd.Data,fd.Color;if ReverseY then local function vd(wd)local xd={}for yd,zd in pairs(wd)do for Ad,Bd in pairs(zd)do xd[yd]=xd[yd]or{}xd[yd][-Ad]=Bd end end;return xd end;gd=vd(gd)hd=vd(hd)end;fd={Data=gd,Color=hd}local function id(vd)local wd=nil;for xd,yd in pairs(vd)do if not wd or xd<wd then wd=xd end end;return wd end;local function jd(vd)local wd=nil;for xd,yd in pairs(vd)do if not wd or xd>wd then wd=xd end end;return wd end;local function kd(vd,wd)local xd={}for yd,zd in pairs(vd)do local Ad=wd(zd)if Ad then xd[Ad]=true end end;return wd(xd)end;local ld,md,nd,od=id(gd),jd(gd),kd(gd,id),kd(gd,jd)local pd={}local qd=string.rep('0',8)local rd=Pixel.Data.Dot[qd]local sd=nil;local td=nil;if fd.Color.All then local vd=tostring(Pixel.Color(fd.Color.All))table.insert(pd,vd)td=vd end;local ud={}for vd,wd in pairs(gd)do for xd,yd in pairs(wd)do ud[xd]=ud[xd]or{}ud[xd][vd]=yd end end;if not nd then return''end;for y=nd,od,4 do for x=ld,md,2 do local vd=''local wd={{0,0},{0,1},{0,2},{0,3},{1,0},{1,1},{1,2},{1,3}}for i=1,8 do local xd,yd=x+wd[i][1],y+wd[i][2]vd=vd.. ( (gd[xd]and gd[xd][yd]or false)and gd[xd][yd]or Pixel.Data.Empty)end;if vd~=qd then vd=Pixel.Data.Dot[vd]if not td then local xd=Pixel.GetColor(fd,x,y)if not xd then local yd={{0,0},{0,1},{0,2},{0,3},{1,0},{1,1},{1,2},{1,3}}for i=1,8 do xd=Pixel.GetColor(fd,x+yd[i][1],y+yd[i][2])if xd then break end end end;if xd then xd=tostring(Pixel.Color(xd))else xd=tostring(Pixel.Color('reset'))end;if sd==xd then else table.insert(pd,xd)sd=xd end end;table.insert(pd,vd)else table.insert(pd,rd)end end;table.insert(pd,Pixel.Data.NewLine)end;table.insert(pd,tostring(Pixel.Color('reset')))return table.concat(pd)end;function Pixel.Convert.FromDots(fd)if''then return nil end;local function gd(id)for jd,kd in pairs(Pixel.Data.Dot)do if kd==id then return jd end end end;local hd=Pixel.Convert.To2d(fd)for x=1,#hd do for y=1,#hd[x]do print(hd[x][y])end end end;setmetatable(Pixel.Convert,{__call=function(fd,...)return Pixel.Convert.ToDots(...)end})for fd,gd in pairs(Pixel.Convert)do Pixel[fd]=gd end;function Pixel.Format(fd,gd)local function hd()for i=1,#fd do local jd=string.sub(fd,i,i)if jd==Pixel.Data.Empty or jd==Pixel.Data.Filled or jd==Pixel.Data.NewLine then else return false end end;return true end;local id;if type(fd)=='string'then local jd=hd()if jd then id='str'else id='dots'end elseif type(fd)=='table'then id='2d'end;if id=='str'then elseif id=='2d'then fd=Pixel.Convert.From2d(fd)elseif id=='dots'then fd=Pixel.Convert.FromDots(fd)else Error('Pixel.Format: Could not convert {from} to {to}.',{from=id,to='STR'})end;if gd=='str'then return fd elseif gd=='2d'then return Pixel.Convert.To2d(fd)elseif gd=='dots'then return Pixel.Convert.ToDots(str)else Error('Pixel.Format: Could not convert {from} to {to}.',{from='STR',to=gd})end end;local function Qb(fd)local gd=nil;for hd,id in pairs(fd)do if not gd or hd>gd then gd=hd end end;return gd end;function Pixel.GetSizeX(fd)local gd=GetPixelData(fd)return Qb(gd.Data)end;function Pixel.GetSizeY(fd)local gd=GetPixelData(fd)local hd=nil;for id,jd in pairs(gd.Data)do local kd=Qb(jd)if(not hd or kd>hd)and kd then hd=kd end end;return hd end;function Pixel.SetPixel(fd,gd,hd,id)local jd=GetPixelData(fd)jd.Data[gd]=jd.Data[gd]or{}jd.Data[gd][hd]=id;return jd end;function Pixel.GetPixel(fd,gd,hd)local id=GetPixelData(fd)return id.Data[gd]and id.Data[gd][hd]or nil end;function Pixel.SetPixels(fd,gd)local hd=GetPixelData(fd)for i=1,#gd do hd.Data=Pixel.SetPixel(hd.Data,gd[i][1],gd[i][2],gd[i][3])end;return hd end;function Pixel.Equal(fd,gd,hd,id,jd)local kd=GetPixelData(fd)return Pixel.GetPixel(gd,hd)==Pixel.GetPixel(id,jd)end;function Pixel.MovePixel(fd,gd,hd,id,jd)local kd=GetPixelData(fd)return Pixel.SetPixel(Pixel.SetPixel(kd,id,jd,Pixel.GetPixel(gd,hd)),gd,hd,Pixel.Data.Empty)end;function Pixel.SwapPixel(fd,gd,hd,id,jd)local kd=GetPixelData(fd)local ld=Pixel.GetPixel(kd,gd,hd)return Pixel.SetPixel(Pixel.SetPixel(kd,gd,hd,Pixel.GetPixel(kd,id,jd)),id,jd,ld)end;function Pixel.Replace(fd,gd,hd)local id=GetPixelData(fd)for jd,kd in pairs(id.Data)do for ld,md in pairs(kd)do if md==gd and id.Data[jd]then id=Pixel.SetPixel(id,jd,ld,hd)end end end;return id end;function Pixel.SetAll(fd,gd)local hd=GetPixelData(fd)return Pixel.Replace(hd,Pixel.Data.Empty,gd)end;function Pixel.Flip(fd)local gd=GetPixelData(fd)return Pixel.Replace(Pixel.Replace(Pixel.Replace(gd,'0, 2'),'1','0'),'2','1')end;function Pixel.GetRect(fd,gd,hd,id,jd,kd,ld)local md=GetPixelData(fd)local nd=Pixel.New()if id>jd then id,jd=jd,id end;if jd>ld then jd,ld=ld,jd end;for x=id,kd do for y=jd,ld do nd=Pixel.SetPixel(nd,x-id+gd,y-jd+hd,Pixel.GetPixel(md,x,y))end end;return nd end;function Pixel.ZoomIn(fd,gd)local hd=GetPixelData(fd)local id=Pixel.New()for jd,kd in pairs(hd.Data)do for ld,md in pairs(kd)do for x2=(jd-1)*gd+1,jd*gd do for y2=(ld-1)*gd+1,ld*gd do id=Pixel.SetPixel(id,x2,y2,md)end end end end;return id end;function Pixel.ZoomOut(fd,gd)local hd=GetPixelData(fd)local id=Pixel.New()for jd,kd in pairs(hd.Data)do for ld,md in pairs(kd)do if(jd-1)%gd==0 and(ld-1)%gd==0 then local nd={}for x2=jd,jd+gd-1 do for y2=ld,ld+gd-1 do local pd=Pixel.GetPixel(hd,x2,y2)if pd then nd[pd]=nd[pd]and nd[pd]+1 or 1 end end end;local od=nil;for pd,qd in pairs(nd)do if not od or qd>nd[od]then od=pd elseif od and qd==nd[od]then pd=Pixel.Data.Empty;break end end;id=Pixel.SetPixel(id,(jd-1)/gd+1,(ld-1)/gd+1,od)end end end;return id end;function Pixel.Resize(fd,gd,hd)end;function Pixel.Offset(fd,gd,hd)end;local function Rb(...)local fd={...}if#fd==1 and type(fd[1])=='table'then return unpack(fd[1])else return...end end;local function Sb(fd,gd,...)local hd={...}if hd[#hd]~=true then table.insert(fd.Op,{gd,...})end end;local function Tb(fd,gd)if type(fd)=='boolean'and type(gd)=='table'then return gd,fd elseif type(fd)=='table'and type(gd)=='boolean'then return fd,gd elseif type(fd)=='table'then return fd,gd end end;function Pixel.Line(fd,...)local gd={Rb(...)}local hd,id,jd,kd,ld,md=unpack(gd)local nd,od=Tb(ld,md)nd=nd or{}local pd,qd,rd,sd=nd.color,nd.callback,nd.init,nd.setfunction;if rd then rd()end;local td=GetPixelData(fd)local ud,vd=0,0;if hd<0 and hd<ud then ud=hd end;if jd<0 and jd<ud then ud=jd end;if id<0 and id<vd then vd=id end;if kd<0 and kd<vd then vd=kd end;hd,id,jd,kd=hd-ud,id-vd,jd-ud,kd-vd;Sb(td,'Line',hd,id,jd,kd,nd,od)local function wd(Cd,Dd)local Ed,Fd=Cd+ud,Dd+vd;if qd then local Gd=qd(td,Ed,Fd,Pixel.Data.Filled)if Gd then Pixel.SetPixel(td,Ed,Fd,Gd)end else Pixel.SetPixel(td,Ed,Fd,Pixel.Data.Filled)end;if pd then Pixel.SetColor(td,Ed,Fd,pd)end end;if nd.setfunction then wd=nd.setfunction end;local xd,yd=math.abs(jd-hd),hd<jd and 1 or-1;local zd,Ad=math.abs(kd-id),id<kd and 1 or-1;local Bd=math.floor((xd>zd and xd or-zd)/2)while(true)do wd(hd,id)if(hd==jd and id==kd)then break end;if(Bd>-xd)then Bd,hd=Bd-zd,hd+yd;if(hd==jd and id==kd)then wd(hd,id)break end end;if(Bd<zd)then Bd,id=Bd+xd,id+Ad end end;return td end;function Pixel.Bezier2(fd,gd,hd,id,jd,kd,ld,md)local nd=GetPixelData(fd)md=md or 10;local od,pd,qd,rd;for i=0,md do local sd=i/md;local td,ud,vd=(1 -sd)^2,2 *sd* (1 -sd),sd^2;od,pd=qd,rd;qd=math.floor(td*gd+ud*id+vd*kd+0.5)rd=math.floor(td*hd+ud*jd+vd*ld+0.5)if i>0 then Pixel.Line(nd,od,pd,qd,rd)end end;return nd end;function Pixel.Bezier3(fd,gd,hd,id,jd,kd,ld,md,nd,od)local pd=GetPixelData(fd)od=od or 10;local qd,rd,sd,td;for i=0,od do local ud=i/od;local vd,wd,xd,yd=(1 -ud)^3,3 *ud* (1 -ud)^2,3 *ud^2 * (1 -ud),ud^3;qd,rd=sd,td;sd=math.floor(vd*gd+wd*id+xd*kd+yd*md+0.5)td=math.floor(vd*hd+wd*jd+xd*ld+yd*nd+0.5)if i>0 then Pixel.Line(pd,qd,rd,sd,td)end end;return pd end;function Pixel.Fill(fd,gd,hd,id,jd)local kd,ld=Tb(id,jd)local md=GetPixelData(fd)Sb(md,'Fill',gd,hd,kd,ld)local function nd(od,pd)if Pixel.GetPixel(md,od,pd)==Pixel.Data.Filled then return else Pixel.SetPixel(md,od,pd,Pixel.Data.Filled)nd(od-1,pd)nd(od+1,pd)nd(od,pd-1)nd(od,pd+1)end end;nd(gd,hd)return md end;local function Ub(fd,gd,hd,id,jd,kd,ld,md)local nd=(kd-gd)/ (ld-hd)local od=(kd-id)/ (ld-jd)local pd=kd;local qd=kd;local rd=ld;repeat fd=Pixel.Line(fd,Round(pd),rd,Round(qd),rd,md)pd,qd=pd-nd,qd-od;rd=rd-1 until rd<hd;return fd end;local function Vb(fd,gd,hd,id,jd,kd,ld,md)local nd=(id-gd)/ (jd-hd)local od=(kd-gd)/ (ld-hd)local pd=gd;local qd=gd;local rd=hd;repeat fd=Pixel.Line(fd,Round(pd),rd,Round(qd),rd,md)pd,qd=pd+nd,qd+od;rd=rd+1 until rd>jd;return fd end;function Pixel.Tri(fd,gd,hd,id,jd,kd,ld,md)local nd=GetPixelData(fd)local od,pd={},{}local qd=true;local rd=nil;local sd=nil;local td=nil;md=md or{}local function ud(xd,yd)if xd~=nil then return xd else return yd end end;qd=ud(md.fill,qd)rd=ud(md.color,rd)sd=ud(md.fillcolor,sd)td=ud(md.callback,td)local vd,wd={color=rd,callback=td},{color=sd,callback=td}if qd then local xd=function(Ad,Bd)local Cd={}for Ed in pairs(Ad)do Cd[#Cd+1]=Ed end;if Bd then table.sort(Cd,function(Ed,Fd)return Bd(Ad,Ed,Fd)end)else table.sort(Cd)end;local Dd=0;return function()Dd=Dd+1;if Cd[Dd]then return Cd[Dd],Ad[Cd[Dd]]end end end;local yd={{gd,hd},{id,jd},{kd,ld}}local zd={}for Ad,Bd in xd(yd,function(Ad,Bd,Cd)return Ad[Bd][2]<Ad[Cd][2]end)do table.insert(zd,Bd[1])table.insert(zd,Bd[2])end;yd=zd;gd,hd,id,jd,kd,ld=yd[1],yd[2],yd[3],yd[4],yd[5],yd[6]if jd==ld then nd=Vb(nd,gd,hd,id,jd,kd,ld,wd)elseif hd==jd then nd=Ub(nd,gd,hd,id,jd,kd,ld,wd)else local Ad,Bd=Round(gd+ (jd-hd)/ (ld-hd)* (kd-gd)),jd;nd=Vb(nd,gd,hd,id,jd,Ad,Bd,wd)nd=Ub(nd,id,jd,Ad,Bd,kd,ld,wd)end end;nd=Pixel.Line(nd,gd,hd,id,jd,vd)nd=Pixel.Line(nd,id,jd,kd,ld,vd)nd=Pixel.Line(nd,kd,ld,gd,hd,vd)return nd end;function Pixel.PolygonFill(fd,...)local gd={...}local hd;if#gd%2 ==1 then hd=gd[#gd]table.remove(gd,#gd)end;local function id(od)local pd=#od;local qd=0;p=pd-1;for q=1,pd,2 do qd=qd+od[p]*od[q+1]-od[q]*od[p+1]p=q end;return qd*0.5 end;local function jd(od,pd,qd,rd,sd,td,ud,vd)local wd,xd,yd,zd,Ad,Bd,Cd,Dd,Ed,Fd,Gd,Hd;local Id,Jd,Kd;wd=sd-qd;xd=td-rd;yd=od-sd;zd=pd-td;Ad=qd-od;Bd=rd-pd;Cd=ud-od;Dd=vd-pd;Ed=ud-qd;Fd=vd-rd;Gd=ud-sd;Hd=vd-td;Kd=wd*Fd-xd*Ed;Id=Ad*Dd-Bd*Cd;Jd=yd*Hd-zd*Gd;return(Kd>=0.0)and(Jd>=0.0)and(Id>=0.0)end;local kd=0.000001;local function ld(od,pd,qd,rd,sd,td)local ud,vd,wd,xd,yd,zd,Ad,Bd;ud=od[td[pd]]vd=od[td[pd]+1]wd=od[td[qd]]xd=od[td[qd]+1]yd=od[td[rd]]zd=od[td[rd]+1]if(kd> ( ( (wd-ud)* (zd-vd))- ( (xd-vd)* (yd-ud))))then return false end;for p=1,sd do if(p==pd)or(p==qd)or(p==rd)then else Ad=od[td[p]]Bd=od[td[p]+1]if(jd(ud,vd,wd,xd,yd,zd,Ad,Bd))then return false end end end;return true end;local function md(od)local pd={}if#od<6 then return nil elseif#od==6 then return{od}end;local qd=#od/2;local rd={}if id(od)>=0 then for i=1,qd do rd[i]=i*2 -1 end else for i=1,qd do rd[i]=#od-i*2 +1 end end;local sd=qd*2;local td=qd;while qd>2 do sd=sd-1;if sd<0 then return nil end;local wd=td;if wd>qd then wd=1 end;td=wd+1;if td>qd then td=1 end;local xd=td+1;if xd>qd then xd=1 end;if ld(od,wd,td,xd,qd,rd)then local yd=rd[wd]local zd=rd[td]local Ad=rd[xd]table.insert(pd,od[yd])table.insert(pd,od[yd+1])table.insert(pd,od[zd])table.insert(pd,od[zd+1])table.insert(pd,od[Ad])table.insert(pd,od[Ad+1])table.remove(rd,td)qd=qd-1;sd=qd*2 end end;local ud={}local vd=6;for i=1,#pd,vd do local wd={}for i2=1,vd do table.insert(wd,pd[i+i2 -1])end;table.insert(ud,wd)end;pd=ud;return pd end;local nd=md(gd)if hd then for i=1,#nd do Pixel.Tri(fd,unpack(Table.Combine(nd[i],{hd})))end else for i=1,#nd do Pixel.Tri(fd,unpack(nd[i]))end end;return fd end;function Pixel.Polygon(fd,...)local gd=GetPixelData(fd)local hd=true;local id=nil;local jd=nil;local kd={Rb(...)}if#kd%2 ==1 and type(kd)=='table'then local ld=kd[#kd]local function md(nd,od)if nd~=nil then return nd else return od end end;hd=md(ld.fill,hd)id=md(ld.color,id)jd=md(ld.fillcolor,jd)end;if hd then gd=Pixel.PolygonFill(gd,unpack(kd))else table.remove(kd,#kd)local ld={color=id}for i=1,#kd-2,2 do gd=Pixel.Line(gd,kd[i],kd[i+1],kd[i+2],kd[i+3],true,ld)end;gd=Pixel.Line(gd,kd[#kd-1],kd[#kd],kd[1],kd[2],true,ld)end;Sb(gd,'Polygon',...)return gd end;function Pixel.Ellipse(fd,gd,hd,id,jd,kd)local ld=GetPixelData(fd)local md=Pixel.Data.Filled;local function nd(pd,qd)return pd^2 *jd^2 +qd^2 *id^2 <=id^2 *jd^2 end;local od=id;for y=0,jd do local pd=false;repeat pd=nd(od,y)od=od-1 until pd;od=od+1;for x2=0,od do Pixel.SetPixel(ld,gd+x2,hd+y,md,kd)Pixel.SetPixel(ld,gd-x2,hd+y,md,kd)Pixel.SetPixel(ld,gd+x2,hd-y,md,kd)Pixel.SetPixel(ld,gd-x2,hd-y,md,kd)end end;return ld end;function Pixel.Circle(fd,gd,hd,id,jd)return Pixel.Ellipse(fd,gd,hd,id,id,jd)end;function Pixel.Graph(fd,gd,hd,id,jd)local kd=jd or true;local ld=hd or 1;local md=GetPixelData(fd)local nd=id or Pixel.GetSizeX(md)local od=md.Data;if kd then for i=ld,nd do local pd=Round(gd(i))od=Pixel.Line(md,i,pd,i,pd)end else for i=ld,nd do local pd=gd(i)od=Pixel.Line(md,i,pd,i,pd)end end;return od end;function Pixel.Area(fd)local gd=GetPixelData(fd)local hd=0;for id,jd in pairs(gd.Data)do for kd,ld in pairs(jd)do if Pixel.GetPixel(id,kd)==Pixel.Data.Filled then hd=hd+1 end end end;return hd end;function Pixel.GetOutline(fd)local gd=GetPixelData(fd)local hd=Pixel.New()local id={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}}for jd,kd in pairs(gd.Data)do for ld,md in pairs(kd)do local nd=false;for i=1,#id do if Pixel.GetPixel(gd,jd+id[i][1],ld+id[i][2])~=Pixel.Data.Filled then nd=true end end;if nd then hd=Pixel.SetPixel(hd,jd,ld,Pixel.Data.Filled)end end end;return hd end;PixelMaze={}function PixelMaze.BT(fd,gd)local hd={}local id,jd=fd%2 +fd+1,gd%2 +gd+1;local kd=Pixel.Polygon(Pixel.New(),1,1,id,1,id,jd,1,jd,{fill=true})for y=2,jd,2 do for x=2,id,2 do kd=Pixel.SetPixel(kd,x,y,Pixel.Data.Empty)local ld={}if x>2 then table.insert(ld,{x-1,y})end;if y>2 then table.insert(ld,{x,y-1})end;if#ld~=0 then local md=ld[math.random(1,#ld)]kd=Pixel.SetPixel(kd,md[1],md[2],Pixel.Data.Empty)end end end;return kd end;function PixelMaze.DFS(fd,gd)local hd={}local id,jd=fd%2 +fd+1,gd%2 +gd+1;local kd=Pixel.Polygon(Pixel.New(),1,1,id,1,id,jd,1,jd,{fill=true})local function ld(sd,td)return math.random(1,sd),math.random(1,td)end;local function md(sd,td,ud,vd,wd)local xd={}local function yd(Ad,Bd)if Ad>vd or Bd>wd or Ad<1 or Bd<1 then return else table.insert(xd,{Ad,Bd})end end;local zd=2;yd(td-zd,ud)yd(td+zd,ud)yd(td,ud-zd)yd(td,ud+zd)if#xd>0 then return xd else return nil end end;local function nd(sd)for i=1,#sd-1 do local td=math.random(i,#sd)sd[i],sd[td]=sd[td],sd[i]end;return sd end;local function od(sd)hd[sd]=hd[sd]or{}end;local function pd(sd,td)Pixel.SetPixel(kd,sd,td,Pixel.Data.Empty)od(sd)hd[sd][td]=true;local ud=md(hd,sd,td,id,jd)if ud then ud=nd(ud)for i=1,#ud do local vd,wd=ud[i][1],ud[i][2]if hd[vd]and hd[vd][wd]then elseif vd>0 and wd>0 and vd<=id and wd<=jd then kd=Pixel.SetPixel(kd,(vd-sd)/2 +sd,(wd-td)/2 +td,Pixel.Data.Empty)pd(vd,wd)end end else return end end;local qd,rd=ld(id,jd)qd,rd=qd%2 +qd,rd%2 +rd;pd(qd,rd)return kd end;function PixelMaze.Solve(fd,gd,hd,id,jd)local kd={['l']={-1,0,'r'},['r']={1,0,'l'},['u']={0,-1,'d'},['d']={0,1,'u'}}local ld={}local function md(pd,qd,rd,sd)rd=rd or{}sd=sd or{}ld[pd]=ld[pd]or{}ld[pd][qd]=true;if pd==id and qd==jd then return rd,sd end;local td=false;for ud,vd in pairs(kd)do local wd,xd=pd+vd[1],qd+vd[2]if ld[wd]==nil or ld[wd][xd]==nil then td=true;if Pixel.GetPixel(fd,wd,xd)==Pixel.Data.Empty then table.insert(rd,ud)table.insert(sd,{wd,xd})local yd=#rd;local zd,Ad=md(wd,xd,rd,sd)if zd then return zd,Ad else local Bd={}for i=1,yd-1 do table.insert(Bd,rd[i])end;rd=Bd;local Cd={}for i=1,yd-1 do table.insert(Cd,sd[i])end;sd=Cd end end end end;if td==false then return nil end end;local nd,od=md(gd,hd,{})return nd,od end;function PixelMaze.SolveShort(fd,gd,hd,id,jd)local kd=true;local ld=Pixel.GetSizeX(fd)local md=Pixel.GetSizeY(fd)local function nd(xd,yd,zd,Ad)return(zd-xd)^2 + (Ad-yd)^2 end;local function od(xd,yd)return nd(xd,yd,gd,hd)end;local function pd(xd,yd)return nd(xd,yd,id,jd)end;local function qd(xd,yd)return xd+yd end;local function rd(xd)local yd=xd;local zd={}local Ad={}repeat if yd then table.insert(zd,{yd.x,yd.y})table.insert(Ad,yd.d)else break end;yd=yd.p until false;local Bd={}local Cd={}for i=#zd,1,-1 do table.insert(Bd,zd[i])table.insert(Cd,Ad[i])end;return Cd,Bd end;local sd={{-1,-1,'lu'},{0,-1,'u'},{1,-1,'ru'},{-1,0,'l'},{1,0,'r'},{-1,1,'ld'},{0,1,'d'},{1,1,'rd'}}local td={{0,-1,'u'},{-1,0,'l'},{1,0,'r'},{0,1,'d'}}local ud={}local vd={}table.insert(ud,{x=gd,y=hd,g=0,h=0,f=0})local wd;while#ud~=0 do wd=nil;for i=1,#ud do if not wd or ud[i].f<wd.f then wd=ud[i]end end;if not kd and wd.x==id and wd.y==jd then return rd(wd)end;table.insert(vd,wd)for i=1,#ud do if ud[i].x==wd.x and ud[i].y==wd.y then table.remove(ud,i)break end end;for i=1,#td do local xd,yd,zd=wd.x+td[i][1],wd.y+td[i][2],td[i][3]if xd>0 and xd<=ld and yd>1 and xd<=md then if Pixel.GetPixel(fd,xd,yd)==Pixel.Data.Empty then local Ad=false;for i2=1,#vd do local Bd=vd[i2]if Bd.x==xd and Bd.y==yd then Ad=true;break end end;if Ad==false then local Bd=false;for i2=1,#vd do local Cd=vd[i2]if Cd.x==xd and Cd.y==yd then Bd=true;break end end;if Bd==false then local Cd={x=xd,y=yd,g=od(xd,yd),h=pd(xd,yd),p=wd,d=zd}Cd.f=qd(Cd.g,Cd.h)table.insert(ud,Cd)else end end end end end end;if kd then return rd(wd)else return nil end end;function PixelMaze.Mark(fd,gd,hd,id,jd)local kd={['l']={-1,0,'r'},['r']={1,0,'l'},['u']={0,-1,'d'},['d']={0,1,'u'}}local ld,md=gd,hd;for i=1,#id do fd=Pixel.SetPixel(fd,ld,md,jd)local nd=kd[id[i]]ld,md=nd[1]+ld,nd[2]+md end;return fd end;function PixelMaze.Color(fd,gd,hd,id,jd)local kd={['l']={-1,0,'r'},['r']={1,0,'l'},['u']={0,-1,'d'},['d']={0,1,'u'}}local ld,md=gd,hd;for i=1,#id do fd=Pixel.SetColor(fd,ld,md,jd)local nd=kd[id[i]]ld,md=nd[1]+ld,nd[2]+md end;return fd end;Pixel3d={}local function Wb(fd,gd,hd,id,jd,kd,ld,md,nd)ld,md=md,ld;ld,md=-ld,-md;ld,md=math.rad(ld),math.rad(md)local od,pd,qd,rd=math.sin(ld),math.cos(ld),math.sin(md),math.cos(md)fd,gd,hd=fd-id,gd-jd,hd-kd;fd,gd,hd=(hd*qd)+ (fd*rd),gd,(hd*rd)- (fd*qd)fd,gd,hd=fd,(gd*pd)- (hd*od),(gd*od)+ (hd*pd)rx,ry=nd* (fd/hd),nd* (gd/hd)rx,ry=Round(rx),Round(ry)return rx,ry end;local function Xb(fd,gd,hd)end;local function Yb(fd,gd,...)fd,gd=fd/2,gd/2;local hd={}local id={...}for i=1,#id,2 do table.insert(hd,{id[i],id[i+1]})end;local jd={{-fd,-gd},{fd,-gd},{fd,gd},{-fd,gd}}local function kd(od,pd,qd)return(qd.x-pd.x)* (od.y-pd.y)> (qd.y-pd.y)* (od.x-pd.x)end;local function ld(od,pd,qd,rd)local sd,td=od.x-pd.x,od.y-pd.y;local ud,vd=qd.x-rd.x,qd.y-rd.y;local wd=od.x*pd.y-od.y*pd.x;local xd=qd.x*rd.y-qd.y*rd.x;local yd=1 / (sd*vd-td*ud)local zd=(wd*ud-xd*sd)*yd;local Ad=(wd*vd-xd*td)*yd;return{x=zd,y=Ad}end;local function md(od,pd)local qd=od;local rd=pd[#pd]for sd,td in ipairs(pd)do local ud=qd;qd={}local vd=ud[#ud]for wd,xd in ipairs(ud)do if kd(xd,rd,td)then if not kd(vd,rd,td)then qd[#qd+1]=ld(rd,td,vd,xd)end;qd[#qd+1]=xd elseif kd(vd,rd,td)then qd[#qd+1]=ld(rd,td,vd,xd)end;vd=xd end;rd=td end;return qd end;local function nd()local function od(rd)for sd,td in ipairs(rd)do td.x,td.y=td[1],td[2]end end;od(hd)od(jd)local pd=md(hd,jd)local qd={}for i=1,#pd do local rd,sd=pd[i].x,pd[i].y;local td=false;for i2=1,#qd,2 do if i~=i2 and rd==qd[i2]and sd==qd[i2 +1]then td=true end end;if td==false then table.insert(qd,Round(rd))table.insert(qd,Round(sd))end end;return unpack(qd)end;return nd()end;local function Zb(fd,gd,hd)gd=(gd>180)and(gd-360)or gd;fd=(fd>180)and(fd-360)or fd;return(gd<fd)and(fd<hd)end;local function ac(fd)return fd- (math.floor(fd/360)*360)end;local function bc(fd,gd,hd,id,jd,kd)xn,yn,zn=x<0,y<0,z<0;x,y,z=id-fd,jd-gd,kd-hd;n=math.sqrt(x^2 +y^2 +z^2)x,y,z=x/n,y/n,z/n;if xn then x=x*-1 end;if yn then y=y*-1 end;if zn then z=z*-1 end;return fd,gd,hd,fd+x,gd+y,hd+z end;local function cc(fd)local gd={}local hd={}local id={}local jd={}local kd=0;local function ld(nd,od)table.insert(gd,{nd,od})end;ld('v',function(nd)local od={}for i=2,#nd do table.insert(od,tonumber(nd[i]))end;table.insert(hd,od)end)ld('f',function(nd)local od={}local pd={}for i=2,#nd do table.insert(od,hd[tonumber(nd[i])])table.insert(pd,tonumber(nd[i]))end;table.insert(id,od)table.insert(jd,pd)end)local md=Split(fd,'\n')for i=1,#md do local nd=Split(md[i],' ')for i2=1,#gd do if gd[i2][1]==nd[1]then kd=kd+1;gd[i2][2](nd)break end end end;return hd,id,jd end;function Pixel3d.New(fd)local gd={}setmetatable(gd,Pixel3d)if fd then for hd,id in pairs(fd)do gd[string.lower(hd)]=id end;return gd end end;function Pixel3d.Default()local fd=Pixel3d.New({x=0,y=0,z=0,size={x=0,y=0,z=0}})return fd end;function Pixel3d.Point()local fd=Pixel3d.New({x=0,y=0,z=0,type='Point',size={x=0,y=0,z=0}})return fd end;function Pixel3d.Box(fd,gd,hd)local id=Pixel3d.New({type='Box',x=0,y=0,z=0,size={x=0,y=0,z=0},fill=nil,color=nil,fillcolor=nil,colorall=nil})id.size.x,id.size.y,id.size.z=fd,gd,hd;return id end;function Pixel3d.Sphere(fd,gd,hd)local id=Pixel3d.New({x=0,y=0,z=0,radius=fd,type='Sphere'})return id end;local function dc(fd,gd,hd,id)local jd=id-gd;local kd=hd-fd;if kd==0 then if jd>0 then return 90 elseif jd<0 then return 270 else return 0 end end;local ld=math.atan2(jd,kd)ld=ld*180 /math.pi;return ld end;function Pixel3d.RenderObject(fd,gd,hd,id,jd,kd,ld,md)local nd=jd or 105;nd=180;nd=105;local od,pd,qd=gd or 0,hd or 0,id or 0;local rd,sd=kd or 0,ld or 0;local td=scale or 25;local ud,vd=200,200;ud,vd=100,100;rd=ac(rd)local wd=md or{fill=false,color='red'}local xd=Pixel.New()xd.Color.All=wd.colorall;local yd,zd,Ad=cc(fd)local Bd={}local Cd=2;local Dd=Pixel.New()local Ed,Fd=Round(od),Round(qd)Dd=Pixel.SetPixel(Dd,Ed*Cd,Fd*Cd,Pixel.Data.Filled)Dd=Pixel.SetColor(Dd,Ed*Cd,Fd*Cd,'red')print(rd,(ac(rd-nd/2)))local Gd,Hd,Id=Pixel3d.CalculateMovement(Ed*Cd,0,Fd*Cd,(ac(rd-nd/2)),0,10)local Jd,Kd,Ld=Pixel3d.CalculateMovement(Ed*Cd,0,Fd*Cd,(ac(rd+nd/2)),0,10)Dd=Pixel.Line(Dd,Ed*Cd,Fd*Cd,Round(Gd),Round(Id))Dd=Pixel.Line(Dd,Ed*Cd,Fd*Cd,Round(Jd),Round(Ld))local Md,Nd,Od=Pixel3d.CalculateMovement(Ed*Cd,0,Fd*Cd,(ac(rd)),0,20)Dd=Pixel.Line(Dd,Ed*Cd,Fd*Cd,Round(Md),Round(Od))for i=1,#yd do local Pd=yd[i]local Qd,Rd,Sd=Pd[1],Pd[2],Pd[3]local Td,Ud=Wb(Qd,Rd,Sd,od,pd,qd,rd,sd,td)local Vd=math.sqrt((od-Qd)^2 + (pd-Rd)^2 + (qd-Sd)^2)local Wd=ac(dc(od,qd,Qd,Sd)-90)Dd=Pixel.SetPixel(Dd,Qd*Cd,Sd*Cd,Pixel.Data.Filled)if Zb(Wd,ac(rd-nd/2),ac(rd+nd/2))then else Vd=-Vd end;table.insert(Bd,{Td,Ud,{Qd,Rd,Sd},Vd})end;print(Dd)for i=1,#Ad do local Pd={}local Qd=false;for i2=1,#Ad[i]do local Rd=Bd[Ad[i][i2]]local Sd,Td=Rd[1],Rd[2]local Ud=Rd[4]if Ud>0 then Qd=true end;table.insert(Pd,Sd)table.insert(Pd,Td)end;if Qd then Pd={Yb(ud,vd,unpack(Pd))}if#Pd>=6 then local Rd=true;for i=1,#Pd do local Sd=Pd[i]if Sd~=Sd or Sd==1 /0 then Rd=false end end;if Rd then table.insert(Pd,wd)Pixel.Polygon(xd,unpack(Pd))end end end end;return xd end;function Pixel3d.CalculateMovement(fd,gd,hd,id,jd,kd)id,jd=math.rad(id),jd;return fd+math.sin(id)*kd,gd+math.sin(jd),hd+math.cos(id)*kd end;function Pixel3d.Interactive(fd,gd,hd,id,jd,kd,ld,md)local nd=jd or 70;local od,pd,qd=gd or 0,hd or 0,id or 0;local rd,sd=kd or 0,ld or 0;local td=1;local ud=10;ud=45;print('Use wasd to move, and ijkl to move camera. Type stop to stop.')local vd={}local function wd(zd)if vd[zd]then vd[zd]()end end;local function xd(zd,Ad)vd[zd]=Ad end;local function yd(zd)od,pd,qd=Pixel3d.CalculateMovement(od,pd,qd,(rd+zd),(sd),td)end;xd('w',function()yd(0)end)xd('a',function()rd=rd-ud end)xd('s',function()yd(-180)end)xd('d',function()rd=rd+ud end)xd('c',function()yd(-90)end)xd('v',function()yd(90)end)xd('i',function()sd=sd+ud end)xd('j',function()rd=rd-ud end)xd('k',function()sd=sd-ud end)xd('l',function()rd=rd+ud end)xd('debug',function()print(od,pd,qd)print(rd,sd)end)xd('up',function()pd=pd+td end)xd('down',function()pd=pd-td end)repeat print(Pixel3d.RenderObject(fd,od,pd,qd,nd,rd,sd,md))local zd=string.lower(io.read())wd(zd)until input=='stop'end;GameOfLife={}function GameOfLife.NextGeneration(fd)local gd=GetPixelData(fd)local hd=Pixel.New()local function id(kd,ld)local md=0;md=Pixel.GetPixel(gd,kd-1,ld-1)==Pixel.Data.Filled and md+1 or md;md=Pixel.GetPixel(gd,kd,ld-1)==Pixel.Data.Filled and md+1 or md;md=Pixel.GetPixel(gd,kd+1,ld-1)==Pixel.Data.Filled and md+1 or md;md=Pixel.GetPixel(gd,kd-1,ld)==Pixel.Data.Filled and md+1 or md;md=Pixel.GetPixel(gd,kd+1,ld)==Pixel.Data.Filled and md+1 or md;md=Pixel.GetPixel(gd,kd-1,ld+1)==Pixel.Data.Filled and md+1 or md;md=Pixel.GetPixel(gd,kd,ld+1)==Pixel.Data.Filled and md+1 or md;md=Pixel.GetPixel(gd,kd+1,ld+1)==Pixel.Data.Filled and md+1 or md;local nd=Pixel.GetPixel(gd,kd,ld)if nd==Pixel.Data.Filled then if md==2 or md==3 then Pixel.SetPixel(hd,kd,ld,Pixel.Data.Filled)else end elseif md==3 then Pixel.SetPixel(hd,kd,ld,Pixel.Data.Filled)end end;local jd={}for kd,ld in pairs(gd.Data)do for md,nd in pairs(ld)do jd[kd-1]=jd[kd-1]or{}jd[kd]=jd[kd]or{}jd[kd+1]=jd[kd+1]or{}jd[kd-1][md-1]=true;jd[kd][md-1]=true;jd[kd+1][md-1]=true;jd[kd-1][md]=true;jd[kd][md]=true;jd[kd+1][md]=true;jd[kd-1][md+1]=true;jd[kd][md+1]=true;jd[kd+1][md+1]=true end end;for kd,ld in pairs(jd)do for md,nd in pairs(ld)do id(kd,md)end end;return hd end;local ec=50;local function fc(fd,gd,hd,id)local jd,kd=(fd+hd)/2,(gd+id)/2;local ld=-1 / ( (id-gd)/ (hd-fd))local md=math.sqrt((ec^2)- ((( (jd-fd)^2 + (kd-gd)^2))))if fd==hd then return Round(jd+md),Round(kd)elseif gd==id then return Round(jd),Round(kd+md)else local nd=(md/math.sqrt(1 + (ld^2)))local od=ld*nd;return Round(jd+nd),Round(jd+od)end end;local function gc(fd,gd,hd,id,jd)local kd,ld=fc(gd,hd,id,jd)fd=Pixel.Line(fd,gd,hd,kd,ld)fd=Pixel.Line(fd,kd,ld,id,jd)return fd end;function Pixel.AnimateWrite(fd,gd,hd,id)local jd=true;fd=GetPixelData(fd)gd=GetPixelData(gd)hd=hd or 0;id=id or 0;local kd={}local ld={}for qd,rd in pairs(gd.Data)do for sd,td in pairs(rd)do if td==Pixel.Data.Filled then table.insert(kd,qd)ld[qd]=ld[qd]or{}table.insert(ld[qd],sd)end end end;table.sort(kd)local function md(qd)print(qd)end;local function nd(qd,rd,sd,td)local ud=0;if math.abs(sd-qd)<=1 and math.abs(td-rd)<=1 then return ud else Pixel.Line(Pixel.New(),qd,rd,sd,td,{setfunction=function(vd,wd)if(vd==qd and wd==rd)or(vd==sd and wd==td)then else ud=ud+1;local xd=Pixel.Copy(fd)xd=gc(xd,hd,id,vd,wd)md(xd)end end})return ud end end;local od,pd;for i=1,#kd do local qd=kd[i]if od~=qd then table.sort(ld[qd])for i2=1,#ld[qd]do local rd=ld[qd][i2]if pd then if od and i2 ==1 then nd(od,pd,qd,rd)else nd(qd,pd,qd,rd)end end;local sd=Pixel.Copy(fd)sd=gc(sd,hd,id,qd,rd)fd=Pixel.SetPixel(fd,qd,rd,Pixel.Data.Filled)md(sd)pd=rd end;od=qd end end end;local hc=string.char;local ic=type;local jc=select;local kc=string.sub;local lc=table.concat;local mc={}local nc={}for i=0,255 do local fd,gd=hc(i),hc(i,0)mc[fd]=gd;nc[gd]=fd end;local function oc(fd,gd,hd,id)if hd>=256 then hd,id=0,id+1;if id>=256 then gd={}id=1 end end;gd[fd]=hc(hd,id)hd=hd+1;return gd,hd,id end;local function pc(fd)if ic(fd)~="string"then return nil,"string expected, got "..ic(fd)end;local gd=#fd;if gd<=1 then return"u"..fd end;local hd={}local id,jd=0,1;local kd={"c"}local ld=1;local md=2;local nd=""for i=1,gd do local od=kc(fd,i,i)local pd=nd..od;if not(mc[pd]or hd[pd])then local qd=mc[nd]or hd[nd]if not qd then return nil,"algorithm error, could not fetch word"end;kd[md]=qd;ld=ld+#qd;md=md+1;if gd<=ld then return"u"..fd end;hd,id,jd=oc(pd,hd,id,jd)nd=od else nd=pd end end;kd[md]=mc[nd]or hd[nd]ld=ld+#kd[md]md=md+1;if gd<=ld then return"u"..fd end;return lc(kd)end;local function qc(fd,gd,hd,id)if hd>=256 then hd,id=0,id+1;if id>=256 then gd={}id=1 end end;gd[hc(hd,id)]=fd;hd=hd+1;return gd,hd,id end;local function rc(fd)if ic(fd)~="string"then return nil,"string expected, got "..ic(fd)end;if#fd<1 then return nil,"invalid input - not a compressed string"end;local gd=kc(fd,1,1)if gd=="u"then return kc(fd,2)elseif gd~="c"then return nil,"invalid input - not a compressed string"end;fd=kc(fd,2)local hd=#fd;if hd<2 then return nil,"invalid input - not a compressed string"end;local id={}local jd,kd=0,1;local ld={}local md=1;local nd=kc(fd,1,2)ld[md]=nc[nd]or id[nd]md=md+1;for i=3,hd,2 do local od=kc(fd,i,i+1)local pd=nc[nd]or id[nd]if not pd then return nil,"could not find last from dict. Invalid input?"end;local qd=nc[od]or id[od]if qd then ld[md]=qd;md=md+1;id,jd,kd=qc(pd..kc(qd,1,1),id,jd,kd)else local rd=pd..kc(pd,1,1)ld[md]=rd;md=md+1;id,jd,kd=qc(rd,id,jd,kd)end;nd=od end;return lc(ld)end;function Pixel.Compress(fd)local gd=GetPixelData(fd)local hd={'M'}table.insert(hd,'Color{')for Bd,Cd in pairs(gd.Color)do table.insert(hd,'[')table.insert(hd,tostring(Bd))table.insert(hd,']={')for Dd,Ed in pairs(Cd)do if Ed then table.insert(hd,'[')table.insert(hd,tostring(Dd))table.insert(hd,']=\'')table.insert(hd,tostring(Ed))table.insert(hd,'\',')end end;hd[#hd]='\''table.insert(hd,'}')end;table.insert(hd,'}')hd=table.concat(hd)local id,jd,kd=Pixel.Convert.From2d(gd)local ld='X'..tostring(jd)..'Y'..tostring(kd)..'S'..id..hd;local md=pc(ld)do return'1'..md end;local nd={}local od=4;local pd=0;local qd=0;local rd={}for Bd,Cd in pairs(gd.Data)do for Dd,Ed in pairs(Cd)do for Fd,Gd in pairs(gd.Data)do for Hd,Id in pairs(Gd)do if Fd>Bd and Hd>Dd then if math.abs(Fd-Bd)>od and math.abs(Hd-Dd)>od then local Jd=0;for x=Bd,Fd do for y=Dd,Hd do if Pixel.GetPixel(gd,x,y)==Pixel.Data.Filled then Jd=Jd+1 end end end;local Kd=( (math.abs(Fd-Bd)+1)* (math.abs(Hd-Dd)+1))if(Jd/Kd)>0.8 then local Ld=( (2 +#tostring(Bd)+#tostring(Dd)+Kd+ (math.abs(Fd-Bd)))- (4 +#tostring(Bd)+#tostring(Dd)+#tostring(Fd)+#tostring(Hd)+ (pd* (Kd-Jd)+ (qd* ( (Jd/Kd)==1 and 1 or 0)))))/1;if Ld>0 then table.insert(rd,{Ld,Bd,Dd,Fd,Hd})end end end end end end end end;local sd=function(Bd,Cd)local Dd={}for Fd in pairs(Bd)do Dd[#Dd+1]=Fd end;if Cd then table.sort(Dd,function(Fd,Gd)return Cd(Bd,Fd,Gd)end)else table.sort(Dd)end;local Ed=0;return function()Ed=Ed+1;if Dd[Ed]then return Dd[Ed],Bd[Dd[Ed]]end end end;for Bd,Cd in sd(rd,function(Bd,Cd,Dd)return Bd[Cd][1]>Bd[Dd][1]end)do if Cd then local Dd={Cd[2],Cd[3],Cd[4],Cd[5]}for Ed,Fd in pairs(rd)do if Bd~=Ed then local Gd={Fd[2],Fd[3],Fd[4],Fd[5]}if Dd[1]<Gd[3]and Dd[3]>Gd[1]and Dd[2]<Gd[4]and Dd[4]>Gd[2]then rd[Ed]=nil end end end end end;local td,ud=nil,nil;local function vd(Bd,Cd,Dd)local Ed=false;if not(td==Bd)then table.insert(nd,'X')table.insert(nd,Bd)td=Bd;Ed=true end;if not(ud and(ud+1 ==Cd)or false)then table.insert(nd,'Y')table.insert(nd,Cd)Ed=true end;if Ed then table.insert(nd,'S')end;table.insert(nd,Dd)ud=Cd end;for Bd,Cd in sd(rd,function(Bd,Cd,Dd)return Bd[Cd][1]>Bd[Dd][1]end)do local Dd={Cd[2],Cd[3],Cd[4],Cd[5]}table.insert(nd,'A')table.insert(nd,Dd[1])table.insert(nd,'B')table.insert(nd,Dd[2])table.insert(nd,'C')table.insert(nd,Dd[3])table.insert(nd,'D')table.insert(nd,Dd[4])table.insert(nd,'S')table.insert(nd,Pixel.Data.Filled)local Ed={}for x=Dd[1],Dd[3]do for y=Dd[2],Dd[4]do if Pixel.GetPixel(gd,x,y)==Pixel.Data.Empty then table.insert(Ed,{x,y})else if gd.Data[x]then gd.Data[x][y]=nil end;if gd.Data[x]then local Fd=true;for Gd,Hd in pairs(gd.Data[x])do Fd=false;break end;if Fd then gd.Data[x]=nil end end end end end;for i=1,#Ed do vd(Ed[i][1],Ed[i][2],Pixel.Data.Empty)end end;for Bd,Cd in pairs(gd.Data)do for Dd,Ed in pairs(Cd)do if Ed==Pixel.Data.Filled then vd(Bd,Dd,Pixel.Data.Filled)end end end;local wd=table.concat(nd)..hd;local xd=pc(wd)local yd=nil;local zd={ld,md,wd,xd}local Ad={'0','1','2','3'}for Bd,Cd in pairs(zd)do print(Bd,#Cd)end;for Bd,Cd in sd(zd,function(Bd,Cd,Dd)return#Bd[Cd]<#Bd[Dd]end)do yd=Ad[Bd]..Cd;break end;return yd end;function Pixel.Decompress(fd)local gd=string.sub(fd,1,1)fd=string.sub(fd,2,-1)local hd=false;if gd=='0'then elseif gd=='1'then fd=rc(fd)elseif gd=='2'then hd=true elseif gd=='3'then hd=true;fd=rc(fd)end;local id=#fd;repeat if string.sub(fd,id,id)=='M'then break end;id=id-1;if id<=0 then error('No metadata found')end until false;local jd=string.sub(fd,id+1,-1)fd=string.sub(fd,1,id-1)local kd=Pixel.New()local ld={}local function md(rd,sd)if rd=='S'then sd=tostring(sd)for i=1,#sd do local td=string.sub(sd,i,i)if ld.A and ld.B and ld.C and ld.D then for x=ld.A,ld.C do for y=ld.B,ld.D do Pixel.SetPixel(kd,x,y,td)end end;ld.A,ld.B,ld.C,ld.D=nil,nil,nil,nil elseif ld.X and ld.Y then if hd==false then if td==Pixel.Data.NewLine then ld.Y=ld.Y+1;ld.X=ld.DX else Pixel.SetPixel(kd,ld.X,ld.Y,td)ld.X=ld.X+1 end else if td==Pixel.Data.NewLine then ld.X=ld.X+1 else Pixel.SetPixel(kd,ld.X,ld.Y,td)ld.Y=ld.Y+1 end end else error('Unable to determine opdata set')end end else sd=tonumber(sd)ld[rd]=sd;if hd==false and rd=='X'then ld.DX=ld.X end end end;local nd={A=true,B=true,C=true,D=true,X=true,Y=true,S=true}local od=false;local pd=''local qd=''for i=1,#fd+1 do local rd=string.sub(fd,i,i)if nd[rd]or(i==#fd+1)then if od then md(pd,qd)end;od=true;pd=rd;qd=''else if od then qd=qd..rd else error('Invalid opcode: '..rd..', i: '..i)end end end;return kd end;BenchmarkOn=false;function Pixel.Benchmark()if BenchmarkOn then local fd=os.clock()-BenchmarkOn;print(fd)else BenchmarkOn=os.clock()end end;BenchmarkFunctionStats={{'','Test Length','Count','Per Second','Per Operation'}}function Pixel.BenchmarkFunction(fd,gd,hd)if ic(gd[1])=='table'and gd[1].Data then else if hd then else table.insert(gd,1,Pixel.New())end end;local id;if ic(fd)=='function'then id=fd elseif ic(fd)=='string'then id=Pixel[fd]else error('Invalid Function.')end;local jd=5;local kd=0;local ld=os.clock()repeat id(unpack(gd))kd=kd+1 until ld+jd<=os.clock()local md={}md[1]=tostring(fd)md[2]=jd;md[3]=kd;md[4]=kd/jd;md[5]=jd/kd;table.insert(BenchmarkFunctionStats,md)end;function Pixel.BenchmarkFunctionChart()local function fd(id)local jd={}for x=1,#id do for y=1,#id[x]do jd[y]=jd[y]or{}jd[y][x]=id[x][y]end end;local kd={}for i=1,#id do table.insert(kd,id[i][1])end;local ld={}for i=1,#id[1]do table.insert(ld,id[1][i])end;local md={}for i=1,#id do local od=0;for i2=1,#id[i]do local pd=#tostring(id[i][i2])od=(pd>od)and pd or od end;table.insert(md,od+1)end;local nd={}for i=1,#jd do for i2=1,#jd[i]do local od=tostring(jd[i][i2])table.insert(nd,od..string.rep(' ',md[i2]-#od))end;table.insert(nd,'\n')end;return table.concat(nd)end;local gd=pcall(function()require'jit'end)local hd='Version: '.._VERSION.. (gd and' JIT'or'')..'\n'..fd(BenchmarkFunctionStats)..'\n'print(hd)return hd end;return Pixel
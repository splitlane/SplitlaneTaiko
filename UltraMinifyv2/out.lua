local __OptimizedPixel Split=function(__a,__b)local __c={}for __d,__b in __a:gmatch("([^"..__b.."]*)("..__b.."?)")do table.insert(__c,__d)if __b==''then return __c end end end Trim=function(__s)local __a=__s:gsub("^%s*(.-)%s*$","%1")return __a end TrimLeft=function(__s)local __a=__s:gsub("^%s*(.-)$","%1")return __a end TrimRight=function(__s)local __a=__s:gsub("^(.-)%s*$","%1")return __a end StartsWith=function(__a,__b)return __a:sub(1,#__b)==__b end EndsWith=function(__a,__b)return __a:sub(-#__b,-1)==__b end Table={}function Table.Clone(__orig,__copies)__copies=__copies or{}local __orig_type=type(__orig)local __copy if __orig_type=='table'then if __copies[__orig]then __copy=__copies[__orig]else __copy={}__copies[__orig]=__copy for __orig_key,__orig_value in next,__orig,nil do __copy[Table.Clone(__orig_key,__copies)]=Table.Clone(__orig_value,__copies)end setmetatable(__copy,Table.Clone(getmetatable(__orig),__copies))end else __copy=__orig end return __copy end ClipN=function(__n,__a,__b)if __n<__a then return __a elseif __n>__b then return __b else return __n end end function Error(__msg)error(__msg)end LineN=nil function ParseError(__cmd,__msg,__data)Error('Line: '..LineN..'\n'..__cmd..': '..__msg.. (__data and(', '..__data)or''))end function MsToS(__ms)return __ms/1000 end function SToMs(__s)return __s*1000 end Taiko={}Taiko.Data={Languages={'','EN','JA','CN','TW','KO'},GenreName={Pop={'pop','j-pop'},Anime={'anime','アニメ'},Kids={'kids','どうよう'},Variety={'variety','バラエティ'},VOCALOID={'vocaloid','ボーカロイド'},Classic={'classic','クラシック'},['Game Music']={'game music','ゲームミュージック'},['Namco Original']={'namco original','ナムコオリジナル'}},CourseId={easy=0,normal=1,hard=2,oni=3,edit=4,tower=5,dan=6,ura=4},CourseName={[0]='Easy','Normal','Hard','Oni','Edit','Tower','Dan','Ura'},RatingMultiplier={[0]=0,[1]=0.5,[2]=1,[3]=2},GogoMultiplier=1.2,ScoreMode={[0]=function(__score,__combo,__init,__diff,__status,__gogo)return __score+ ( ( (__combo<200)and(__init or 1000)or( (__init or 1000)+ (__diff or 1000)))*Taiko.Data.RatingMultiplier[__status]* (__gogo and Taiko.Data.GogoMultiplier or 1))end,[1]=function(__score,__combo,__init,__diff,__status,__gogo)return __score+ ( (__init+math.max(0,__diff*math.floor((math.min(__combo,100)-1)/10)))*Taiko.Data.RatingMultiplier[__status]* (__gogo and Taiko.Data.GogoMultiplier or 1))end,[2]=function(__score,__combo,__init,__diff,__status,__gogo)return __score+ ( (__init+__diff* ( (__combo>=100)and 8 or(__combo>=50)and 4 or(__combo>=30)and 2 or(__combo>=10)and 1 or 0))*Taiko.Data.RatingMultiplier[__status]* (__gogo and Taiko.Data.GogoMultiplier or 1))end},Autoscore={[0]=function(__Parsed)end,[1]=function(__Parsed)end,[2]=function(__Parsed)end},SideId={normal=1,ex=2,both=3},SideName={'normal','ex','both'},StyleId={single=1,double=2,couple=2},StyleName={'single','double'},Exam={Condition={g=true,jp=true,jg=true,jb=true,s=true,r=true,h=true,c=true},Scope={m=true,l=true}},Branch={PathId={N=0,E=1,M=2},PathName={[0]='N',[1]='E',[2]='M'},Requirements={r=function()end,p=function()end}},Timing={GetFunction=function(__course)return function(__framems)if __course==1 then return{good=5 /2 *__framems,ok=13 /2 *__framems,bad=15 /2 *__framems}else return{good=3 /2 *__framems,ok=9 /2 *__framems,bad=13 /2 *__framems}end end end},StatusId={bad=0,ok=1,good=2,biggood=3},StatusName={[0]='BAD',[1]='OK',[2]='GOOD',[3]='GOOD'},ModeId={['']=0,P1=1,P2=2},ModeName={[0]='',P1,P2},Combo={[1]=true,[2]=true,[3]=true,[4]=true},BigLeniency=2,Strings={Notes={}}}for __k,__v in pairs(Taiko.Data.ScoreMode)do Taiko.Data.ScoreMode[__k]=function(...)return math.floor(__v(...)/10)*10 end end function Taiko.ParseTJA(__source)local __time=os.clock()local __Out={}local __Parsed={Metadata={SUBTITLE='',BPM=120,WAVE='main.mp3',OFFSET=0,DEMOSTART=0,SCOREMODE=1,SONGVOL=100,SEVOL=100,SIDE=3,LIFE=0,GAME='Taiko',HEADSCROLL=1,MOVIEOFFSET=0,COURSE='ONI',LEVEL=0,BALLOON=nil,SCOREINIT,SCOREDIFF,BALLOONNOR=nil,BALLOONEXP=nil,BALLOONMAS=nil,STYLE=1,EXAM1=nil,EXAM2=nil,EXAM3=nil,GAUGEINCR='NORMAL',TOTAL=nil,HIDDENBRANCH=0,DIVERGENOTES=false,SCOREINIT=0,SCOREDIFF=0},Data={}}local function __GetTranslated(__name)local __a=Taiko.Data.Languages for i=1,#__a do local __b=__Parsed.Metadata[__name..__a[i]]if __b then return __b end end return nil end local function __CheckN(__cmd,__n,__e)local __a=tonumber(__n)if __a then return __a else ParseError(__cmd,__e,__n)end end local function __Check(__cmd,__a,__e,__data)if __a then return __a else ParseError(__cmd,__e,__data)end end local function __CheckB(__cmd,__b,__e)local __boolean={['true']=true,['false']=false,yes=true,no=false,['1']=true,['0']=false,[1]=true,[0]=false}local __a=__boolean[__b]~=nil if __a then return __a else ParseError(__cmd,__e,__b)end end local function __CheckCSV(__cmd,__str)local __seperator=','local __escape='\\'local __t={}local __temp=''local __escaped=false for i=1,#__str do local __s=string.sub(__str,i,i)if __escaped then __temp=__temp..__s __escaped=false else if __s==__seperator then table.insert(__t,__temp)__temp=''elseif __s==__escape then __escaped=true else __temp=__temp..__s end end end table.insert(__t,__temp)return __t end local function __CheckCSVN(__cmd,__str,__e)local __t=__CheckCSV(__cmd,__str)for i=1,#__t do __t[i]=__CheckN(__cmd,__t[i],__e,__str)end return __t end local function __CheckBalloon(__cmd,__s,__e)if __s and __s~=''then return __CheckCSVN(__cmd,__s,__e)else return{}end end local function __CheckExam(__cmd,__s,__e)if __s and __s~=''then local __t=__CheckCSV(__cmd,__s,__e)__Check(__cmd,Taiko.Data.Exam.Condition[__t[1]],__e)__t[2]=__CheckN(__cmd,__t[2],__e)__t[3]=__CheckN(__cmd,__t[3],__e)__Check(__cmd,Taiko.Data.Exam.Scope[__t[4]],__e)return __t else return{}end end local __Parser={}local function __GetParser()local __Parser={settings={noteparse={notealias={A=3,B=4},noteexceptions={[',']=true,[' ']=true,['\t']=true}},command={matchexceptions={}}},bpm=0,ms=0,songstarted=false,timingpoint=nil,sign=4 /4,mpm=0,mspermeasure=0,scroll=1,measuredone=true,currentmeasure={},measurepushto=__Parsed.Data,barline=true,gogo=false,lastlong=nil,balloonn=1,currentbranch=nil,branch={on=false,requirements={},paths={}},msbeforebranch=nil,section=false,notechain={}}function __Parser.createnote(__n)if __n then local __note={ms=nil,data=nil,type=__n,txt=nil,gogo=__Parser.gogo,scroll=(__Parser.scroll*__Parsed.Metadata.HEADSCROLL),mspermeasure=__Parser.mspermeasure,bpm=__Parser.bpm,nextnote=nil,radius=1,requiredhits=nil,length=nil,endnote=nil,section=nil,text=nil,onnotepush=nil}__note.type=__n if __n==3 or __n==4 or __n==6 then __note.radius=__note.radius*1.6 end if __n==5 or __n==6 or __n==7 or __n==9 then if __Parser.lastlong then if __n==9 then else ParseError('parser.noteparse','Last long note has not ended')end else __Parser.lastlong=__note if __n==7 or __n==9 then __note.requiredhits=__Check('parser.noteparse',__Parsed.Metadata.BALLOON[__Parser.balloonn],'Invalid number of balloons',__Parser.balloonn)__Parser.balloonn=__Parser.balloonn+1 end end end if __n==8 then local __lastlong=__Parser.lastlong __Parser.lastlong=nil __note.startnote=__lastlong if __lastlong then __note.onnotepush=function()__lastlong.length=__note.ms-__lastlong.ms __lastlong.endnote=__note end else end end if __Parser.section then __note.section=true __Parser.section=false end return __note else return{ms=nil,data=nil,type=nil,txt=nil,gogo=__Parser.gogo,scroll=(__Parser.scroll*__Parsed.Metadata.HEADSCROLL),mspermeasure=__Parser.mspermeasure,bpm=__Parser.bpm,nextnote=nil}end end function __Parser.endbranch()local __n=__Parser.createnote()__n.data='event'__n.event='branch'__n.branch={requirements=__Parser.branch.requirements,paths=__Parser.branch.paths}__Parser.branch.on=false __Parser.branch.requirements={}__Parser.branch.paths={}table.insert(__Parsed.Data,__n)__Parser.measurepushto=__Parsed.Data end return __Parser end __Parser=__GetParser()local __lines=Split(__source,'\n')for i=1,#__lines do LineN=i local __line=Trim(__lines[i])if StartsWith(__line,'//')or __line==''then else local __comment=string.find(__line,'//')if __comment then __line=string.sub(__line,1,__comment-1)end local __done=false if __Parser.songstarted==false and __done==false then local __match={string.match(__line,'(%u+):(.*)')}if __match[1]then local __a=Trim(__match[2])if __a~=''then __Parsed.Metadata[Trim(__match[1])]=__a end __done=true end end if(__Parser.songstarted or StartsWith(__line,'#START'))and __done==false then local __match={string.match(__line,'#(%u-)%s(.*)')}if not __match[1]then __match={string.match(__line,'#(%u+)')}end if __match[1]then if __match[1]=='START'then if __Parser.songstarted then ParseError(__match[1],'Song has already started')else __Parsed.OriginalMetadata=Table.Clone(__Parsed.Metadata)if __match[2]then __Parsed.Metadata.MODE=__Check(__match[1],Taiko.Data.ModeId[__match[2]],'Invalid mode',__match[2])else __Parsed.Metadata.MODE=0 end __Parsed.Metadata.TITLE=__Check(__match[1],__GetTranslated'TITLE','Title is missing')__Parsed.Metadata.SUBTITLE=__Check(__match[1],__GetTranslated'SUBTITLE','Subtitle is missing')__Parsed.Metadata.BPM=__CheckN(__match[1],__Parsed.Metadata.BPM,'Invalid bpm')__Parsed.Metadata.OFFSET=SToMs(__CheckN(__match[1],__Parsed.Metadata.OFFSET,'Invalid offset'))__Parsed.Metadata.DEMOSTART=SToMs(__CheckN(__match[1],__Parsed.Metadata.DEMOSTART,'Invalid demostart'))if __Parsed.Metadata.DEMOSTART==0 then __Parsed.Metadata.DEMOSTART=nil end for __k,__v in pairs(Taiko.Data.GenreName)do for i=1,#__v do if __v[i]==__Parsed.Metadata.GENRE then __Parsed.Metadata.GENRE=__k end end end __Parsed.Metadata.SCOREMODE=__CheckN(__match[1],__Parsed.Metadata.SCOREMODE,'Invalid scoremode')__Check(__match[1],Taiko.Data.ScoreMode[__Parsed.Metadata.SCOREMODE],'Invalid scoremode',__Parsed.Metadata.SCOREMODE)if __Parsed.Metadata.MAKER then __Parsed.Metadata.CREATORURLT={}__Parsed.Metadata.CREATOR=Trim(string.gsub(__Parsed.Metadata.MAKER,'(<.->)',function(__url)table.insert(__Parsed.Metadata.CREATORURLT,string.sub(__url,2,-2))return''end))__Parsed.Metadata.CREATORURL=table.concat(__Parsed.Metadata.CREATORURLT,', ')__Parsed.Metadata.CREATIVE=false else __Parsed.Metadata.CREATIVE=false end __Parsed.Metadata.SONGVOL=__CheckN(__match[1],__Parsed.Metadata.SONGVOL,'Invalid songvol')/100 __Parsed.Metadata.SEVOL=__CheckN(__match[1],__Parsed.Metadata.SEVOL,'Invalid sevol')/100 local __a=tonumber(__Parsed.Metadata.SIDE)if __a then __Check(__match[1],Taiko.Data.SideName[__a],'Invalid side id',__Parsed.Metadata.SIDE)__Parsed.Metadata.SIDE=__a else __Parsed.Metadata.SIDE=__Check(__match[1],Taiko.Data.SideId[string.lower(__Parsed.Metadata.SIDE)],'Invalid side name',__Parsed.Metadata.SIDE)end __Parsed.Metadata.LIFE=__CheckN(__match[1],__Parsed.Metadata.LIFE,'Invalid life')if __Parsed.Metadata.LIFE==0 then __Parsed.Metadata.LIFE=nil end __Parsed.Metadata.GAME=string.lower(__Parsed.Metadata.GAME)if __Parsed.Metadata.GAME=='taiko'then elseif __Parsed.Metadata.GAME=='jube'then else end __Parsed.Metadata.HEADSCROLL=__CheckN(__match[1],__Parsed.Metadata.HEADSCROLL,'Invalid headscroll')__Parsed.Metadata.MOVIEOFFSET=__CheckN(__match[1],__Parsed.Metadata.MOVIEOFFSET,'Invalid movieoffset')local __a=tonumber(__Parsed.Metadata.COURSE)if __a then __Check(__match[1],Taiko.Data.CourseName[__a],'Invalid course id',__Parsed.Metadata.COURSE)__Parsed.Metadata.COURSE=__a else __Parsed.Metadata.COURSE=__Check(__match[1],Taiko.Data.CourseId[string.lower(__Parsed.Metadata.COURSE)],'Invalid course name',__Parsed.Metadata.COURSE)end __Parsed.Metadata.TIMING=Taiko.Data.Timing.GetFunction(__Parsed.Metadata.COURSE)__Parsed.Metadata.LEVEL=ClipN(math.floor(__CheckN(__match[1],__Parsed.Metadata.LEVEL,'Invalid level')),0,10)__Parsed.Metadata.BALLOON=__CheckBalloon(__match[1],__Parsed.Metadata.BALLOON,'Invalid balloon')__Parsed.Metadata.SCOREINIT=__CheckN(__match[1],__Parsed.Metadata.SCOREINIT,'Invalid scoreinit')__Parsed.Metadata.SCOREDIFF=__CheckN(__match[1],__Parsed.Metadata.SCOREDIFF,'Invalid scoreinit')__Parsed.Metadata.BALLOONNOR=__CheckBalloon(__match[1],__Parsed.Metadata.BALLOONNOR,'Invalid balloonnor')__Parsed.Metadata.BALLOONEXP=__CheckBalloon(__match[1],__Parsed.Metadata.BALLOONEXP,'Invalid balloonexp')__Parsed.Metadata.BALLOONMAS=__CheckBalloon(__match[1],__Parsed.Metadata.BALLOONMAS,'Invalid balloonmas')local __a=tonumber(__Parsed.Metadata.STYLE)if __a then __Check(__match[1],Taiko.Data.StyleName[__a],'Invalid style id',Taiko.Data.STYLE)__Parsed.Metadata.STYLE=__a else __Parsed.Metadata.STYLE=__Check(__match[1],Taiko.Data.StyleId[string.lower(__Parsed.Metadata.STYLE)],'Invalid style name',__Parsed.Metadata.STYLE)end __Parsed.Metadata.EXAM1=__CheckExam(__Parsed.Metadata.EXAM1)__Parsed.Metadata.EXAM2=__CheckExam(__Parsed.Metadata.EXAM2)__Parsed.Metadata.EXAM3=__CheckExam(__Parsed.Metadata.EXAM3)__Parsed.Metadata.GAUGEINCR=string.lower(__Parsed.Metadata.GAUGEINCR)if __Parsed.Metadata.TOTAL then __Parsed.Metadata.TOTAL=__CheckN(__match[1],__Parsed.Metadata.TOTAL,'Invalid total')end __Parsed.Metadata.HIDDENBRANCH=__CheckB(__match[1],__Parsed.Metadata.HIDDENBRANCH,'Invalid hiddenbranch')__Parser.bpm=__Parsed.Metadata.BPM __Parser.songstarted=true end elseif __match[1]=='END'then if __Parser.songstarted then if#__Parser.currentmeasure~=0 then ParseError(__match[1],'Current measure is not empty')end table.insert(__Out,__Parsed)__Parsed={Metadata=Table.Clone(__Parsed.OriginalMetadata),Data={}}__Parser=__GetParser()__Parser.songstarted=false __Parser.measurepushto=__Parsed.Data else ParseError(__match[1],'Song has already ended')end elseif __match[1]=='MEASURE'then local __a,__b=string.match(__match[2],'(%d+)/(%d+)')__a=__CheckN(__match[1],__a,'Invalid measure')__b=__CheckN(__match[1],__b,'Invalid measure')__Parser.sign=(__a/__b)or __Parser.sign elseif __match[1]=='BPMCHANGE'then __Parser.bpm=__CheckN(__match[1],__match[2],'Invalid bpmchange')or __Parser.bpm elseif __match[1]=='DELAY'then table.insert(__Parser.currentmeasure,{__match[1],SToMs((__CheckN(__match[1],__match[2],'Invalid delay')or 0))})elseif __match[1]=='SCROLL'then __Parser.scroll=__CheckN(__match[1],__match[2],'Invalid scroll')or __Parser.scroll if __Parser.scroll==0 then ParseError(__match[1],'Scroll cannot be 0')end elseif __match[1]=='GOGOSTART'then __Parser.gogo=true elseif __match[1]=='GOGOEND'then __Parser.gogo=false elseif __match[1]=='BARLINEOFF'then __Parser.barline=false elseif __match[1]=='BARLINEON'then __Parser.barline=true elseif __match[1]=='BRANCHSTART'then if __Parser.branch.on then __Parser.endbranch()end __Parser.msbeforebranch=__Parser.ms __Parser.branch.on=true __Parsed.Metadata.DIVERGENOTES=true local __t=__CheckCSV(__match[1],__match[2])local __f=__Check(__match[1],Taiko.Data.Branch.Requirements[string.lower(__t[1])],'Invalid type',__t[1])__Parser.branch.requirements={__f}local __i=2 while true do if not __t[__i]then break end local __p=Taiko.Data.Branch.PathName[__i-1]if __p then __Parser.branch.requirements[__p]=__t[__i]else break end __i=__i+1 end elseif Taiko.Data.Branch.PathId[__match[1]]then if __Parser.branch.on then __Parser.ms=__Parser.msbeforebranch __Parser.currentbranch=__match[1]__Parser.branch.paths[__match[1]]={}__Parser.measurepushto=__Parser.branch.paths[__match[1]]else ParseError(__match[1],'Branch has not started')end elseif __match[1]=='BRANCHEND'then if __Parser.branch.on then __Parser.endbranch()else ParseError(__match[1],'Branch has already ended')end elseif __match[1]=='SECTION'then __Parser.section=true elseif __match[1]=='LYRIC'then elseif __match[1]=='LEVELHOLD'then elseif __match[1]=='BMSCROLL'then elseif __match[1]=='HBSCROLL'then elseif __match[1]=='SENOTECHANGE'then elseif __match[1]=='NEXTSONG'then elseif __match[1]=='DIRECTION'then elseif __match[1]=='SUDDEN'then elseif __match[1]=='JPOSSCROLL'then else end __done=true end end if(__Parser.songstarted)and __done==false then __Parser.mpm=__Parser.bpm*__Parser.sign/4 __Parser.mspermeasure=60000 *__Parser.sign*4 /__Parser.bpm if __Parser.barline and#__Parser.currentmeasure==0 then local __note=__Parser.createnote()__note.ms=__Parser.ms __note.data='event'__note.event='barline'table.insert(__Parser.measurepushto,1,__note)end for i=1,#__line do local __s=string.sub(__line,i,i)if __Parser.settings.noteparse.noteexceptions[__s]then else local __n=__CheckN('parser.noteparse',tonumber(__s)or __Parser.settings.noteparse.notealias[__s]or __s,'Invalid note')if __n then local __note=__Parser.createnote(__n)__note.data='note'table.insert(__Parser.currentmeasure,__note)end end end if EndsWith(TrimRight(__line),',')then __Parser.mpm=__Parser.bpm*__Parser.sign/4 __Parser.mspermeasure=60000 *__Parser.sign*4 /__Parser.bpm if#__Parser.currentmeasure==0 then __Parser.ms=__Parser.ms+__Parser.mspermeasure else local __notes=0 local __firstmspermeasure=nil for i=1,#__Parser.currentmeasure do local __c=__Parser.currentmeasure[i]if __c.data=='note'then __firstmspermeasure=__firstmspermeasure or __c.mspermeasure __notes=__notes+1 end end __firstmspermeasure=__firstmspermeasure or __Parser.mspermeasure local __increment=__firstmspermeasure/__notes for i=1,#__Parser.currentmeasure do local __c=__Parser.currentmeasure[i]if __c[1]=='DELAY'then __Parser.ms=__Parser.ms+__c[2]else if __c.type~=0 then __c.ms=__Parser.ms local __lastnote=__Parsed.Data[#__Parsed.Data]if __lastnote then __lastnote.nextnote=__c end table.insert(__Parser.measurepushto,__c)if __c.onnotepush then __c.onnotepush()end __increment=__c.mspermeasure/__notes end end __Parser.ms=__Parser.ms+__increment end end __Parser.measuredone=true __Parser.currentmeasure={}else __Parser.measuredone=false end end end end print('Parsing Took: '..SToMs(os.clock()-__time)..'ms')return __Out end function Taiko.Score(__Parsed,__score,__combo,__status,__gogo)if __status==0 then __combo=0 else __combo=__combo+1 end local __m=__Parsed.Metadata return Taiko.Data.ScoreMode[__m.SCOREMODE](__score,__combo,__m.SCOREINIT,__m.SCOREDIFF,__status,__gogo),__combo end function Taiko.Analyze(__Parsed)local __branch='M'local __scoredata={[1]=2,[2]=2,[3]=3,[4]=3}local __out={notes={n=0,validn=0},measures=0,lengthms=0,drumrollms=0,drumrollbigms=0,balloonms=0,balloonhit=0,specialms=0,specialhit=0,maxcombo=0,maxscore=0}local __lastnote=nil Taiko.ForAll(__Parsed.Data,function(__note,__i,__n)if __note.data=='note'then __out.notes.n=__out.notes.n+1 __out.notes[__note.type]=__out.notes[__note.type]and __out.notes[__note.type]+1 or 1 if __scoredata[__note.type]then __out.maxscore,__out.maxcombo=Taiko.Score(__Parsed,__out.maxscore,__out.maxcombo,__scoredata[__note.type],__note.gogo)end local __endnote=__note.endnote if __endnote then local __ms=__endnote.ms-__note.ms if __note.type==5 then __out.drumrollms=__out.drumrollms+__ms elseif __note.type==6 then __out.drumrollbigms=__out.drumrollbigms+__ms elseif __note.type==7 then __out.balloonms=__out.balloonms+__ms __out.balloonhit=__out.balloonhit+__note.requiredhits elseif __note.type==9 then __out.specialms=__out.specialms+__ms __out.specialhit=__out.specialhit+__note.requiredhits else end end __lastnote=__note elseif __note.data=='event'and __note.event=='barline'then __out.measures=__out.measures+1 else end end,__branch)__out.lengthms=__lastnote.ms-__Parsed.Metadata.OFFSET __out.notes.validn=__out.maxcombo return __out end function Taiko.GetDifficulty(__Parsed,__Difficulty)local __a=Taiko.Data.CourseId[string.lower(__Difficulty)]or __Difficulty for __k,__v in pairs(__Parsed)do if __v.Metadata.COURSE==__a then return __v end end Error('No difficulty found, '..__Difficulty)return nil end function Taiko.ForAll(__ParsedData,__f,__branch)local __n=1 for i=1,#__ParsedData do local __v=__ParsedData[i]if __v.branch then if __branch then local __b=__v.branch.paths[__branch]for i2=1,#__b do __f(__b[i2],i2,__n)__n=__n+1 end __n=__n-1 else local __n3=-1 for __k2,__v2 in pairs(__v.branch.paths)do local __n2=__n for i2=1,#__v2 do __f(__v2[i2],i2,__n2)__n2=__n2 +1 end __n3=(__n3 <__n2)and __n2 or __n3 end __n=__n3 end else __f(__v,i,__n)end __n=__n+1 end return __ParsedData end function Taiko.GetAllNotes(__ParsedData)local __t={}for __k,__v in pairs(__ParsedData)do if __v.branch then for __k2,__v2 in pairs(__v.branch.paths)do for i=1,#__v2 do table.insert(__t,__v2[i])end end else table.insert(__t,__v)end end return __t end function Taiko.ConnectNotes(__ParsedData)local __nextnote=nil for i=#__ParsedData,1,-1 do local __n=__ParsedData[i]__n.nextnote=__nextnote __nextnote=__n end return __ParsedData end function Taiko.ExtractBranch(__branch,__path)return __branch.branch.paths[__path]end function Taiko.ConnectAll(__ParsedData)local __nextnote=nil for i=#__ParsedData,1,-1 do local __note=__ParsedData[i]if __note.branch then for __k,__v in pairs(__note.branch.paths)do local __path=Taiko.ConnectNotes(__v)__path[#__path].nextnote=__nextnote end else __note.nextnote=__nextnote end __nextnote=__note end end function Taiko.CalculateSpeed(__note,__noteradius)local __speed=(__noteradius*__note.scroll*__note.bpm/7500)return __speed end function Taiko.CalculateSpeedAll(__ParsedData,__noteradius)for i=1,#__ParsedData do __ParsedData[i].speed=Taiko.CalculateSpeed(__ParsedData[i],__noteradius)end return __ParsedData end function Taiko.RenderScale(__Parsed)local __t={}local __mst={}local __dont={}for i=1,#__Parsed.Data do local __note=__Parsed.Data[i]if __note.data=='note'then local __ms=math.floor(__note.ms)if math.floor(__ms)-__ms==0 then table.insert(__t,{__ms,__note.type})table.insert(__mst,__ms)else table.insert(__dont,i)end end end function gcd2(__a,__b)if __b==0 then return __a else return gcd2(__b,__a%__b)end end function gcdn(__ns)local __r=__ns[1]for i=2,#__ns do __r=gcd2(__r,__ns[i])end return __r end local __gcd=gcdn(__mst)for i=1,#__dont do local __d=__t[__dont[i]]__d[1]=math.floor(__d[1]/__gcd)*__gcd end local __str=''local __ms=0 for i=1,#__t do __t[i][1]=__t[i][1]/__gcd __str=__str..string.rep(' ',__t[i][1]-__ms)..__t[i][2]__ms=__t[i][1]end return __str end function Taiko.PlaySong(__Parsed,__Window,__Settings,__Controls)local __prerender={on=false,fps=60,frames={}}local __framerate=nil local __optionsmap={auto={[1]=false,[2]=true},notespeedmul={[1]=1,[2]=2,[3]=3,[4]=4,[5]=0.25,[6]=0.5,[7]=0.75},songspeedmul={[1]=1,[2]=2,[3]=3,[4]=4,[5]=0.25,[6]=0.5,[7]=0.75}}local __auto=__optionsmap.auto[__Settings[2]]or false local __autoemu=false local __notespeedmul=__optionsmap.notespeedmul[__Settings[3]]or 1 local __songspeedmul=__optionsmap.songspeedmul[__Settings[4]]or 1 local __Controls=__Controls or{}__Controls={Hit=__Controls.Hit or{['4']=2,['v']=1,['n']=1,['8']=2},Escape=__Controls.Escape or{['\27']=true,ALT_ESC=true},L=__Controls.L or{KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_A2=true},R=__Controls.R or{KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true},Select=__Controls.Select or{KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}}local __Selected=1 local __SelectedPadding=2 local __SelectedChar='>'local __MenuConcat='\n\n\n'local __bufferlength=10 local __endms=1000 local __noteradius=4 local __y=0 local __tracky=10 local __trackstart=0 local __tracklength=40 local __target=3 local __factor=1 local __renderconfig={[1]={color='red'},[2]={color='blue'},[3]={color='red'},[4]={color='blue'},[5]={color='yellow'},[6]={color='yellow'}}local __statuslength=200 local __statusanimationlength=__statuslength/4 local __statusanimationmove=4 local __flashlength=20 __tracklength=math.floor(__tracklength*__noteradius)local __trackend=__trackstart+__tracklength __target=math.floor(__target*__noteradius)local __curses=require'taikocurses'local __window=__Window or{window=__curses.initscr()}__curses.keypad(__window,true)__curses.echo(false)__curses.raw(true)__curses.nl(false)__curses.cbreak(true)__curses.nodelay(__window,true)local __timingpixel={[0]={Data={[1]={'0','1','1','1','1','1','1','1'},[2]={[2]='1',[5]='1',[8]='1'},[3]={[2]='1',[5]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={[3]='1',[4]='1',[6]='1',[7]='1'},[8]={'0','0','1','1','1','1','1','1'},[9]={[2]='1',[5]='1'},[10]={[2]='1',[5]='1'},[11]={[2]='1',[5]='1'},[12]={[2]='1',[5]='1'},[13]={'0','0','1','1','1','1','1','1'},[15]={'0','1','1','1','1','1','1','1'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'}},Color={All='blue'},Offset={-1,0}},[1]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[8]='1'},[5]={[2]='1',[8]='1'},[6]={'0','0','1','1','1','1','1','0'},[8]={'0','1','1','1','1','1','1','1'},[9]={[5]='1'},[10]={[4]='1',[6]='1'},[11]={[3]='1',[7]='1'},[12]={[2]='1',[8]='1'}},Color={All='white'},Offset={-1,0}},[2]={Data={[1]={'0','0','1','1','1','1','1','0'},[2]={[2]='1',[8]='1'},[3]={[2]='1',[8]='1'},[4]={[2]='1',[5]='1',[8]='1'},[5]={[2]='1',[5]='1',[8]='1'},[6]={'0','1','0','0','1','1','1','1'},[8]={'0','0','1','1','1','1','1','0'},[9]={[2]='1',[8]='1'},[10]={[2]='1',[8]='1'},[11]={[2]='1',[8]='1'},[12]={[2]='1',[8]='1'},[13]={'0','0','1','1','1','1','1','0'},[15]={'0','0','1','1','1','1','1','0'},[16]={[2]='1',[8]='1'},[17]={[2]='1',[8]='1'},[18]={[2]='1',[8]='1'},[19]={[2]='1',[8]='1'},[20]={'0','0','1','1','1','1','1','0'},[22]={'0','1','1','1','1','1','1','1'},[23]={[2]='1',[8]='1'},[24]={[2]='1',[8]='1'},[25]={[2]='1',[8]='1'},[26]={[2]='1',[8]='1'},[27]={'0','0','1','1','1','1','1','0'}},Color={All='yellow'},Offset={-1,0}},Size={27,8}}__timingpixel[3]=__timingpixel[2]local __flashpixel={[0]=nil,[1]={},[2]={}}local __Pixel if __OptimizedPixel then __Pixel=__OptimizedPixel else os.execute'chcp 65001'__Pixel={}local __dotdata=([[
⠀ ⢀ ⠠ ⢠ ⠐ ⢐ ⠰ ⢰ ⠈ ⢈ ⠨ ⢨ ⠘ ⢘ ⠸ ⢸
⡀ ⣀ ⡠ ⣠ ⡐ ⣐ ⡰ ⣰ ⡈ ⣈ ⡨ ⣨ ⡘ ⣘ ⡸ ⣸
⠄ ⢄ ⠤ ⢤ ⠔ ⢔ ⠴ ⢴ ⠌ ⢌ ⠬ ⢬ ⠜ ⢜ ⠼ ⢼
⡄ ⣄ ⡤ ⣤ ⡔ ⣔ ⡴ ⣴ ⡌ ⣌ ⡬ ⣬ ⡜ ⣜ ⡼ ⣼
⠂ ⢂ ⠢ ⢢ ⠒ ⢒ ⠲ ⢲ ⠊ ⢊ ⠪ ⢪ ⠚ ⢚ ⠺ ⢺
⡂ ⣂ ⡢ ⣢ ⡒ ⣒ ⡲ ⣲ ⡊ ⣊ ⡪ ⣪ ⡚ ⣚ ⡺ ⣺
⠆ ⢆ ⠦ ⢦ ⠖ ⢖ ⠶ ⢶ ⠎ ⢎ ⠮ ⢮ ⠞ ⢞ ⠾ ⢾
⡆ ⣆ ⡦ ⣦ ⡖ ⣖ ⡶ ⣶ ⡎ ⣎ ⡮ ⣮ ⡞ ⣞ ⡾ ⣾
⠁ ⢁ ⠡ ⢡ ⠑ ⢑ ⠱ ⢱ ⠉ ⢉ ⠩ ⢩ ⠙ ⢙ ⠹ ⢹
⡁ ⣁ ⡡ ⣡ ⡑ ⣑ ⡱ ⣱ ⡉ ⣉ ⡩ ⣩ ⡙ ⣙ ⡹ ⣹
⠅ ⢅ ⠥ ⢥ ⠕ ⢕ ⠵ ⢵ ⠍ ⢍ ⠭ ⢭ ⠝ ⢝ ⠽ ⢽
⡅ ⣅ ⡥ ⣥ ⡕ ⣕ ⡵ ⣵ ⡍ ⣍ ⡭ ⣭ ⡝ ⣝ ⡽ ⣽
⠃ ⢃ ⠣ ⢣ ⠓ ⢓ ⠳ ⢳ ⠋ ⢋ ⠫ ⢫ ⠛ ⢛ ⠻ ⢻
⡃ ⣃ ⡣ ⣣ ⡓ ⣓ ⡳ ⣳ ⡋ ⣋ ⡫ ⣫ ⡛ ⣛ ⡻ ⣻
⠇ ⢇ ⠧ ⢧ ⠗ ⢗ ⠷ ⢷ ⠏ ⢏ ⠯ ⢯ ⠟ ⢟ ⠿ ⢿
⡇ ⣇ ⡧ ⣧ ⡗ ⣗ ⡷ ⣷ ⡏ ⣏ ⡯ ⣯ ⡟ ⣟ ⡿ ⣿]]):gsub('\n',' ')function GenerateDotData()function ToBinary(__a)local __t={}while __a>0 do local __r=math.fmod(__a,2)__t[#__t+1]=string.sub(__r,1,1)__a=(__a-__r)/2 end local __s=string.reverse(table.concat(__t))return string.rep('0',8 -#__s)..__s end local function __format(__s)return __s end local __t=Split(__dotdata,' ')local __newt={}local __inputa=false local __str=''local __sep=' 'for i=1,#__t do __newt[i-1]=__format(__t[i])end return __newt end __Pixel.Data={}__Pixel.Data.Dot=GenerateDotData()__Pixel.ColorData={reset=0,clear=0,space=0,bright=1,bold=1,dim=2,faint=1,italic=3,underline=4,blink=5,reverse=7,invisible=8,hidden=8,strikethrough=9,black=30,red=31,green=32,yellow=33,blue=34,purple=35,magenta=35,cyan=36,white=37,onblack=40,onred=41,ongreen=42,onyellow=43,onblue=44,onpurple=45,onmagenta=45,oncyan=46,onwhite=47}__Pixel.Color={}for __k,__v in pairs(__Pixel.ColorData)do __Pixel.Color[__k]='\27['..__v..'m'end local __minx,__maxx=__trackstart,__tracklength local __miny,__maxy=-__tracky,__tracky __miny,__maxy=-20,20 __Pixel.Convert={}__Pixel.Convert.ToDots=function(__str,__outoffsetx)__outoffsetx=__outoffsetx or 0 local __minx,__maxx=__minx+__outoffsetx,__maxx+__outoffsetx local __data,__colordata=__str.Data,__str.Color local __out={}local __zerostring=0 local __zerodot=__Pixel.Data.Dot[__zerostring]local __currentcolor=nil local __allcolor=nil local __resetcolor=__Pixel.Color['reset']if __str.Color.All then local __c=__Pixel.Color[__str.Color.All]__out[#__out+1]=__c __allcolor=__c end if not __miny then return''end for y=__miny,__maxy,4 do for x=__minx,__maxx,2 do local __dx=__data[x]local __dx2=__data[x+1]local __pixel=(__dx and( (__dx[y]or 0)*128 + (__dx[y+1]or 0)*64 + (__dx[y+2]or 0)*32 + (__dx[y+3]or 0)*16)or 0)+ (__dx2 and( (__dx2[y]or 0)*8 + (__dx2[y+1]or 0)*4 + (__dx2[y+2]or 0)*2 + (__dx2[y+3]or 0))or 0)if __pixel~=__zerostring then __pixel=__Pixel.Data.Dot[__pixel]if not __allcolor then local __dx=__colordata[x]local __dx2=__colordata[x+1]local __color=( (__dx)and(__dx[y]or __dx[y+1]or __dx[y+2]or __dx[y+3]))or( (__dx2)and(__dx2[y]or __dx2[y+1]or __dx2[y+2]or __dx2[y+3]))if __color then __color=__Pixel.Color[__color]else __color=__resetcolor end if __currentcolor==__color then else __out[#__out+1]=__color __currentcolor=__color end end __out[#__out+1]=__pixel else __out[#__out+1]=__zerodot end end __out[#__out+1]='\n'end __out[#__out+1]=__resetcolor return table.concat(__out)end __Pixel.ToDotsParallel=function(__str,__str2,__outoffsetx)__outoffsetx=__outoffsetx or 0 local __minx,__maxx=__minx+__outoffsetx,__maxx+__outoffsetx local __data,__colordata=__str.Data,__str.Color local __data2,__colordata2=__str2.Data,__str2.Color local __out={}local __zerostring=0 local __zerodot=__Pixel.Data.Dot[__zerostring]local __currentcolor=nil local __allcolor=nil local __resetcolor=__Pixel.Color['reset']if __str.Color.All then local __c=__Pixel.Color[__str.Color.All]__out[#__out+1]=__c __allcolor=__c end if not __miny then return''end for y=__miny,__maxy,4 do for x=__minx,__maxx,2 do local __dx=__data[x]local __dx2=__data[x+1]local __dx21=__data2[x]local __dx22=__data2[x+1]local __pixel=( (__dx and __dx21)and( (__dx[y]or __dx21[y]or 0)*128 + (__dx[y+1]or __dx21[y+1]or 0)*64 + (__dx[y+2]or __dx21[y+2]or 0)*32 + (__dx[y+3]or __dx21[y+3]or 0)*16)or(__dx)and( (__dx[y]or 0)*128 + (__dx[y+1]or 0)*64 + (__dx[y+2]or 0)*32 + (__dx[y+3]or 0)*16)or(__dx21)and( (__dx21[y]or 0)*128 + (__dx21[y+1]or 0)*64 + (__dx21[y+2]or 0)*32 + (__dx21[y+3]or 0)*16)or 0)+ ( (__dx2 and __dx22)and( (__dx2[y]or __dx22[y]or 0)*8 + (__dx2[y+1]or __dx22[y+1]or 0)*4 + (__dx2[y+2]or __dx22[y+2]or 0)*2 + (__dx2[y+3]or __dx22[y+3]or 0))or(__dx2)and( (__dx2[y]or 0)*8 + (__dx2[y+1]or 0)*4 + (__dx2[y+2]or 0)*2 + (__dx2[y+3]or 0))or(__dx22)and( (__dx22[y]or 0)*8 + (__dx22[y+1]or 0)*4 + (__dx22[y+2]or 0)*2 + (__dx22[y+3]or 0))or 0)if __pixel~=__zerostring then __pixel=__Pixel.Data.Dot[__pixel]if not __allcolor then local __dx21=__colordata2[x]local __dx22=__colordata2[x+1]local __dx=__colordata[x]local __dx2=__colordata[x+1]local __color=__dx and(__dx[y]or __dx[y+1]or __dx[y+2]or __dx[y+3])or __dx2 and(__dx2[y]or __dx2[y+1]or __dx2[y+2]or __dx2[y+3])or __dx21 and(__dx21[y]or __dx21[y+1]or __dx21[y+2]or __dx21[y+3])or __dx22 and(__dx22[y]or __dx22[y+1]or __dx22[y+2]or __dx22[y+3])if __color then __color=__Pixel.Color[__color]else __color=__resetcolor end if __currentcolor==__color then else __out[#__out+1]=__color __currentcolor=__color end end __out[#__out+1]=__pixel else __out[#__out+1]=__zerodot end end __out[#__out+1]='\n'end __out[#__out+1]=__resetcolor return table.concat(__out)end __Pixel.CircleGen=function(__str,__cx,__cy,__r,__options)__options=__options or{}local __color=__options.color local __r2=__r*__r local __x=__r for y=0,__r do __x=__x+1 repeat __x=__x-1 until __x*__x+y*y<=__r2 for x2=0,__x do __str.Data[__cx+x2]=__str.Data[__cx+x2]or{}__str.Data[__cx-x2]=__str.Data[__cx-x2]or{}__str.Data[__cx+x2][__cy+y]='1'__str.Data[__cx-x2][__cy+y]='1'__str.Data[__cx+x2][__cy-y]='1'__str.Data[__cx-x2][__cy-y]='1'__str.Color[__cx+x2]=__str.Color[__cx+x2]or{}__str.Color[__cx-x2]=__str.Color[__cx-x2]or{}__str.Color[__cx+x2][__cy+y]=__color __str.Color[__cx-x2][__cy+y]=__color __str.Color[__cx+x2][__cy-y]=__color __str.Color[__cx-x2][__cy-y]=__color end end return __str end local __circlecache={}__Pixel.Circle=function(__str,__cx,__cy,__r,__options)local __circle=nil if __circlecache[__r]then else __circlecache[__r]=__Pixel.CircleGen(__Pixel.New(),0,0,__r)end local __c=__options and __options.color __circle=__circlecache[__r]for __x,__v in pairs(__circle.Data)do for __y,__v2 in pairs(__v)do local __x,__y=__x+__cx,__y+__cy __str.Data[__x]=__str.Data[__x]or{}__str.Data[__x][__y]=__v2 __str.Color[__x]=__str.Color[__x]or{}__str.Color[__x][__y]=__c end end return __str end __Pixel.New=function()return{Data={},Color={}}end __OptimizedPixel=__Pixel end local function __RenderBarline(__out,__note)local __x=math.floor(__note.p)local __y1,__y2=__y-__tracky,__y+__tracky for y=__y1,__y2 do local __a=__out.Data[__x]and __out.Data[__x][y]if __a=='0'or __a==nil then __out.Data[__x]=__out.Data[__x]or{}__out.Data[__x][y]='1'end end end local function __RenderCircle(__out,__note,__p)__p=__p or __note.p __Pixel.Circle(__out,math.floor(__p),__y,__noteradius*__note.radius,__renderconfig[__note.type])end local function __RenderRect(__out,__x1,__x2,__y1,__y2,__options)local __options=__options or{}color=__options.color for y=__y1,__y2 do for x=__x1,__x2 do __out.Data[x]=__out.Data[x]or{}__out.Data[x][y]='1'if color then __out.Color[x]=__out.Color[x]or{}__out.Color[x][y]=color end end end end local function __RenderNote(__out,__note,__speedopt)local __n=__note.type if __n==1 or __n==2 or __n==3 or __n==4 then __RenderCircle(__out,__note)elseif __n==5 or __n==6 then __RenderCircle(__out,__note)local __endnote=__note.endnote local __length=(__endnote.ms-__note.ms)*__note.speed __RenderCircle(__out,__note)local __r=__noteradius*__note.radius local __x1,__x2=math.floor(__note.p),math.floor(__note.p+__length)local __y1=math.floor(__y-__r)local __y2=math.floor(__y+__r)if __speedopt then else local __a1=(__trackstart-__bufferlength)if __x1 <__a1 then __x1=__a1 end local __a2=(__tracklength+__bufferlength)if __x2 >__a2 then __x2=__a2 end end __RenderRect(__out,__x1,__x2,__y1,__y2,__renderconfig[__note.type])elseif __n==8 then __RenderCircle(__out,__note.startnote,__note.p)end end local function __RenderStatus(__out,__status,__ms,__outoffsetx)local __slope=__statusanimationmove/ (__statusanimationlength/2)local __anim=-__slope*math.abs(( (__ms-__status.startms)/ (__statuslength/__statusanimationlength))- (__statusanimationmove/__slope))+__statusanimationmove local __t=__timingpixel[__status.status]local __o=__t.Offset local __c=__t.Color.All local __ox,__oy=0,-math.floor(__noteradius*1.6)-8 -math.floor(__anim)local __tox,__toy=__o[1]+__ox+__outoffsetx,__o[2]+__oy for x=1,__timingpixel.Size[1]do for y=1,__timingpixel.Size[2]do local __px,__py=x+__tox,y+__toy __out.Data[__px]=__out.Data[__px]or{}__out.Data[__px][__py]=__t.Data[x]and __t.Data[x][y]__out.Color[__px]=__out.Color[__px]or{}__out.Color[__px][__py]=__c end end end local function __RenderFlash(__out,__status)local __t=__flashpixel[__status.status]local __o=__t.Offset local __c=__t.Color.All local __ox,__oy=0,0 for __x,__v in pairs(__t.Data)do for __y,__v2 in pairs(__v)do if __v2 =='1'then local __x,__y=__x+__o[1]+__ox,__y+__o[2]+__oy __out.Data[__x]=__out.Data[__x]or{}__out.Data[__x][__y]=__v2 __out.Color[__x]=__out.Color[__x]or{}__out.Color[__x][__y]=__c end end end end local __Ansi={ClearScreen=function()io.write"\27[2J"end,SetCursor=function(__x,__y)io.write(string.format("\27[%d;%dH",__y,__x))end}local __notetable=Taiko.GetAllNotes(__Parsed.Data)local __startms=__Parsed.Metadata.OFFSET local __framems=1000 /60 local __timing=__Parsed.Metadata.TIMING(__framems)local function __IsNote(__note)return(__note.data=='note')or(__note.data=='event'and __note.event=='barline')end local function __CalculateLoadMs(__note,__ms)return __ms- (( (__tracklength+__bufferlength)/math.abs(__note.speed)))end local function __CalculateLoadPosition(__note,__lms)return(__note.ms-__lms)*__note.speed+__target end local function __CalculatePosition(__note,__ms)return __note.loadp- (__note.speed* (__ms-__note.loadms))end local __timet={}for __k,__v in pairs(__notetable)do __v.ms=__v.oms or __v.ms __v.oms=__v.ms __v.ms=(__v.ms-__startms)/__songspeedmul __v.s=MsToS(__v.ms)__v.speed=(Taiko.CalculateSpeed(__v,__noteradius))*__notespeedmul __v.loadms=__CalculateLoadMs(__v,__v.ms)__v.loads=MsToS(__v.loadms)__v.loadp=__CalculateLoadPosition(__v,__v.loadms)__v.hit=nil __timet[#__timet+1]=__v.ms end for __k,__v in pairs(__Parsed.Data)do if __v.branch then for __k2,__v2 in pairs(__v.branch.paths)do table.sort(__v2,function(__a,__b)return __a.loadms<__b.loadms end)end end end table.sort(__Parsed.Data,function(__a,__b)if __a.branch and __b.branch then for __k,__v in pairs(__a.branch.paths)do for __k2,__v2 in pairs(__b.branch.paths)do return __v[1].loadms<__v2[1].loadms end end elseif __a.branch then for __k,__v in pairs(__a.branch.paths)do return __v[1].loadms<__b.loadms end elseif __b.branch then for __k,__v in pairs(__b.branch.paths)do return __a.loadms<__v[1].loadms end else return __a.loadms<__b.loadms end end)Taiko.ConnectAll(__Parsed.Data)Taiko.ForAll(__Parsed.Data,function(__note,__i,__n)__note.n=__n end)local __endms=math.max(unpack(__timet))+ (__endms/__songspeedmul)local __loaded={s=1,e=0,n=0}local __nextnote=__Parsed.Data[1]local __nextnotel=__nextnote.loads __loaded.e=__loaded.n local __padding=10 local __paddingstr=string.rep(' ',__padding)local __statistics={}local function __Statistic(__k,__v)__statistics[#__statistics+1]=__k __statistics[#__statistics+1]=': '__statistics[#__statistics+1]=tostring(__v)__statistics[#__statistics+1]=__paddingstr __statistics[#__statistics+1]='\n'end local function __RenderStatistic()print(table.concat(__statistics))__statistics={}end local __logs=''local function __Log(__s)__logs=__logs..'\n'..__s end local function __RenderLog()print(__logs)end __Ansi.ClearScreen()local __branch='M'local __laststatus={startms=nil,status=nil}local __lastinput={-1,nil}local __framen=0 local __framerenderstotal=0 local __dorender=true local __dospeedopt=true local __speedopt=false local __speedoptspeed=nil local __speedoptoldpos=nil local __speedoptout=nil local __speedoptfirstnote=nil local __speedoptstartms=nil local __speedoptstatus=nil if __framerate then local __frames=1 /__framerate local __nextframes=nil end local __startt=os.clock()if __framerate then nextframes=__startt+frames end if not __prerender.on then while true do local __out=__Pixel.New()local __raws=os.clock()local __s=__raws-__startt local __ms=__s*1000 if __nextnote then if __nextnote.loadms<__ms then __loaded.n=__loaded.n+1 __loaded.e=__nextnote.n __loaded[__nextnote.n]=__nextnote if __speedopt and __nextnote.speed~=__speedoptspeed then __speedopt=false end if __speedopt then __nextnote.p=__CalculatePosition(__nextnote,__speedoptstartms)if __nextnote.data=='event'then if __nextnote.event=='barline'then __RenderBarline(__speedoptout,__nextnote,__speedopt)end elseif __nextnote.data=='note'then __RenderNote(__speedoptout,__nextnote,__speedopt)else error'Invalid note.data'end end __nextnote=__nextnote.nextnote if __nextnote and __nextnote.branch then __nextnote=__nextnote.branch.paths[__branch][1]end end else if __ms>__endms then break end end if __dospeedopt and __speedopt==false then local __s=nil for i=__loaded.s,__loaded.e do if __s then if __loaded[i]and __s~=__loaded[i].speed then __s=false break end else __s=__loaded[i].speed end end if __s then __speedoptstartms=__ms __speedoptspeed=__s __speedoptout=false __speedoptfirstnote=__loaded[__loaded.s]or __loaded[__loaded.s+1]__speedopt=true else __speedopt=false end end local __outoffsetx=0 if __speedopt and __speedoptout then __dorender=false local __firstnote=__loaded[__loaded.s]or __loaded[__loaded.s+1]local __oldpos=__speedoptoldpos or __firstnote.p __speedoptoldpos=__oldpos local __newpos=__CalculatePosition(__speedoptfirstnote,__ms)__oldpos=__oldpos or __newpos local __dif=math.floor(__oldpos-__newpos+0.5)if __dif>=1 then __outoffsetx=__dif else end __out=__speedoptout else __speedoptoldpos=nil __dorender=true end if __dorender and __speedoptout~=false then __Pixel.Circle(__out,math.floor(__target),__y,__noteradius,{color='purple'})end if __speedopt then __speedoptstatus=__Pixel.New()__Pixel.Circle(__speedoptstatus,math.floor(__target)+__outoffsetx,__y,__noteradius,{color='purple'})end local __nearest={}local __nearestnote={}for i=__loaded.s,__loaded.e do local __note=__loaded[i]if __note then if __note.data=='note'then if(__note.type==1 or __note.type==3)and(not __nearest[1]or math.abs(__ms-__note.ms)<__nearest[1])then __nearest[1]=math.abs(__ms-__note.ms)__nearestnote[1]=__note elseif(__note.type==2 or __note.type==4)and(not __nearest[2]or math.abs(__ms-__note.ms)<__nearest[2])then __nearest[2]=math.abs(__ms-__note.ms)__nearestnote[2]=__note end end __note.p=__CalculatePosition(__note,__ms)if math.abs(__note.p-__target)> (__tracklength+__bufferlength+1)then if __note.endnote and __note.endnote.done~=true then else __note.done=true __loaded[i]=nil if __nextnote and __loaded.n==0 then __loaded.s=__nextnote.n elseif __note.n==__loaded.s then if __note.n==__loaded.e then __loaded.n=0 else local __i2=__loaded.s repeat __i2=__i2 +1 __loaded.n=__loaded.n-1 until __loaded[__i2]__loaded.s=__i2 end end end else if __dorender then if __note.data=='event'then if __note.event=='barline'then __RenderBarline(__out,__note)end elseif __note.data=='note'then __RenderNote(__out,__note)else error'Invalid note.data'end end end end end if __speedoptout==false then __speedoptout=__out end if __laststatus.status then if __ms>__laststatus.startms+__statuslength then __laststatus={}else if __speedopt then __RenderStatus(__speedoptstatus,__laststatus,__ms,__outoffsetx)else __RenderStatus(__out,__laststatus,__ms,__outoffsetx)end end end __Ansi.SetCursor(1,1)if __speedopt then if __speedoptstatus then print(__Pixel.ToDotsParallel(__out,__speedoptstatus,__outoffsetx))else print(__Pixel.Convert.ToDots(__out,__outoffsetx))end else if __framerate then local __dots=__Pixel.Convert.ToDots(__out,__outoffsetx)repeat until os.clock()>=nextframes nextframes=nextframes+frames print(__dots)else print(__Pixel.Convert.ToDots(__out,__outoffsetx))end end __framen=__framen+1 local __framerenders=os.clock()-__raws __framerenderstotal=__framerenderstotal+__framerenders local __input=__curses.getch(__window)local __key=__curses.getkeyname(__input)local __v=__Controls.Hit[__key]if __auto then local __n1=__nearest[1]local __n2=__nearest[2]local __testv=(__nearest[1]and __nearest[2])and( (__nearest[1]<__nearest[2])and 1 or 2)or(__nearest[1]and 1 or 2)local __n=__nearest[__testv]local __note=__nearestnote[__testv]if __n and __ms>__note.ms and(not __note.hit)then if __autoemu then __v=__testv else __note.hit=true local __a=__note.type local __status=( (__a==3 or __a==4)and 3)or 2 __laststatus={startms=__ms,status=__status}end end end if __v and __nearest[__v]and(not __nearestnote[__v].hit)then local __n=__nearest[__v]local __status local __a=__nearestnote[__v].type local __leniency=( (__a==3 or __a==4)and Taiko.Data.BigLeniency)or 1 if __n< (__timing.good)then local __a=__nearestnote[__v].type __status=( (__a==3 or __a==4)and 3)or 2 elseif __n< (__timing.ok*__leniency)then __status=1 elseif __n< (__timing.bad*__leniency)then __status=0 else __status=nil end if __status then __nearestnote[__v].hit=true __laststatus={startms=__ms,status=__status}end end if __Controls.Escape[__key]then local __before=os.clock()__Ansi.ClearScreen()__curses.nodelay(__window,false)local __Menu={'Back','Retry','Back to Select'}while true do __Ansi.SetCursor(1,1)local __o={}for i=1,#__Menu do __o[i]=( (i==__Selected)and(__SelectedChar..string.rep(' ',__SelectedPadding-#__SelectedChar))or string.rep(' ',__SelectedPadding))..__Menu[i]end print(table.concat(__o,__MenuConcat))local __input=__curses.getch(__window)local __key=__curses.getkeyname(__input)if __Controls.L[__key]then __Selected=__Selected==1 and 1 or __Selected-1 elseif __Controls.R[__key]then __Selected=__Selected==3 and 3 or __Selected+1 elseif __Controls.Select[__key]then if __Selected==1 then elseif __Selected==2 then return'Retry'elseif __Selected==3 then return nil end break elseif __Controls.Escape[__key]then break end end __curses.nodelay(__window,true)__startt=__startt+ (os.clock()-__before)end if __input~=-1 then __lastinput={__input,__key}end __Statistic('Input (ascii)',__lastinput[1])__Statistic('Input (key)',__lastinput[2])__Statistic('S',__s)__Statistic('Ms',__ms)__Statistic('Loaded',__loaded.n)__Statistic('Frames Rendered',__framen)__Statistic('Last Frame Render (s)',__framerenders)__Statistic('Last Frame Render (ms)',__framerenders*1000)__Statistic('Frame Render Total (s)',__framerenderstotal)__Statistic('Frame Render Total (ms)',__framerenderstotal*1000)__Statistic('Frame Render Total (%)',__framerenderstotal/__s*100)__Statistic('FPS (Frame)',__framen/__s)__Statistic('Memory Usage (mb)',collectgarbage'count'/1000)__Statistic('Finished (%)',__ms/ (__endms)*100)__Statistic('Nearest1 (ms)',__nearest[1])__Statistic('Nearest2 (ms)',__nearest[2])__Statistic('Song Name',__Parsed.Metadata.TITLE)__Statistic('Difficulty (id)',__Parsed.Metadata.COURSE)__Statistic('Stars',__Parsed.Metadata.LEVEL)__RenderStatistic()__RenderLog()end else error'Prerendering has been removed'end return true end function Taiko.SongSelect(__header,__data)local __Display={}local __dx,__dy=10,10 local __dminx,__dmaxx,__dminy,__dmaxy=-__dx,__dx,-__dy,__dy local __Vertical=true local __Selected=1 local __SelectedOption=1 local __SelectedOptionIndex=4 local __DisplayN=5 local __Spacing=5 local __TopSpacing=2 local __SelectedChar='V'local __SelectedCharVertical='>'local __SearchN=10 local __Padding=nil local __SearchSelected='>'local __OptionSelected='>'local __OptionSpacing=2 local __ParsedCacheOn=true local __Options={[2]={'Normal','Auto'},[3]={'Normal','2x Speed','3x Speed','4x Speed','0.25x Speed','0.5x Speed','0.75x Speed'},[4]={'Normal','2x Speed','3x Speed','4x Speed','0.25x Speed','0.5x Speed','0.75x Speed'},[5]={'TODO Normal'}}local __OptionsConfig={4,1,1,1,1,1}local __OptionsLimit={nil}for __k,__v in pairs(__Options)do __OptionsLimit[__k]={1,#__v,__v}end local __Compact=require'./CompactTJA/compactv4'local __curses=require'taikocurses'local __window={window=__curses.initscr()}__curses.keypad(__window,true)__curses.echo(false)__curses.raw(true)__curses.nl(false)__curses.cbreak(true)__curses.nodelay(__window,true)__curses.getch(__window)__curses.nodelay(__window,false)local __cols,__lines=__curses.cols(),__curses.lines()__Padding=__Padding or __cols-2 local __Controls={Escape={['\27']=true,ALT_ESC=true},Scroll={L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_A2=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true}},Select={Init={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Escape={['\27']=true,ALT_ESC=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true},U={KEY_UP=true,KEY_A2=true},D={KEY_DOWN=true,KEY_C2=true},Play={Hit={['4']=2,['v']=1,['n']=1,['8']=2},Escape={['\27']=true,ALT_ESC=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_DOWN=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}}},Search={Init={ALT_F=true,f=true,F=true},Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},FirstResult={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},Select={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true},Up={KEY_A2=true,KEY_UP=true},Down={KEY_C2=true,KEY_DOWN=true},Escape={['\27']=true,ALT_ESC=true}},Add={Init={ALT_N=true,n=true,N=true},Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},Select={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true}},StandardInput={Backspace={['\8']=true,KEY_BACKSPACE=true,ALT_BKSP,CTL_BKSP},Escape={KEY_ENTER=true,PADENTER=true,CTL_PADENTER=true,ALT_PADENTER=true,CTL_PADCENTER=true,ALT_ENTER=true,CTL_ENTER=true,SHF_PADENTER=true,['\n']=true,['\r']=true},L={KEY_LEFT=true,KEY_SLEFT=true,CTL_LEFT=true,KEY_B1=true,ALT_LEFT=true,KEY_SHIFT_L=true,KEY_UP=true,KEY_DOWN=true},R={KEY_RIGHT=true,KEY_SRIGHT=true,CTL_RIGHT=true,KEY_B3=true,ALT_RIGHT=true,KEY_SHIFT_R=true,KEY_DOWN=true,KEY_C2=true}}}local __Ansi={ClearScreen=function()io.write"\27[2J"end,SetCursor=function(__x,__y)io.write(string.format("\27[%d;%dH",__y,__x))end,ClearLine=function()io.write"\27[2K"end,CursorLeft=function(__amount)io.write(string.format("\27[%dD",__amount))end,CursorRight=function(__amount)io.write(string.format("\27[%dC",__amount))end,SaveCursor=function()io.write"\27[s"end,RestoreCursor=function()io.write"\27[u"end}local function __Pad(__str)return __str..string.rep(' ',__Padding-#__str)end local function __Input()local __input=__curses.getch(__window)local __key=__curses.getkeyname(__input)return __input,__key end local function __StandardInput()local __str=''local __pos=0 local __oldpos=__pos while true do local __input,__key=__Input()if __Controls.StandardInput.Backspace[__key]then __str=string.sub(__str,1,__pos-1)..string.sub(__str,__pos+1,-1)__pos=__pos-1 elseif __Controls.StandardInput.Escape[__key]then io.write'\n'return __str elseif __Controls.StandardInput.L[__key]then __pos=__pos-1 elseif __Controls.StandardInput.R[__key]then __pos=__pos+1 else __str=string.sub(__str,1,__pos)..__key..string.sub(__str,__pos+1,-1)__pos=__pos+1 end __pos=ClipN(__pos,0,#__str)local __dif=__pos-__oldpos if __dif<0 then __Ansi.CursorLeft(-__dif)elseif __dif>0 then __Ansi.CursorRight(__dif)end __Ansi.SaveCursor()__Ansi.ClearLine()io.write'\r'io.write(__str)__Ansi.RestoreCursor()__oldpos=__pos end end local function __IsValid(__byte)return __byte>=32 and __byte<=126 end local function __Select(__on,__char,__pad,__str)return(__on and(__char..string.sub(__pad,#__char+1,-1))or __pad)..__str end local function __Wrap(__n,__min,__max)return __n>__max and __min or __n<__min and __max or __n end local __Bool={[0]='No',[1]='Yes'}local function __ConvertBool(__bool)return __bool and __Bool[1]or __Bool[0]end local function __ConvertPercent(__percent)return __percent*100 ..'%'end local function __ConvertMs(__ms)return MsToS(__ms)..'s'end local function __ConvertS(__s)return __ConvertMs(SToMs(__s))end local function __ConvertN(__n)return tonumber(__n)and tonumber(__n)or 0 end local __ParsedCache={}__Ansi.ClearScreen()while true do __Display={}if __Vertical then __Display[__dminx]={}for i=__Selected-__DisplayN,__Selected+__DisplayN do local __index=nil if i<1 then __index=#__header+i elseif i>#__header then __index=i-#__header else __index=i end local __song=__header[__index]if __song then __Display[0]=__Display[0]or{}__Display[0][(i-__Selected)*__Spacing]=__song end end local __out={}local __ts=string.rep(' ',__TopSpacing)for y=__dminy,__dmaxy do __out[#__out+1]=__Select(y==0,__SelectedCharVertical,__ts,'')__out[#__out+1]=__Pad(__Display[0][y]or'')__out[#__out+1]='\n'end __Ansi.SetCursor(1,1)print(table.concat(__out))else __Display[0]={}__Display[0][__dminy]=__SelectedChar for i=__Selected-__DisplayN,__Selected+__DisplayN do local __index=nil if i<1 then __index=#__header+i elseif i>#__header then __index=i-#__header else __index=i end local __song=__header[__index]if __song then local __x=(i-__Selected)*__Spacing __Display[__x]=__Display[__x]or{}local __y=__dminy+__TopSpacing for i2=1,#__song do __Display[__x][__y]=string.sub(__song,i2,i2)__y=__y+1 end end end local __out={}for y=__dminy,__dmaxy do for x=__dminx,__dmaxx do if __Display[x]and __Display[x][y]then local __a=__Display[x][y]if __IsValid(string.byte(__a))then __out[#__out+1]=__a else __out[#__out+1]=' 'end else __out[#__out+1]=' 'end end __out[#__out+1]='\n'end __Ansi.SetCursor(1,1)print(table.concat(__out))end local __input,__key=__Input()if __Controls.Scroll.L[__key]then __Selected=__Selected-1 elseif __Controls.Scroll.R[__key]then __Selected=__Selected+1 elseif __Controls.Select.Init[__key]then local __Parsed if __ParsedCacheOn then if __ParsedCache[__Selected]then __Parsed=__ParsedCache[__Selected]else __Parsed=Taiko.ParseTJA(__data[__Selected])__ParsedCache[__Selected]=__Parsed end else __Parsed=Taiko.ParseTJA(__data[__Selected])end local __map={}for __k,__v in pairs(__Parsed)do __map[#__map+1]={__k,__v.Metadata.COURSE}end table.sort(__map,function(__a,__b)return __a[2]<__b[2]end)min=1 max=#__map __OptionsLimit[__SelectedOption]={min,max,__map}DifficultyMap=__map local __pad=string.rep(' ',__OptionSpacing)__Ansi.ClearScreen()__Ansi.SetCursor(1,1)local __ParsedData=nil local __lastoption=__SelectedOption while true do __SelectedOption=ClipN(__SelectedOption,1,5)if __SelectedOption~=__lastoption then __SelectedOptionIndex=__OptionsConfig[__SelectedOption]__lastoption=__SelectedOption end local __a=__OptionsLimit[__SelectedOption]min,max=__a[1],__a[2]__SelectedOptionIndex=__Wrap(__SelectedOptionIndex,min,max)__OptionsConfig[__SelectedOption]=__SelectedOptionIndex __Ansi.SetCursor(1,1)local __SelectedDifficulty=DifficultyMap[__OptionsConfig[1]][2]__ParsedData=Taiko.GetDifficulty(__Parsed,__SelectedDifficulty)local __m=__ParsedData.Metadata local __a=Taiko.Analyze(__ParsedData)local __t={{'',__m.TITLE},{'\t',__m.SUBTITLE},{'',''},{'','Select Options:'},{__Select(__SelectedOption==1,__OptionSelected,__pad,'Difficulty: '),Taiko.Data.CourseName[__m.COURSE]},{__Select(__SelectedOption==2,__OptionSelected,__pad,'Mode: '),__Options[2][__OptionsConfig[2]]},{__Select(__SelectedOption==3,__OptionSelected,__pad,'Note Speed: '),__Options[3][__OptionsConfig[3]]},{__Select(__SelectedOption==4,__OptionSelected,__pad,'Song Speed: '),__Options[4][__OptionsConfig[4]]},{__Select(__SelectedOption==5,__OptionSelected,__pad,'Modifiers: '),__Options[5][__OptionsConfig[5]]},{'',''},{'Difficulty: ',Taiko.Data.CourseName[__m.COURSE]},{'Stars: ',__m.LEVEL},{'Diverge Notes: ',__ConvertBool(__m.DIVERGENOTES)},{'',''},{'','Statistics:'},{'Don (DON) / Ka (KA): ',__ConvertN(__a.notes[1])..' + ('..__ConvertN(__a.notes[3])..') / '..__ConvertN(__a.notes[2])..' + ('..__ConvertN(__a.notes[4])..') = '..__ConvertPercent((__ConvertN(__a.notes[1])+__ConvertN(__a.notes[3]))/__a.notes.validn)..' / '..__ConvertPercent((__ConvertN(__a.notes[2])+__ConvertN(__a.notes[4]))/__a.notes.validn)},{'Max Score (without drumroll): ',__a.maxscore},{'Max Combo: ',__a.maxcombo},{'Drumroll Time (total): ',__ConvertMs(__a.drumrollms+__a.drumrollbigms)},{'Balloon Time: ',__ConvertMs(__a.balloonms)},{'Balloon Hits: ',__a.balloonhit},{'Special Time: ',__ConvertMs(__a.specialms)},{'Special Hits: ',__a.specialhit},{'',''},{'','Press Enter to Play!'}}for i=1,#__t do local __d=__t[i]print(__Pad(__d[1]..tostring(__d[2])))end local __input,__key=__Input()if __Controls.Select.L[__key]then __SelectedOptionIndex=__SelectedOptionIndex-1 elseif __Controls.Select.R[__key]then __SelectedOptionIndex=__SelectedOptionIndex+1 elseif __Controls.Select.U[__key]then __SelectedOption=__SelectedOption-1 elseif __Controls.Select.D[__key]then __SelectedOption=__SelectedOption+1 elseif __Controls.Select.Select[__key]then while true do local __success,__out=Taiko.PlaySong(Taiko.GetDifficulty(__Parsed,__SelectedDifficulty),__window,__OptionsConfig,__Controls.Select.Play)if __success and __out then break elseif __success=='Retry'then else break end end __curses.nodelay(__window,false)elseif __Controls.Select.Escape[__key]then break end end elseif __Controls.Search.Init[__key]then local __str=''local __results={}local __max=1 local __result=nil local __selected=1 __Ansi.ClearScreen()__Ansi.SetCursor(1,1)print'Searching...'while true do __Ansi.SetCursor(#__str+1,2)local __input,__key=__Input()__Ansi.SetCursor(1,2)if __Controls.Search.Backspace[__key]then __str=string.sub(__str,1,-2)elseif __Controls.Search.FirstResult[__key]then __result=__results[1]break elseif __Controls.Search.Select[__key]then __result=__results[__selected]break elseif __Controls.Search.Down[__key]then __selected=__selected+1 elseif __Controls.Search.Up[__key]then __selected=__selected-1 elseif __Controls.Search.Escape[__key]then break else __str=__str..__key end print(__Pad(__str))local __t=__Compact.SearchHeaderAll(__header,__str)for i=1,__SearchN do if __t[i][2]==-math.huge then __max=i-1 break elseif i==__SearchN then __max=i end end __selected=ClipN(__selected,1,__max)local __padmode=false for i=1,__SearchN do local __a=__t[i]if __padmode then print(__Pad'')else if __a then if __a[2]==-math.huge then __padmode=true print(__Pad'')else print(__Pad((i==__selected and __SearchSelected or i)..'. '..__t[i][3]))__results[i]=__a end end end end end __Selected=(__result and __result[1]or __Selected)or __Selected elseif __Controls.Add.Init[__key]then print'Import a Custom Song'while true do print'Enter a .tja or .tjac file path (with the file extention)'local __input=__StandardInput()local __file=io.open(__input,'rb')if __file then local __data2=__file:read'*all'if EndsWith(__input,'.tja')then print'Enter a song name'local __input2=__StandardInput()__header[#__header+1]=__input2 __data[#__data+1]=__data2 break elseif EndsWith(__input,'.tjac')then local __t,__h=__Compact.Decompress(__data2)for i=1,#__t do __data[#__data+1]=__t[i]__header[#__header+1]=__h[i]end break else print'Invalid file type'end io.close(__file)else print'Unable to read file'end end elseif __Controls.Escape[__key]then return end __Selected=__Wrap(__Selected,1,#__header)end end local __file='./CompactTJA/taikobuipm.tjac'__file='./CompactTJA/ESE/06 Classical.tjac'__file='./CompactTJA/ESE/ESE.tjac'local __Compact=require'./CompactTJA/compactv4'local __t,__header=__Compact.Decompress(__Compact.Read(__file))Taiko.SongSelect(__header,__t)error()Taiko.PlaySong(Taiko.GetDifficulty(Taiko.ParseTJA(__Compact.InputFile(__file)),'Ura'))